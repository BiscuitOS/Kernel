BIOS
-----------------------------------------------------------
INT 00 - DIVIDE ERROR (internal interrupt)
   Automatically called at end of DIV or IDIV operation that results in error.
   Normally set by DOS to display an error message and abort the program.
-----------------------------------------------------------
INT 01 - SINGLE-STEP (internal interrupt)
   Generated at end of each machine instruction if TF bit in FLAGS is set.
   This is what makes the T command of DEBUG work for single-stepping. It is
   not generated after MOV to segment register or POP of segment register
   (unless you have a very early 8088 with a microcode bug).
-----------------------------------------------------------
INT 02 - NMI (NON-MASKABLE INTERRUPT)
   Generated by NMI signal in hardware.  This signal has various uses:
   Parity error: all except Jr and CONV
   Coprocessor interrupt: all except Jr and CONV
   Keyboard interrupt: Jr, CONV
   I/O channel check: CONV, PS50+
   Disk-controller power-on request: CONV
   System suspend: CONV
   Real-time clock: CONV
   System watch-dog timer, time-out interrupt: PS50+
   DMA timer time-out interrupt: PS50+
-----------------------------------------------------------
INT 03 - 1-BYTE INTERRUPT (internal interrupt)
   Generated by opcode CCh. Similar to 8080's RST instruction. Generally
   used to set breakpoints for DEBUG.
   Also used by Turbo Pascal versions 1,2,3 when {$U+} specified
-----------------------------------------------------------
INT 04 - OVERFLOW (internal interrupt)
   Generated by INTO instruction if OF flag is set.  If flag is not set, INTO
   is effectively a NOP.  Used to trap any arithmetic errors when program is
   ready to handle them rather than immediately when they occur.
-----------------------------------------------------------
INT 05 - PRINT-SCREEN KEY
   Automatically called by keyboard scan when print-screen key is pressed.
   Normally executes routine to print the screen, but may call any routine that
   can safely be executed from inside the keyboard scanner.  Status and result
   byte for default handler is at address 0050:0000.
-----------------------------------------------------------
INT 05 - BOUND CHECK FAILED (80186/80286 internal interrupt)
   Generated by BOUND instruction when the value to be tested is less than the
   indicated lower bound or greater than the indicated upper bound.
-----------------------------------------------------------
INT 06 - UNDEFINED OPCODE (80286 internal interrupt)
-----------------------------------------------------------
INT 07 - NO MATH UNIT AVAILABLE (80286 protected-mode internal)
-----------------------------------------------------------
INT 08 thru 0F - VECTORED HARDWARE LINES
   In IBM, these 8 interrupts are generated in response to IRQ 0 through
   IRQ 7 (if enabled via port 21h).
         [Tandy 1000] [Adapters]
     IRQ0 - timer interrupt
     IRQ1 - keyboard interrupt
     IRQ2 - EGA vertical retrace     [fixed disk] [TOPS&PCnet default]
     IRQ3 - serial port 2 (com2:)   [TOPS&PCnet alternate]
     IRQ4 - serial port 1 (com1:)
     IRQ5 - fixed disk (PC/AT: LPT2) [60 Hz ram refresh]
     IRQ6 - diskette interrupt
     IRQ7 - PPI interrupt (lpt1:, lpt2:)
-----------------------------------------------------------
INT 08 - DOUBLE FAULT (80286 protected-mode internal)
   Called when multiple exceptions occur on one instruction, or an exception
   occurs in an exception handler.  If an exception occurs in the double fault
   handler, the CPU goes into SHUTDOWN mode (which circuitry in the PC/AT
   converts to a reset).
-----------------------------------------------------------
INT 09 - MATH UNIT PROTECTION FAULT (80286 protected-mode internal)
-----------------------------------------------------------
INT 0A - INVALID TASK STATE SEGMENT (80286 protected-mode internal)
-----------------------------------------------------------
INT 0B - NOT PRESENT (80286 protected-mode internal)
   Generated when loading a segment register if the segment descriptor
   indicates that the segment is not currently in memory.
-----------------------------------------------------------
INT 0C - STACK FAULT (80286 protected-mode internal)
   Generated on stack overflow/underflow.  Note that the 80286 will shut down
   in real mode if SP=1 before a push.
-----------------------------------------------------------
INT 0D - GENERAL PROTECTION VIOLATION (80286 internal interrupt)
   Called in real mode when an instruction attempts to access a word operand
   located at offset FFFFh
-----------------------------------------------------------
INT 0E - PAGE FAULT (80386 native-mode internal interrupt)
-----------------------------------------------------------
INT 10 - VIDEO - SET VIDEO MODE
 AH = 00h
 AL = mode (graphics mode if graphics resolution listed)
   text  pixel graphic color disp scrn  system
   resol box  resoltn    page addr
    00h = 40x25 8x8      B&W     8 B800 CGA
    01h = 40x25 8x8      16      8 B800 CGA
    02h = 80x25 8x8      B&W     4 B800 CGA
    03h = 80x25 8x8      16      4 B800 CGA
    04h = 40x25 8x8  320x200 4      1 B800 CGA
    05h = 40x25 8x8  320x200 4 gray  1 B800 CGA
    06h = 80x25 8x8  640x200 B&W     1 B800 CGA
    07h = 80x25 8x14      mono    1 B000 MDA/Hercules
    08h =      160x200 16     ??? B800 PCjr/Tandy 1000
    09h =      320x200 16     ??? B800 PCjr/Tandy 1000
    0Ah =      640x200 4     ??? B800 PCjr/Tandy 1000
    0Bh = reserved (used internally by EGA BIOS)
    0Ch = reserved (used internally by EGA BIOS)
    0Dh =      320x200 16     ??? A000 EGA/VGA
    0Eh =      640x200 16     ??? A000 EGA/VGA
    0Fh =      640x350 mono   ??? A000 EGA/VGA
    10h =      640x350 4or16  ??? A000 EGA/VGA
    11h =      640x480 mono   ??? A000 VGA/MCGA
    12h =      640x480 16     ??? A000 VGA
    13h =      320x200 256    ??? A000 VGA/MCGA
    18h = 132x44 8x8      mono      Tseng Labs EVA
    19h = 132x25 8x14      mono      Tseng Labs EVA
    1Ah = 132x28 8x13      mono      Tseng Labs EVA
    22h = 132x44 8x8      ???      Tseng, Ahead
    23h = 132x25 6x14      ???      Tseng Labs EVA
        = 132x25 8x14      ???      Ahead Systems EGA2001
    24h = 132x28 6x13      ???      Tseng Labs EVA
    25h = 80x60 8x8  640x480 ???      Tseng Labs EVA
    26h = 80x60 8x8      ???      Tseng Labs EVA
        = 80x60 8x8  640x480 ???      Ahead Systems EGA2001
    30h =      ???x??? ???      AT&T 6300
    40h =             640x400   2        B800 AT&T 6300
    48h = 80x50       640x400   2        B800 AT&T 6300
    50h = 132x25 9x14      mono      Ahead Systems EGA2001
        = 80x30 8x16 640x480 ???      Paradise EGA-480
    51h = 80x30 8x16      ???      Paradise EGA-480
    52h = 132x44 9x8      mono      Ahead Systems EGA2001
    54h = 132x43 8x8      ???      Paradise EGA-480
    55h = 132x25 8x14      ???      Paradise EGA-480
    56h = 132x43 8x8      3???   2 B000 NSI Smart EGA+
    57h = 132x25 8x14      3???   4 B000 NSI Smart EGA+
    60h = 80x???      ???x400 ???      Corona/Cordata BIOS v4.10+
    61h =      ???x400 ???      Corona/Cordata BIOS v4.10+
    71h = 100x35 8x16 800x600 16of64 A000 NSI Smart EGA+
    74h =      640x400 ???      Toshiba 3100
    D0h =      640x400   2      DEC VAXmate AT&T mode
    ??? =      640x225 ???      Z-100
    ??? =      640x400 ???      Z-100
-----------------------------------------------------------
INT 10 - VIDEO - SET CURSOR CHARACTERISTICS
 AH = 01h
 CH bits 0-4 = start line for cursor in character cell
    bits 5-6 = blink attribute
       (00=normal, 01=invisible, 10=slow, 11=fast)
 CL bits 0-4 = end line for cursor in char. cell
-----------------------------------------------------------
INT 10 - VIDEO - SET CURSOR POSITION
 AH = 02h
 DH,DL = row, column (0,0 = upper left)
 BH = page number
     0 in graphics modes
     0-3 in modes 2&3
     0-7 in modes 0&1
-----------------------------------------------------------
INT 10 - VIDEO - READ CURSOR POSITION
 AH = 03h
 BH = page number
     0 in graphics modes
     0-3 in modes 2&3
     0-7 in modes 0&1
Return: DH,DL = row,column
 CH = cursor start line
 CL = cursor end line
-----------------------------------------------------------
INT 10 - VIDEO - READ LIGHT PEN POSITION (all but PS)
 AH = 04h
Return: AH = 0: light pen switch not activated
 AH = 1: light pen values in registers
     DH,DL = row,column of current position
     CH = raster line (0-199) (EGA) old graphics modes
     CX = (EGA) raster line (0-nnn) new graphics modes
     BX = pixel column (0-319 or 0-639)
-----------------------------------------------------------
INT 10 - VIDEO - SELECT DISPLAY PAGE
 AH = 05h
 AL =
     0-7: new page value for modes 0 & 1
     0-3: new page value for modes 2 & 3
     80h: read CRT/CPU page registers [PCjr only]
     81h: set CPU page register to value in BL [PCjr only]
     82h: set CRT page register to value in BH [PCjr only]
     83h: set both display registers [PCjr only]
     {Corona/Cordata BIOS v4.10+}
     0: set address of graphics bitmap buffer (video modes 60h,61h)
        BX = segment of buffer
     0Fh: get address of graphics bitmap buffer (video modes 60h,61h)
Return: BH = CRT page register (if AL >= 80h)
 BL = CPU page register (if AL >= 80h)
 DX = segment of graphics bitmap buffer (video modes 60h,61h; AL=0Fh)
-----------------------------------------------------------
INT 10 - VIDEO - SCROLL PAGE UP
 AH = 06h
 AL = number of lines to scroll window (0 = blank whole window)
 BH = attributes to be used on blanked lines
 CH,CL = row,column of upper left corner of window to scroll
 DH,DL = row,column of lower right corner of window
-----------------------------------------------------------
INT 10 - VIDEO - SCROLL PAGE DOWN
 AH = 07h
 AL = number of lines to scroll window (0 = blank whole window)
 BH = attributes to be used on blanked lines
 CH,CL = row,column of upper left corner of window to scroll
 DH,DL = row,column of lower right corner of window
-----------------------------------------------------------
INT 10 - VIDEO - READ ATTRIBUTES/CHARACTER AT CURSOR POSITION
 AH = 08h
 BH = display page
Return: AL = character
 AH = attribute of character (alpha modes)
-----------------------------------------------------------
INT 10 - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POS
 AH = 09h
 AL = character
 BH = display page - alpha modes
 BL = attributes of char (alpha modes) or color (graphics modes)
      if bit 7 == 1 in graphics mode, character is xor'ed onto screen
 CX = number of times to write character
-----------------------------------------------------------
INT 10 - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POS
 AH = 0Ah
 AL = character
 BH = display page - alpha mode
 BL = color of character (graphics mode)
 CX = number of times to write character
      (EGA) in graphics modes, replication count in CX works correctly
      only if all character written are contains on the same row
-----------------------------------------------------------
INT 10 - VIDEO - SET COLOR PALETTE
 AH = 0Bh
 BH = 0
     BL = border color (0-15) (text modes)
   border color and background color (graphics modes)
     (EGA)
     BL = border color (0-15) and high-intensity background color
    (16-31??? maybe should be high nybble?)
 BH = 1
     BL = palette (0/1)
-----------------------------------------------------------
INT 10 - VIDEO - WRITE DOT ON SCREEN
 AH = 0Ch
 AL = color of dot (0/1 in mode 6, 0-3 in modes 4 and 5)
      if bit 7 set, new color will be XORed with current pixel
 DX = row (0 - 199)
 CX = column (0 - 319 in modes 4/5/13, 0 - 639 in modes 6/14/15/16)
Note: only valid in graphics modes
-----------------------------------------------------------
INT 10 - VIDEO - READ DOT ON SCREEN
 AH = 0Dh
 CX = column (0 - 319 or 639)
 DX = row (0 - 199)
Return: AL = color read
-----------------------------------------------------------
INT 10 - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
 AH = 0Eh
 AL = character
 BH = display page (alpha modes)
 BL = foreground color (graphics modes)
-----------------------------------------------------------
INT 10 - VIDEO - GET CURRENT VIDEO MODE
 AH = 0Fh
Return: AH = number of columns on screen
 AL = current video mode (see INT 10h/AH=00h)
 BH = current active display page
-----------------------------------------------------------
INT 10 - VIDEO - SET PALETTE REGISTERS (Jr, PS, TANDY 1000, EGA, VGA)
 AH = 10h
 AL = 0: set palette register
  BL = palette register to set
  BH = color value to store
 AL = 1: set border color register
  BH = color value to store
 AL = 2: set all palette registers and overscan
  ES:DX = pointer to 17-byte list
   bytes 0-15 = values for palette regs. 0-15
   byte 16 = value for border register
 (EGA/VGA/MCGA)
 AL = 3: toggle intensity/blinking bit
  BL = 0: enable intensity
  BL = 1: enable blink
 (VGA/MCGA)
 AL = 07h: read individual palette register (VGA only)
  BL = palette register number
  Return: BH = palette register value
 AL = 08h: read overscan (border color) register (VGA only)
  Return: BH = value
 AL = 09h: read all palette registers and overscan register (VGA only)
  ES:DX = buffer address (17 bytes)
 AL = 10h: set individual DAC register
  BX = register number
  CH = new value for green (0-63)
  CL = new value for blue (0-63)
  DH = new value for red (0-63)
 AL = 12h: set block of DAC registers
  BX = starting color register
  CX = number of registers to set
  ES:DX = Table of 3*CX bytes where each 3 byte
  group represents one byte each of red, green and blue (0-63)
 AL = 13h: select video DAC color page (VGA only)
  BL = 00h Select paging mode
   BH = 00h Select 4 blocks of 64
   BH = 01h Select 16 blocks of 16
  BL = 01h Select Page
   BH = page number (00h to 03h) or (00h to 0Fh)
 AL = 15h: read individual DAC register
  BL = palette register number
  Return: DH = red value
   CH = green value
   CL = blue value
 AL = 17h: read block of DAC registers
  BX = starting palette register
  CX = number of palette registers to read
  ES:DX = buffer (3 * CX bytes in size)
  Return: CX number of red, green and blue triples
  in buffer
 AL = 18h *UNDOCUMENTED* set PEL mask
  BL = new PEL value
 AL = 19h *UNDOCUMENTED* read PEL mask
  BL = value read
 AL = 1Ah: read video DAC color-page state (VGA only)
  Return: BL = paging mode
   BH = current page
 AL = 1Bh: perform gray-scale summing
  BX = starting palette register
  CX = number of registers to convert
-----------------------------------------------------------
INT 10 - VIDEO - CHARACTER GENERATOR FUNCTIONS (PS, EGA, VGA)
 AH = 11h
 The following functions will cause a mode set, completely resetting
 the video environment, but without clearing the video buffer
 AL = 00h, 10h: load user-specified patterns
     ES:BP = pointer to user table
     CX   = count of patterns to store
     DX   = character offset into map 2 block
     BL   = block to load in map 2
     BH   = number of bytes per character pattern
 AL = 01h, 11h: load ROM monochrome patterns (8 by 14)
     BL   = block to load
 AL = 02h, 12h: load ROM 8 by 8 double-dot patterns
     BL   = block to load
 AL = 03h: set block specifier
     BL   = block specifier
 AL = 04h, 14h: load ROM 8x16 character set (VGA)
 The routines called with AL=1xh are designed to be called only
 immediately after a mode set and are similar to the routines called
 with AL=0xh, except that:
       Page 0 must be active.
       Bytes/character is recalculated.
       Max character rows is recalculated.
       CRT buffer length is recalculated.
       CRTC registers are reprogrammed as follows:
       R09 = bytes/char-1 ; max scan line (mode 7 only)
       R0A = bytes/char-2 ; cursor start
       R0B = 0  ; cursor end
       R12 = ((rows+1)*(bytes/char))-1 ; vertical display end
       R14 = bytes/char ; underline loc
      (*** BUG: should be 1 less ***)
 The following functions are meant to be called only after a mode set:
 AL = 20h: user 8 by 8 graphics characters (INT 1Fh)
     ES:BP = pointer to user table
 AL = 21h: user graphics characters
     ES:BP = pointer to user table
     CX   = bytes per character
     BL   = row specifier
     0: user set
        DL = number of rows
     1: 14 rows
     2: 25 rows
     3: 43 rows
 AL = 22h: ROM 8 by 14 set
     BL   = row specifier
 AL = 23h: ROM 8 by 8 double dot
     BL   = row specifier
 AL = 24h: load 8x16 graphics characters (VGA)
 AL = 30h: return information
     BH   = pointer specifier
     0: INT 1Fh pointer
     1: INT 44h pointer
     2: ROM 8 by 14 character font pointer
     3: ROM 8 by 8 double dot font pointer
     4: ROM 8 by 8 DD font (top half)
     5: ROM alpha alternate (9 by 14) pointer
     Returns: ES:BP = specified pointer value
       CX    = bytes/character
       DL    = character rows on screen
-----------------------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS, EGA, VGA, MCGA)
 AH = 12h
 BL = 10h: return EGA information
      Returns:
      BH = 0: color mode in effect (3Dx)
    1: mono mode in effect (3Bx)
      BL = 0:  64k bytes memory installed
    1: 128k bytes memory installed
    2: 192k bytes memory installed
    3: 256k bytes memory installed
      CH = feature bits
      CL = switch settings
 BL = 20h: select alternate print screen routine
 BL = 30h: select vertical resolution for alphanumeric modes (VGA only)
      AL = 00h 200 scan lines
    01h 350 scan lines
    02h 400 scan lines
      Return: AL = 12h if function supported
 BL = 31h: enable/disable default palette loading (VGA/MCGA)
      AL = 00h enable default palette loading
    01h disable default palette loading
      Return: AL = 12h if function was supported
 BL = 32h: enable/disable video addressing (VGA/MCGA)
      AL = 00h enable video
    01h disable video
      Return: AL = 12h if function was supported
 BL = 33h: enable/disable default gray-scale summing (VGA/MCGA)
      AL = 00h enable gray scale summing
    01h disable gray scale summing
      Return: AL = 12h if function was supported
 BL = 34h: enable/disable alphanumeric cursor emulation (VGA only)
      AL = 00h enable cursor emulation
    01h disable cursor emulation
      Return: AL = 12h if function was supported
 BL = 35h: PS/2 display-switch interface
      AL = 00h initial adapter video off
    01h initial planar video on
    02h switch active video off
    03h switch inactive video on
    80h *UNDOCUMENTED* set system board video active flag
      ES:DX = buffer (128 byte save area if AL = 0, 2 or 3)
 BL = 36h: video refresh control (VGA/PS)
      AL = 0 enable refresh
    1 disable refresh
      Return: AL = 12h if function supported
-----------------------------------------------------------
INT 10 - VIDEO - WRITE STRING (AT,XT286,PS,EGA,VGA)
 AH = 13h
 AL = mode
     bit 0: set in order to move cursor after write
     bit 1: set if string contains alternating characters and attributes
 BL = attribute if AL bit 1 clear
 BH = display page number
 DH,DL = row,column of starting cursor position
 CX = length of string
 ES:BP = pointer to start of string
-----------------------------------------------------------
INT 10 - VIDEO - LOAD LCD CHARACTER FONT (CONVERTIBLE)
 AH = 14h
 AL = 0 load user-specified font
     ES:DI = pointer to character font
     BH = number of bytes per character
     BL = 0: load main font (block 0)
   1: load alternate font (block 1)
     CX = number of characters to store
     DX = character offset into RAM font area
 AL = 1 load system rom default font
     BL = 0: load main font (block 0)
   1: load alternate font (block 1)
 AL = 2 set mapping of LCD high intensity attributes
     BL = 0: ignore high intensity attribute
   1: map high intensity to underscore
   2: map high intensity to revrese video
   3: map high intensity to selected alternate font
-----------------------------------------------------------
INT 10 - VIDEO - GET PHYSICAL DISPLAY PARAMETERS (CONVERTIBLE)
 AH = 15h
Return: AX = alternate display adapter type
 ES:DI = pointer to parameter table
        word 0: monitor model number
      1: vertical pixels per meter
      2: horizontal pixels per meter
      3: total vertical pixels
      4: total horizontal pixels
      5: horizontal pixel separation in micrometers
      6: vertical pixel separation in micrometers
-----------------------------------------------------------
INT 10 - VIDEO - DISPLAY COMBINATION (PS,VGA/MCGA)
 AH = 1Ah
 AL = 0: read display combination code
      Return: BL = active display code
       BH = alternate display code
      1: set display combination code
       BL = active display code
       BH = alternate display code
Return: AL = 1Ah if function was supported
Display combination codes:
 00h no display
 01h monochrome adapter w/ monochrome display
 02h CGA w/ color display
 03h reserved
 04h EGA w/ color display
 05h EGA w/ monochrome display
 06h PGA w/ color display
 07h VGA w/ monochrome analog display
 08h VGA w/ color analog display
 09h reserved
 0Ah reserved
 0Bh MCGA w/ monochrome analog display
 0Ch MCGA w/ color analog display
 FFh unknown display type
-----------------------------------------------------------
INT 10 - VIDEO - FUNCTIONALITY/STATE INFORMATION (PS,VGA/MCGA)
 AH = 1Bh
 BX = implementation type
 BX = 0000h return funtionality/state information
    ES:DI buffer (64 bytes)
       DI+00 static funtionality table
       DI+04 video mode in effect
       DI+05 number of columns
       DI+07 length of regen buffer in bytes
       DI+09 starting address og regen buffer
       DI+0B cursor position for page 0
       DI+0D cursor position for page 1
       DI+0F cursor position for page 2
       DI+11 cursor position for page 3
       DI+13 cursor position for page 4
       DI+15 cursor position for page 5
       DI+17 cursor position for page 6
       DI+19 cursor position for page 7
       DI+1B cursor type
       DI+1D active display page
       DI+1E CRTC port address
       DI+20 current setting of register (3?8)
       DI+21 current setting of register (3?9)
       DI+22 number of rows
       DI+23 bytes/character
       DI+25 DCC of active display
       DI+26 DCC of alternate display
       DI+27 number of colors supported in current mode
       DI+29 number of pages supported in current mode
       DI+2A number of scan lines active
       (0,1,2,3) = (200,350,400,480)
       DI+2B primary character block
       DI+2C secondary character block
       DI+2D Miscellaneous flags
   bit 0 all modes on all displayss on
       1 gray summing on
       2 monochrome display attached
       3 default palette loading disabled
       4 cursor emulation enabled
       5 0 = intensity; 1 = blinking
       6 reserved
       7 reserved
       DI+2E to DI+30 reserved
       DI+32 save pointer state flags
   bit 0 512 character set active
       1 dynamic save area present
       2 alpha font override active
       3 graphics font override active
       4 palette override active
       5 DCC override active
       6 reserved
       7 reserved
       DI+33 to DI+3F reserved
State Functionality Table format (16 bytes)
address+00 modes supported #1
 bit 0 to bit 7 = 1 modes 0,1,2,3,4,5,6 supported
       +01 modes supported #2
 bit 0 to bit 7 = 1 modes 8,9,A,B,C,D,E,F supported
       +02 modes supported #3
 bit 0 to bit 3 = 1 modes 10,11,12,13 supported
 bit 4 to bit 7 reserved
       +03 to +06 reserved
       +07 scan lines supported
 bit 0 to bit 2 = 1 scan lines 200,350,400 supported
       +08 maximum number of active character blocks in text modes
       +09 total blocks available in text modes
       +0A miscellaneous function flags #1
 bit 0 all modes on all displays function supported
     1 gray summing function supported
     2 character font loading function supported
     3 default palette loading enable/disable supported
     4 cursor emulation function supported
     5 EGA palette present
     6 color palette present
     7 color paging function supported
       +0B miscellaneous function flags #2
 bit 0 light pen supported
     1 save/restore state function 1C supported
     2 intensity blinking function supported
     3 Display Combination Code supported
     4 reserved
     5 reserved
     6 reserved
     7 reserved
       +0C to +0D reserved
       +0E Save pointer function flags
 bit 0 512 character set supported
     1 dynamic save area supported
     2 alpha font override supported
     3 graphics font override supported
     4 palette override supported
     5 DCC extension supported
     6 reserved
     7 reserved
       +07 reserved
-----------------------------------------------------------
INT 10 - VIDEO - SAVE/RESTORE VIDEO STATE (PS50+,VGA)
 AH = 1Ch
 CX = requested states
      bit 0 video hardware
   1 BIOS data areas
   2 color registers and state
   3 reserved
   4 reserved
   5 reserved
   6 reserved
   7 reserved
 AL = 0: return state buffer size in 64 byte blocks
      1: save video state
  ES:BX = buffer address
      2: restore video state
  ES:BX = buffer address of previously saved state
Return: AL = 1Ch if function supported
-----------------------------------------------------------
INT 10 - VIDEO - SET GRAPHICS MODE (Hercules GRAFIX)
 AH = 40h
-----------------------------------------------------------
INT 10 - VIDEO - SET TEXT MODE (Hercules GRAFIX)
 AH = 41h
-----------------------------------------------------------
INT 10 - VIDEO - CLEAR CURRENT PAGE (Hercules GRAFIX)
 AH = 42h
-----------------------------------------------------------
INT 10 - VIDEO - SELECT DRAWING PAGE (Hercules GRAFIX)
 AH = 43h
 AL = Page number (0,1)
-----------------------------------------------------------
INT 10 - VIDEO - SELECT DRAWING FUNCTION (Hercules GRAFIX)
 AH = 44h
 AL = 0 : Clear pixels
 AL = 1 : Set pixels
 AL = 2 : Invert pixels
-----------------------------------------------------------
INT 10 - VIDEO - SELECT PAGE TO DISPLAY (Hercules GRAFIX)
 AH = 45h
 AL = Page number (0,1)
-----------------------------------------------------------
INT 10 - VIDEO - DRAW ONE PIXEL (Hercules GRAFIX)
 AH = 46h
 DI = x (0-720)
 BP = y (0-347)
Note: Function 44h determines operation and function 43h
 page to use.
-----------------------------------------------------------
INT 10 - VIDEO - FIND PIXEL VALUE (Hercules GRAFIX)
 AH = 47h
 DI = x (0-720)
 BP = y (0-347)
Return: AL = 0 Pixel clear
 AL = 1 Pixel set
Note: Function 43h specifies page that is used.
-----------------------------------------------------------
INT 10 - VIDEO - MOVE TO POINT (Hercules GRAFIX)
 AH = 48h
 DI = x (0-720)
 BP = y (0-347)
-----------------------------------------------------------
INT 10 - VIDEO - DRAW TO POINT (Hercules GRAFIX)
 AH = 49h
 DI = x (0-720)
 BP = y (0-347)
Note: Function 48h or 49h specify first point, 44h operation
 and 43h page to use.
-----------------------------------------------------------
INT 10 - VIDEO - BLOCK FILL (Hercules GRAFIX)
 AH = 4Ah
-----------------------------------------------------------
INT 10 - VIDEO - DISPLAY CHARACTER (Hercules GRAFIX)
 AH = 4Bh
 AL = Character to display
 DI = x (0-720)
 BP = y (0-347)
Note: Unlike the other BIOS character functions character
 position is specified in pixels rather than rows and
 columns.
-----------------------------------------------------------
INT 10 - VIDEO - DRAW ARC (Hercules GRAFIX)
 AH = 4Ch
-----------------------------------------------------------
INT 10 - VIDEO - DRAW CIRCLE (Hercules GRAFIX)
 AH = 4Dh
-----------------------------------------------------------
INT 10 - VIDEO - FILL AREA (Hercules GRAFIX)
 AH = 4Eh
-----------------------------------------------------------
INT 10 - Direct Graphics Interface Standard (DGIS) - INQUIRE AVAILABLE DEVICES
 AX = 6A00h
 BX = 0
 CX = 0
 DX = buffer length (may be 0)
 ES:DI = address of buffer
Return: BX = number of bytes stored in buffer
 CX = bytes required for all descriptions (0 if no DGIS)
Note: buffer contains descriptions and addresses of DGIS-compatible
 display(s) and printer(s)
-----------------------------------------------------------
INT 10 - DGIS - REDIRECT CHARACTER OUTPUT
 AX = 6A01h
 CX = 0
 ES:DI = address of device to send INT 10 output to
Return: CX = 0   output could not be redirected
      else INT 10h output now routed to requested display
-----------------------------------------------------------
INT 10 - DGIS - INQUIRE INT 10 OUTPUT DEVICE
 AX = 6A02h
 ES:DI = 0:0
Return: ES:DI = 0:0  if current display is non-DGIS
  else address of the current DGIS INT 10 display
-----------------------------------------------------------
INT 10 - VIDEO - GET VIDEO RAM ADDRESS (TANDY 1000)
 AH = 70h
Return: AX  = segment address of the following
 [BX] = offset address of green plane
 [CX] = segment address of green plane
 [DX] = segment address of red/blue plane
        (red offset = 0, blue offset = 4000)
-----------------------------------------------------------
INT 10 - VIDEO - GET INCRAM ADDRESSES (TANDY 1000)
 AH = 71h
Return: AX  = segment address of the following
 [BX] = segment address of INCRAM
 [CX] = offset address of INCRAM
-----------------------------------------------------------
INT 10 - VIDEO - SCROLL SCREEN RIGHT (TANDY 1000)
 AH = 72h
 AL = number of columns blanked at left of window
      0 = blank entire window
 BH = attributes to be used on blank columns
 CH,CL = row, column of upper left corner of window
 DH,DL = row, column of lower right corner
----------------------------------------------------------
INT 10 - VIDEO - SCROLL SCREEN LEFT (TANDY 1000)
 AH = 73h
 AL = number of columns blanked at right of window
      0 = blank entire window
 BH = attributes to be used on blank columns
 CH,CL = row, column of upper left corner of window
 DH,DL = row, column of lower right corner
-----------------------------------------------------------
INT 10 - VIDEO (DESQview) - ???
 AH = 80h
 DX = 4456h ('DV')
 ES:DI = pointer to ???
Return: DS = segment of DESQview data structure for video buffer
Note: this function is probably meant for internal use only, due to the magic
      value required in DX
-----------------------------------------------------------
INT 10 - VIDEO (DESQview) - ???
 AH = 81h
 DX = 4456h
Return: ES = segment of DESQview data structure for video buffer
     BYTE ES:[0] = current window number
Note: this function is probably meant for internal use only, due to the magic
      value required in DX
-----------------------------------------------------------
INT 10 - VIDEO (DESQview) - ???
 AH = 82h
 DX = 4456h
Return: DS = segment in DESQview for ???
 ES = segment of DESQview data structure for video buffer
 AL = current window number
 AH = ???
 BL = direct screen writes
     0 program does not do direct writes
     1 program does direct writes, so shadow buffer not usable
 BH = ???
 CL = ???
 CH = ???
Note: this function is probably meant for internal use only, due to the magic
      value required in DX
-----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ ONE REGISTER
 AH = F0h
 BH = 00h
 BL = pointer for pointer/data chips
     Pointer/data chips
        00h CRTC (3B4h mono modes, 3D4h color modes)
        08h Sequencer 3C4h
        10h Graphics Controller 3CEh
        18h Attribute Controller 3C0h
     Single registers
        20h Miscellaneous Output register 3C2h
        28h Feature Control register (3BAh mono modes, 3DAh color modes)
        30h Graphics 1 Position register 3CCh
        38h Graphics 2 Position register 3CAh
 DX = port number
 Return: BL = data
-----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - WRITE ONE REGISTER
 AH = F1h
 BH = 00h
 BL = pointer for pointer/data chips
     Pointer/data chips
        00h CRTC (3B4h mono modes, 3D4h color modes)
        08h Sequencer 3C4h
        10h Graphics Controller 3CEh
        18h Attribute Controller 3C0h
     Single registers
        20h Miscellaneous Output register 3C2h
        28h Feature Control register (3BAh mono modes, 3DAh color modes)
        30h Graphics 1 Position register 3CCh
        38h Graphics 2 Position register 3CAh
 DX = port number
 Return: BL = data
-----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ REGISTER RANGE
 AH = F2h
 CH = starting pointer value
 CL = Number of registers (>1)
 DX = port number
      00h CRTC (3B4h mono modes, 3D4h color modes)
      08h Sequencer 3C4h
      10h Graphics Controller 3CEh
      18h Attribute Controller 3C0h
 ES:BX buffer size of CL
-----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - WRITE REGISTER RANGE
 AH = F3h
 CH = starting pointer value
 CL = Number of registers (>1)
 DX = port number
      00h CRTC (3B4h mono modes, 3D4h color modes)
      08h Sequencer 3C4h
      10h Graphics Controller 3CEh
      18h Attribute Controller 3C0h
 ES:BX buffer size of CL
-----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ REGISTER SET
 AH = F4h
 CX = number of registers (>1)
 ES:BX address of table of records in this format:
      bytes 1-2 port number
  Pointer/data chips
     00h CRTC (3B4h mono modes, 3D4h color modes)
     08h Sequencer 3C4h
     10h Graphics Controller 3CEh
     18h Attribute Controller 3C0h
  Single registers
     20h Miscellaneous Output register 3C2h
     28h Feature Control register (3BAh mono modes, 3DAh color)
     30h Graphics 1 Position register 3CCh
     38h Graphics 2 Position register 3CAh
      byte 3 pointer value (0 for single registers)
      byte 4 EGA Register Interface returns data here
-----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ REGISTER SET
 AH = F5h
 CX = number of registers (>1)
 ES:BX address of table of records in this format:
      bytes 1-2 port number
  Pointer/data chips
     00h CRTC (3B4h mono modes, 3D4h color modes)
     08h Sequencer 3C4h
     10h Graphics Controller 3CEh
     18h Attribute Controller 3C0h
  Single registers
     20h Miscellaneous Output register 3C2h
     28h Feature Control register (3BAh mono modes, 3DAh color)
     30h Graphics 1 Position register 3CCh
     38h Graphics 2 Position register 3CAh
      byte 3 pointer value (0 for single registers)
      byte 4 EGA Register Interface writes data here
----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - REVERT TO DEFAULT REGISTERS
 AH = F6h
----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - DEFINE DEFAULT REGISTER TABLE
 AH = F7h
 DX = port number
    Pointer/data chips
       00h CRTC (3B4h mono modes, 3D4h color modes)
       08h Sequencer 3C4h
       10h Graphics Controller 3CEh
       18h Attribute Controller 3C0h
    Single registers
       20h Miscellaneous Output register 3C2h
       28h Feature Control register (3BAh mono modes, 3DAh color modes)
       30h Graphics 1 Position register 3CCh
       38h Graphics 2 Position register 3CAh
 ES:BX address of table of one byte entries, one byte
       to be written to each register
----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - INTERROGATE DRIVER
 AH = FAh
 BX = 0
 Return: BX = 0 if mouse driver not present
  ES:BX pointer to EGA Register Interface
  version number, if present:
      byte 1 = major release number
      byte 2 = minor release number
----------------------------------------------------------
INT 10 - VIDEO (TopView) - GET VIDEO BUFFER
 AH = FEh
 ES:DI = segment:offset of assumed video buffer
Return: ES:DI = segment:offset of actual video buffer
-----------------------------------------------------------
INT 10 - VIDEO (TopView) - UPDATE REAL SCREEN FROM VIDEO BUFFER
 AH = FFh
 CX = number of sequential characters that have been modified
 DI = offset of first character that has been modified
 ES = segment of video buffer
Note: avoid CX=0
-----------------------------------------------------------
INT 11 - EQUIPMENT DETERMINATION
Return: AX = equipment flag bits
     0       diskette installed
     1     8087 present
     2,3     always = 11
     4,5     initial video mode
      01 = 40x25 color
      10 = 80x25 color
      11 = 80X25 IBM monochrome
     6,7     number of diskette drives (only if bit 0 = 1)
      00 = 1, 01 = 2, 10 = 3, 11 = 4
     8     0 = dma present, 1 = no dma on system (PCjr???)
     9,10,11 number of RS232 cards
     12     game I/O attached
     13     serial printer installed (IBM-PCjr)
      internal modem installed (Convertible)
     14,15   number of printers
-----------------------------------------------------------
INT 12 - MEMORY SIZE
Return: AX = number of contiguous 1K blocks of memory
-----------------------------------------------------------
INT 13 - DISK - RESET DISK SYSTEM
 AH = 00h
-----------------------------------------------------------
INT 13 - DISK - STATUS OF DISK SYSTEM
 AH = 01h
Return: AL = status
     00h = successful completion
     01h = bad command
     02h = address mark not found
     03h = write attempted on write-protected disk
     04h = sector not found
     05h = reset failed (hard disk)
     06h = diskette changed
     07h = parameter act. failed (hard disk)
     08h = DMA overrun
     09h = DMA across 64K boundary
     0Ah = bad sector detected (hard disk)
     0Bh = bad track detected (hard disk)
     0Ch = unsupported track
     10h = bad CRC/ECC
     11h = data ECC corrected
     20h = controller failure
     40h = seek failed
     80h = time out
     AAh = drive not ready (hard disk)
     BBh = undefined error (hard disk)
-----------------------------------------------------------
INT 13 - DISK - READ SECTORS INTO MEMORY
 AH = 02h
 AL = number of sectors to read
 CH = track (for hard disk, bits 8,9 in high bits of CL)
 CL = sector
 DH = head
 DL = drive
 ES:BX = address of buffer to fill
Return: CF = set if error occurred
 AH = status (see AH=1 above)
 AL = number of sectors read
-----------------------------------------------------------
INT 13 - DISK - WRITE SECTORS FROM MEMORY
 AH = 03h
 AL = number of sectors to write
 CH = track (for hard disk, bits 8,9 in high bits of CL)
 CL = sector
 DH = head
 DL = drive
 ES:BX = address of buffer
Return: CF = set if error occurred
 AH = status (see AH=1 above)
 AL = number of sectors written
-----------------------------------------------------------
INT 13 - DISK - VERIFY SECTORS
 AH = 04h
 AL = number of sectors to verify
 CH = track (for hard disk, bits 8,9 in high bits of CL)
 CL = sector
 DH = head
 DL = drive
Return: CF = set if error occurred
 AH = status (see AH=1 above)
 AL = number of sectors verified
-----------------------------------------------------------
INT 13 - FLOPPY - FORMAT TRACK
 AH = 05h
 AL = number of sectors to create on this track
 CH = track
 CL = sector
 DH = head
 DL = drive
 ES:BX = pointer to array of 4-byte address fields
        byte 1 = track
        byte 2 = head
        byte 3 = sector
        byte 4 = bytes/sector  0=128, 1=256, 2=512, 3=1024
Return: CF set if error occurred
 AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - FORMAT TRACK
 AH = 05h
 AL = interleave value (XT only)
 ES:BX = 512-byte format buffer
  the first 2*(sectors/track) bytes contain F,N for each sector
     F = 00 for good sector, 80h for bad sector
     N = sector number
 CH = cylinder number (bits 8,9 in high bits of CL)
 CL = sector number
 DH = head
 DL = drive
Return: AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - FORMAT TRACK AND SET BAD SECTOR FLAGS (XT,PORT)
 AH = 06h
 AL = interleave value (XT only)
 ES:BX = 512-byte format buffer
  the first 2*(sectors/track) bytes contain F,N for each sector
     F = 00 for good sector, 80h for bad sector
     N = sector number
 CH = cylinder number (bits 8,9 in high bits of CL)
 CL = sector number
 DH = head
 DL = drive
Return: AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - FORMAT DRIVE STARTING AT GIVEN TRACK (XT,PORT)
 AH = 07h
 AL = interleave value (XT only)
 ES:BX = 512-byte format buffer, see AH=6 above
 CH = cylinder number (bits 8,9 in high bits of CL)
 CL = sector number
 DH = head
 DL = drive
Return: AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
 AH = 08h
 DL = drive number
Return: CF set on error
 AH = status code (see AH=1 above)
 DL = number of consecutive acknowledging drives
 DH = maximum value for head number
 CL = maximum value fo sector number
 CH = maximum value for cylinder number
-----------------------------------------------------------
INT 13 - FIXED DISK - INITIALIZE TWO FIXED DISK BASE TABLES (XT,AT,XT286,PS)
 AH = 09h
Return: CF set on error
 AH = status code (see AH=1 above)
 INT 41h points to table for drive 0
 INT 46h points to table for drive 1
-----------------------------------------------------------
INT 13 - FIXED DISK - READ LONG (XT,AT,XT286,PS)
 AH = 0Ah
 DL = drive ID
 DH = head
 CH = cylinder (bits 8,9 in high bits of CL)
 CL = sector
 ES:BX = pointer to buffer to fill
Return: CF set on error
 AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - WRITE LONG (XT,AT,XT286,PS)
 AH = 0Bh
 DL = drive ID
 DH = head
 CH = cylinder (bits 8,9 in high bits of CL)
 CL = sector
 ES:BX = pointer to buffer containing data
Return: CF set on error
 AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - SEEK TO CYLINDER (XT,AT,XT286,PS)
 AH = 0Ch
 DL = drive ID
 DH = head
 CH = cylinder (bits 8,9 in high bits of CL)
Return: CF set on error
 AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - ALTERNATE DISK RESET (XT,PORT,AT,XT286,PS)
 AH = 0Dh
 DL = drive ID
Return: CF set on error
 AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - READ SECTOR BUFFER (XT,PORT,PS)
 AH = 0Eh
 AL = number of sectors
 CH = cylinder (bits 8,9 in top two bits of CL)
 CL = sector number
 DH = head number
 DL = drive number
 ES:BX = pointer to buffer
Return: AL = number of sectors actually transferred
 AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - WRITE SECTOR BUFFER (XT,PORT,PS)
 AH = 0Fh
 AL = number of sectors
 CH = cylinder (bits 8,9 in top two bits of CL)
 CL = sector number
 DH = head number
 DL = drive number
 ES:BX = pointer to buffer
Return: AL = number of sectors actually transferred
 AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - TEST FOR DRIVE READY (XT,AT,XT286,PS)
 AH = 10h
 DL = drive ID
Return: CF set on error
 AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - RECALIBRATE DRIVE (XT,PORT,AT,XT286,PS)
 AH = 11h
 DL = drive ID
Return: CF set on error
 AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - CONTROLER RAM DIAGNOSTIC (XT,PORT,PS)
 AH = 12h
Return: AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - DRIVE DIAGNOSTIC (XT,PORT,PS)
 AH = 13h
Return: AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - CONTROLLER DIAGNOSTICS (XT,PORT,AT,XT286,PS)
 AH = 14h
Return: CF set on error
 AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)
 AH = 15h
 DL = drive ID
Return: AH = disk type
     0 = disk not there
     1 = floppy, no change detection present
     2 = floppy with change detection
     3 = fixed disk
        CX:DX = number of 512-byte sectors
-----------------------------------------------------------
INT 13 - DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
 AH = 16h
 DL = drive to check
Return: AH = disk change status
     0 = no disk change
     6 = disk changed
-----------------------------------------------------------
INT 13 - DISK - SET TYPE (AT,XT2,XT286,CONV,PS)
 AH = 17h
 AL = disk type
     00 = no disk
     01 = regular disk in regular drive
     02 = regular disk in high-capacity drive
     03 = high-capacity disk in high-capacity drive
 DL = drive ID
-----------------------------------------------------------
INT 13 - DISK - SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)
 AH = 18h
 DL = drive number
 CH = lower 8 bits of number of tracks
 CL = sectors per track (bits 0-5)
      top 2 bits of number of tracks (bits 6,7)
Return: AH = 00h  requested combination supported
      01h  function not available
      0Ch  not supported or drive type unknown
      80h  there is no disk in the drive
 ES:DI = pointer to 11-byte parameter table
-----------------------------------------------------------
INT 13 - FIXED DISK - PARK HEADS (XT286,PS)
 AH = 19h
-----------------------------------------------------------
INT 13 - ESDI FIXED DISK - FORMAT UNIT (PS50+)
 AH = 1Ah
 ???
-----------------------------------------------------------
INT 14 - SERIAL I/O - INITIALIZE USART
 AH = 00h
 AL = initializing parameters
     7 - 6 - 5    4 - 3     2   1 - 0
     -BAUD RATE-    PARITY   STOP   WORD
        BITS  LENGTH
     000  110 bd    00 none  0-1   10 - 7
     001  150 bd    01 odd   1-2   11 - 8
     010  300 bd    11 even
     011  600 bd
     100 1200 bd
     101 2400 bd
     110 4800 bd
     111 9600 bd (4800 on PCjr)
 DX = port number
Return: AH = RS-232 status code bits
     0: data ready
     1: overrun error
     2: parity error
     3: framing error
     4: break detected
     5: transmission buffer register empty
     6: transmission shift register empty
     7: time out--if set, other bits invalid
 AL = modem status bits
     0: delta Clear-To-Send
     1: delta Data-Set-Ready
     2: trailing edge of ring detected
     3: change in receive line signal detected
     4: Clear-To-Send
     5: Data-Set-Ready
     6: ring detected
     7: receive line signal detected
-----------------------------------------------------------
INT 14 - SERIAL I/O - TRANSMIT CHARACTER
 AH = 01h
 AL = character
 DX = port number
Return: AX = port status (see AH = 00h above)
-----------------------------------------------------------
INT 14 - SERIAL I/O - RECEIVE CHARACTER
 AH = 02h
Return: AL = character received
 AH = RS-232 status code (see AH = 00h above)
-----------------------------------------------------------
INT 14 - SERIAL I/O - GET USART STATUS
 AH = 03h
Return: AX = port status code (see AH = 00h above)
-----------------------------------------------------------
INT 14 - SERIAL I/O - EXTENDED INITIALIZE (CONVERTIBLE???,PS)
 AH = 04h
 AL = break status
     0 if break
     1 if no break
 BH = parity
     0 no parity
     1 odd parity
     2 even parity
     3 stick parity odd
     4 stick parity even
 BL = number of stop bits
     0: one stop bit
     1: two stop bits (1.5 if 5 bit word length)
 CH = word length
     0: 5 bits
     1: 6 bits
     2: 7 bits
     3: 8 bits
 CL = baud rate
     0: 110
     1: 150
     2: 300
     3: 600
     4: 1200
     5: 2400
     6: 4800
     7: 9600
     8: 19200
Return: AX = port status code (see AH = 00h above)
-----------------------------------------------------------
INT 14 - SERIAL I/O - EXTENDED COMMUNICATION PORT CONTROL (CONVERTIBLE???,PS)
 AH = 05h
 AL = 0 read modem control register
       Return: BL = modem control register (see below)
        AH = status
 AL = 1 write modem control register
       BL = modem control register
    bit 0: data terminal ready
    bit 1: request to send
    bit 2: OUT1
    bit 3: OUT2
    bit 4: LOOP
    bits 5-7 reserved
       Return: AH = status
-----------------------------------------------------------
INT 15 - CASSETTE - TURN ON MOTOR (PC,Jr)
 AH = 00h
Return: motor turned on
-----------------------------------------------------------
INT 15 - CASSETTE - TURN OFF MOTOR (PC,Jr)
 AH = 01h
Return: motor turned off
-----------------------------------------------------------
INT 15 - CASSETTE - READ DATA BLOCKS (PC,Jr)
 AH = 02h
 CX = count of bytes
 ES:BX = pointer to data area
Return: CF set on error
 DX = count of bytes read
 ES:BX = pointer past last byte read
-----------------------------------------------------------
INT 15 - CASSETTE - WRITE DATA BLOCKS (PC,Jr)
 AH = 03h
 CX = count of bytes to write
 ES:BX = pointer to data area
Return: ES:BX = pointer past last byte written
-----------------------------------------------------------
Int 15 - SYSTEM - FORMAT UNIT PERIODIC INTERRUPT (PS ESDI drives only)
 AH = 0Fh
 ???
Return: ???
-----------------------------------------------------------
INT 15 - TopView - "PAUSE" - GIVE UP CPU TIME
 AX = 1000h
Return: after other processes run
-----------------------------------------------------------
INT 15 - TopView - "GETMEM" - ALLOCATE "SYSTEM" MEMORY
 AX = 1001h
 BX = number of bytes to allocate
Return: ES:DI = pointer to block of memory
-----------------------------------------------------------
INT 15 - TopView - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY
 AX = 1002h
 ES:DI = pointer to previously allocated block
Return: block freed
-----------------------------------------------------------
INT 15 - TopView - "PRINTC" - DISPLAY CHARACTER/ATTRIBUTE ON SCREEN
 AX = 1003h
 BH = attribute
 BL = character
 DX = segment of object handle for window
Note: BX=0 does not display anything, it only positions the hardware cursor
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.00
 AH = 10h
 AL = 04h thru 12h
Return: pops up "Programming error" window in DV 2.00
-----------------------------------------------------------
INT 15 - TopView - "GETBIT" - DEFINE A 2ND-LEVEL INTERRUPT HANDLER
 AX = 1013h
 ES:DI = pointer to FAR service routine
Return: BX = bit mask indicating which bit was allocated
      0 if no more bits available
-----------------------------------------------------------
INT 15 - TopView - "FREEBIT" - UNDEFINE A 2ND-LEVEL INTERRUPT HANDLER
 AX = 1014h
 BX = bit mask from INT 15/AX=1013h
-----------------------------------------------------------
INT 15 - TopView - "SETBIT" - SCHEDULE ONE OR MORE 2ND-LEVEL INTERRUPTS
 AX = 1015h
 BX = bit mask for interrupts to post
Return: indicated routines will be called at next ???
-----------------------------------------------------------
INT 15 - TopView - "ISOBJ" - VERIFY OBJECT HANDLE
 AX = 1016h
 ES:DI = possible object handle
Return: BX = 0 if ES:DI is a valid object handle
     -1 if ES:DI is not
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.00
 AX = 1017h
Return: pops up "Programming error" window in DV 2.00
-----------------------------------------------------------
INT 15 - TopView - "LOCATE" - FIND WINDOW AT A GIVEN SCREEN LOCATION
 AX = 1018h
 BH = column
 BL = row
 ES = segment of object handle???
      (0 = use default)
Return: ES = segment of object handle for window which is visible at the
      indicated position
-----------------------------------------------------------
INT 15 - TopView - "SOUND" - MAKE TONE
 AX = 1019h
 BX = frequency in Hertz
 CX = duration in clock ticks (18.2 ticks/sec)
Return: immediately, tone continues to completion
Notes: if another tone is already playing, the new tone does not start until
       completion of the previous one. In DV 2.00, it is possible to enqueue
       about 32 tones before the process is blocked until a note completes.
       in DV 2.00, the lowest tone allowed is 20 Hz
-----------------------------------------------------------
INT 15 - TopView - "OSTACK" - SWITCH TO TASK'S INTERNAL STACK
 AX = 101Ah
Return: stack switched
-----------------------------------------------------------
INT 15 - TopView - "BEGINC" - BEGIN CRITICAL REGION
 AX = 101Bh
Return: task-switching temporarily disabled
Note: will not task-switch until END CRITICAL REGION (AX = 101Ch) called
-----------------------------------------------------------
INT 15 - TopView - "ENDC" - END CRITICAL REGION
 AX = 101Ch
Return: task-switching enabled
-----------------------------------------------------------
INT 15 - TopView - "STOP" - STOP TASK
 AX = 101Dh
 ES = segment of object handle for task to be stopped
      (== handle of main window for that task)
Return: indicated task will no longer get CPU time
-----------------------------------------------------------
INT 15 - TopView - "START" - START TASK
 AX = 101Eh
 ES = segment of object handle for task to be started
      (== handle of main window for that task)
Return: indicated task is started up again
-----------------------------------------------------------
INT 15 - TopView - "DISPEROR" - POP-UP ERROR WINDOW
 AX = 101Fh
 BX = bit fields
      bits 0-12: number of characters to display
      bits 13,14: which mouse button may be pressed to remove window
    00 = either
    01 = left
    10 = right
    11 = either (maybe should read "both" or "center"???)
      bit 15: beep if 1
 DS:DI = pointer to text of message
 CH = width of error window (0 = default)
 CL = height of error window (0 = default)
 DX = segment of object handle
Return: BX = ???
Note: window remains on-screen until ESC or indicated mouse button is pressed
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.00
 AX = 1020h
Return: pops up "Programming error" window in DV 2.00
-----------------------------------------------------------
INT 15 - TopView - "PGMINT" - INTERRUPT ANOTHER TASK
 AX = 1021h
 BX = segment of object handle for task to interrupt
 DX:CX = address of FAR routine to jump to (next time task is run???)
Return: nothing???
Note: the current ES, DS, SI, DI, and BP are passed to the FAR routine
-----------------------------------------------------------
INT 15 - TopView - "GETVER" - GET VERSION
 AX = 1022h
 BX = 0
Return: BX nonzero, TopView or compatible loaded
 (BL = major version, BH = minor version)
Notes: TaskView returns BX = 0001h, DESQview 2.0 returns BX = 0A01h
-----------------------------------------------------------
INT 15 - TopView - "POSWIN" - POSITION WINDOW
 AX = 1023h
 BX = segment of object handle for parent window within which to
      position the window (0 = full screen)
 DL = bit flags
      bits 0,1: horizontal position
  00 = current
  01 = center
  10 = left
  11 = right
      bits 2,3: vertical position
  00 = current
  01 = center
  10 = top
  11 = bottom
      bit 4: don't redraw screen if set
      bits 5-7 not used
 ES = segment of object handle for window
Return: ???
-----------------------------------------------------------
INT 15 - TopView - "GETBUF" - GET VIRTUAL SCREEN INFO
 AX = 1024h
 BX = segment of object handle for window
       (0 = use default)
Return: ES:DI = address of virtual screen
 CX = size of virtual screen in bytes
 DL = 0 ???
      1 ???
-----------------------------------------------------------
INT 15 - TopView - "USTACK" - SWITCH BACK TO USER'S STACK
 AX = 1025h
Return: stack switched back
Note: call only after INT 15h/AX=101Ah
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.00
 AH = 10h
 AL = 26h thru 2Ah
Return: pops up "Programming error" window in DV 2.00
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - "POSTTASK"??? - AWAKEN TASK ???
 AX = 102Bh
 BX = segment of object handle for task's OBJECTQ ???
Return: nothing
Note: calls INT 15/AH=12/BX=0506
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - SET .PIF ???
 AX = 102Ch
 BX = number of bytes to copy
      >416 changed to 367, then values <= 369 get some additional code
 ES:DI = pointer to contents of .PIF file ???
Return: BX = ???
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - ???
 AX = 102Dh
 BL = subfunction
      00h
      01h
      02h
Return: ???
-----------------------------------------------------------
INT 15 - TopView commands
 AH = 11h
 AL = various
Note: in DESQview 2.00, these function calls are identical to AH=DEh, so
      see those below
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "HANDLE" - RETURN OBJECT HANDLE
 AH = 12h
 BH = 00h
 BL = which handle to return
     00h handle in DWORD on top of stack
     01h current task's window handle
     02h given task's mailbox handle (task's handle on stack)
     03h current task's mailbox handle
     04h given task's keyboard handle (task's handle on stack)
     05h current task's keyboard object handle
     06h given task's OBJECTQ handle (task's handle on stack)
     07h current task's OBJECTQ handle
     08h   \
       thru > returns 0000:0000
     10h   /
Return: DWORD on top of stack is object handle
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "NEW" - CREATE NEW OBJECT
 AH = 12h
 BH = 01h
 BL = object
     00h handle is DWORD on top of stack
     01h use task's window handle
  takes 8 DWORD parameters on stack
     02h given task's mailbox (task's handle on top of stack)
     03h current task's mailbox
     04h given task's keyboard (task's handle on top of stack)
     05h current task's keyboard object
     08h WINDOW class
  takes 8 DWORD parameters on stack
     09h MAILBOX class
     0Ah KEYBOARD class
     0Bh TIMER object (counts down 32-bit time in 10ms increments)
     0Fh POINTER object
     10h PANEL object
Return: DWORD on top of stack is new object handle
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "FREE" - FREE AN OBJECT
 AH = 12h
 BH = 02h
 BL = object
     00h handle in DWORD on top of stack
  window: close window and free
  timer: free timer
  panel: free panel object
  pointer: free pointer
     01h task's window handle - kills task, never returns
     02h given task's mailbox (task's handle on top of stack)
     03h current task's mailbox
     04h given task's keyboard (task's handle on top of stack)
     05h current task's keyboard object
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "ADDR" - GET OBJECT HANDLE
 AH = 12h
 BH = 03h
 BL = object
     00h handle in DWORD on top of stack
     02h sender of last msg read from mailbox (task's handle on stack)
     03h sender of last msg read from current task's mailbox
Return: DWORD on stack is handle
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "DIR" - GET PANEL FILE DIRECTORY
 AH = 12h
 BX = 0300h
 STACK: DWORD handle of panel object
Return: ???
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "READ" - GET NEXT RECORD
 AH = 12h
 BH = 04h
 BL = object
     00h handle is DWORD on top of stack
  window: read next logical line
  timer: wait for timer to expire
  pointer: wait for next message
     01h read the next logical line from task's default window
     02h get next message from mailbox (task's handle on top of stack)
     03h get next message from current task's mailbox
     04h get the next input from keyboard (handle on top of stack)
     05h get the next input from task's default keyboard
     06h wait for input from any object in OBJECTQ (handle on stack)
     07h wait for input from any object in task's default OBJECTQ
Return: STACK: DWORD number of bytes
        DWORD address
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "APPLY" - WRITE PANEL TO WINDOW
 AH = 12h
 BX = 0400h
 STACK: DWORD handle of panel object
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE STRING TO OBJECT
 AH = 12h
 BH = 05h
 BL = object
     00h handle is DWORD on top of stack
  window: write string
  timer: start timer to end at a specified time
  pointer: move pointer icon to specified position
     01h write string to task's default window
     02h send message by value/status=0 to mbox (task's handle on stack)
     03h send message by value/status=0 to current task's mailbox
     04h add input buffer to KEYBOARD queue (handle on top of stack)
     05h add input buffer to task's default KEYBOARD queue
     06h add an object to OBJECTQ (handle on top of stack)
     07h add an object to task's default OBJECTQ
 STACK: DWORD object handle if handle passed on stack
        DWORD total length of string (high word == 0)
        DWORD address of string to display
Note: service routine will pop stack
-----------
IF OBJECT IS A WINDOW, THEN
Return: indicated actions performed
 a. non-control characters are displayed
 b. CR/LF/BS/Tab cause the usual cursor movement
 c. ESC starts a data structure with additional commands
Data Structure:
 MAGIC  DB  1Bh
 MODE   DB  ?   ; 00h, 01h, 10h, 14h-1Fh legal
 LENGTH DW  ?   ; length of remainder in bytes
 var-length fields follow, each an OPCODE followed by
      zero or more args
MODE 00h (set or display values) "WINDOW STREAM"
    Opcodes:args
 00h  display 20h blanks with the default attribute
 01h-1Fh display OPCODE blanks with the default attribute
 20h  display char with default attribute 20h times
      BYTE char to repeat
 21h-3Fh display char with default attribute OPCODE-20h times
      BYTE char to repeat
 40h  display 20h blanks with specified attribute
      BYTE attribute of blanks
 41h-5Fh display OPCODE-40h blanks with specified attribute
      BYTE attribute of blanks
 60h  display next 20h characters
      20h BYTES characters to display
 61h-7Fh display next OPCODE-60h characters
      N BYTES characters to display
 80h-87h  display N blanks with default attribute
      BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
        [000h means 800h]
 88h-8Fh display N copies of the character
      BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
        [000h means 800h]
      BYTE character to repeat
 90h-97h  display N blanks with specified attribute
      BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
        [000h means 800h]
      BYTE attribute
 98h-9FH  display string at logical cursor pos
      BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
        [000h means 800h]
      N BYTES string to display
 A0h  set logical cursor row
      BYTE row number (0 is top)
 A1h  set logical cursor column
      BYTE column number (0 is leftmost)
 A2h  ???
      BYTE ???
 A3h  ???
      BYTE ???
 A4h  set row of physical window position
      BYTE line
 A5h  set column of physical window position
      BYTE column
 A6h  set height of physical window
      BYTE #rows
 A7h  set width of physical window
      BYTE #columns
 A8h  set viewport row
      BYTE row
 A9h  set viewport column
      BYTE column
 AAh  set virtual screen height
      BYTE rows
 ABh  set virtual screen width
      BYTE columns
 ACh-AEh  unused
 AFh  ???
      BYTE ??? (ANDed with current value of something)
 B0h  move logical cursor down
      BYTE #rows (signed, negative values move up)
 B1h  move logical cursor right
      BYTE #cols (signed, negative values move left)
 B2h  ???
      BYTE ??? (signed)
 B3h  ???
      BYTE ??? (signed)
 B4h  shift window down
      BYTE #lines (signed)
 B5h  shift window right
      BYTE #columns (signed)
 B6h  expand physical window vertically
      BYTE #lines (signed)
 B7h  expand physical window horizontally
      BYTE #columns (signed)
 B8h  adjust viewport row
      BYTE #rows (signed)
 B9h  adjust viewport column
      BYTE #columns (signed)
 BAh  adjust virtual screen height
      BYTE #rows to increase (signed)
 BBh  adjust virtual screen width
      BYTE #cols to increase (signed)
 BCh-BFh  unused
 C0h  set logical cursor position
      BYTE row number (0 is top border)
      BYTE column number (0 is left border)
 C1h  ???
      BYTE ???
      BYTE ???
 C2h  set window pos
      BYTE upper left row (no top border if 0)
      BYTE upper left column (no left border if 0)
 C3h  set current window size
      BYTE #rows
      BYTE #cols
 C4h  set upper left corner of viewport (portion of virtual screen
      displayed in window)
      BYTE row
      BYTE column
 C5h  set size of virtual screen
      BYTE #rows
      BYTE #cols
 C6h  unused
 C7h  unused
 C8h  set logical cursor relative to current position
      BYTE number of rows to move down (signed)
      BYTE number of columns to move right (signed)
 C9h  ???
      BYTE ???
      BYTE ???
 CAh  set window pos relative to current position
      BYTE number of rows to shift down (signed)
      BYTE number of columns to shift right (signed)
 CBh  set window size relative to current size
      BYTE number of rows to expand (signed)
      BYTE number of cols to expand (signed)
 CCh  shift viewport relative to current position
      BYTE rows to shift (signed)
      BYTE cols to shift (signed)
 CDh  resize virtual screen (guess)
      BYTE #rows to expand (signed)
      BYTE #cols to expand (signed)
 CEh  clear ???
 CFh  set ???
 D0h  turn on ??? (default)
 D1h  turn off ???
 D2h  turn on ???
 D3h  turn off ??? (default)
 D4h  window is visible
 D5h  window is hidden
 D6h  window has frame
 D7h  window unframed
 D8h  turn on ??? (default)
 D9h  turn off ???
 DAh  use logical attributes, which may be remapped
  attributes
     1 normal text
     2 highlighted normal text
     3 help text
     4 highlighted help text
     5 error message
     6 highlighted error message
     7 emphasized text
     8 marked text
     others???
 DBh  use physical attributes for characters
 DCh  enable special actions for control characters (default)
 DDh  disable special control char handling, all chars displayable by
      BIOS TTY call
 DEh  write both character and attribute (default)
 DFh  write character only, leave attribute untouched
 E0h  repeat following commands
      BYTE number of times
 E1h  end of commands to repeat, start repeating them
 E2h  set color
      BYTE color
 E3h  clear virtual screen
 E4h  redraw window
 E5h  ???
      BYTE ???
 E6h  create new window and perform rest of manipulations in new window
      BYTE number of rows
      BYTE number of columns
      Return: DWORD object handle returned on stack at end
 E7h  unused
 E8h  ???
      BYTE ???
      BYTE ???
      additional args???
 E9h  ???
      BYTE ???
      BYTE ???
      additional args???
 EAh  ???
      BYTE ???
      BYTE ???
      additional args???
 EBh  ???
      BYTE ???
      BYTE ???
      additional args???
 ECh  ???
      BYTE ???
      BYTE count of remaining args \ counted string maybe???
      N BYTES remaining args   /
 EDh  ???
      BYTE ???
      BYTE ???
      var-length args
 EEh  same as EDh, but ???
      BYTE ???
      BYTE ???
      var-length args
 EFh  set window name
      BYTE length of name
      N BYTES name
 F0h  clear input field to blanks
      BYTE field number
 F1h  fill input field with character
      BYTE field number
      BYTE char
 F2h  set color of input field
      BYTE field number (1-N)
      BYTE attribute
 F3h  set initial contents of input field
      BYTE field number (1-N)
      N BYTES enough chars to exactly fill field as defined by op FFh
 F4h  position cursor to specific input field
      BYTE field number (1-N)
 F5h  change field table entry
      BYTE field number
      7-8 BYTEs field table entry (see FFh)
 F6h  set field type??? (guess)
      BYTE field number
      BYTE type???
 F7h  ???
      STRING??? (I saw 20h 20h 20h 20h)
 F8h  ???
      BYTE field number
      additional args???
 F9h  ???
      BYTE field number
      additional args???
 FAh  ???
      BYTE field number
      additional args???
 FBh  ???
      BYTE field number
      additional args???
 FCh  set field table header??? (guess)
      BYTE field number
      BYTE ???
      6 BYTES ???
      additional args???
 FDh  ???
      no args???
 FEh  ??? (no args)
 FFh  set up input fields
      table header
   BYTE number of fields
   BYTE screen type ??? (I see 47h, 52h, 53h, 55h, 57h, and 5Bh)
   WORD ??? (I see 0 always)
   BYTE color of field currently pointed to
   BYTE color of input fields which have been selected
      the field table entries, one for each field
   BYTE start row
   BYTE start column
   BYTE end row
   BYTE end column
   BYTE field type (A0h allows user entry, 00h/40h don't)
        80h is a fill-in field
        C0h is a menu selection
   BYTE modifier
        if type is 80h, then bit flags to determine behavior
     bit 7  if set, beep when field is full
     bit 6  move to next field when current field is full
     bit 5  if set, enter text from right end (for numbers)
     bit 4  if set, force input to uppercase
     bit 3  if set, clear old contents on first keystroke
     bit 2,1,0 ???
        if type is C0h, key to press to activate menu sel
          00h if have to point-and-click
   BYTE ???
   BYTE second key for activating menu selection if field type is
        C0h (0 = only single key).  Only present if SCREEN TYPE
     is 5Bh
MODE 01h "QUERY STREAM" (valid only for those opcodes listed here)
 A0h return logical cursor row in next byte
 A1h return logical cursor column in next byte
 A2h
 A3h
 A4h return row of physical window origin in next byte
 A5h return column of physical window origin in next byte
 A6h return height of physcial window in next byte
 A7h return width of physical window in next byte
 A8h return row of viewport origin in next byte
 A9h return column of viewport origin in next byte
 AAh return height of virtual screen in next byte
 ABh return width of virtual screen in next byte
 AFh return ??? in next byte
 C0h return current logical cursor position in next two bytes
 C1h return ??? in next two bytes
 C2h return current window position in next two bytes
 C3h return current window size in next two bytes
 C4h return current viewport origin in next two bytes
 C5h return current virtual screen size in next two bytes
 D0h \ overwritten with D0h if ??? on
 D1h /         D1h if ??? off
 D2h \ overwritten with D2h if ??? on
 D3h /         D3h if ??? off
 D4h \ overwritten with D4h if window visible
 D5h /         D5h if window hidden
 D6h \ overwritten with D6h if window has frame
 D7h /         D7h if window unframed
 D8h \ overwritten with D8h if ??? on
 D9h /         D9h if ??? off
 DAh \ overwritten with DAh if using logical attributes
 DBh /         DBh if using physical attributes
 DCh \ overwritten with DCh if TTY control char interpretation on
 DDh /         DDh if TTY control char interpretation off
 DEh \ overwritten with DEh if writing both characters and attributes
 DFh /                  DFh if leaving attributes untouched
 E2h return current color in next byte
 ECh
 EDh
 EEh
 EFh return current window name
     BYTE    max length of returned name
     N BYTES buffer to hold window name
 F3h return contents of input field
     BYTE field number
     N BYTES buffer to hold field contents (size exactly equal to field
      size)
 F5h get field table entry
     BYTE field number
     7-8 BYTES buffer to hold field table entry
 F6h get type of a field??? (guess)
     BYTE field number
     BYTE type???
 FCh get field table header??? (guess)
     BYTE field number
     BYTE ???
     6 BYTES ???
     additional args???
MODE 10h "MANAGER STREAM" (valid only for opcodes listed here)
 00h allow window to be moved horizontally
 01h allow window to be moved vertically
 02h allow window to change width
 03h allow window to change height
 04h allow window to be scrolled horizontally
 05h allow window to be scrolled vertically
 06h allow "Close Window" menu selection
 07h allow window to be hidden
 08h allow "Mark" menu
 0Eh allow "Scissors" menu
 10h allow DESQview main menu to be popped up
 11h allow "Switch Windows" menu
 12h allow "Open Window" menu
 13h allow "Quit" menu selection
 20h-33h opposite of 00h-13h, disallow specified action
 40h notify if horizontal position of window changes
 41h notify if vertical position of window changes
 42h notify if width of window changes
 43h notify if height of window changes
 44h notify if window scrolled horizontally
 45h notify if window scrolled vertically
 46h notify if window is closed--program has to clean up and exit itself
 47h notify if window is hidden
        48h notify if "?" on main menu selected
 49h notify if ???
 4Ah notify if window is swapped out or hidden
 4Bh notify if ???
 4Ch notify if video mode changes
 4Dh notify if "Scissors" menu "Cut" option selected
 4Eh notify if "Scissors" menu "Copy" option selected
 4Fh notify if "Scissors" menu "Paste" option selected
 50h notify if DESQview main menu popped up
 51h notify if "Switch" menu selected
 60h-71h  opposite of 40h-51h: don't notify on specified event
 84h
 85h
 86h disable background operation
 87h enable running in background
 88h set minimum size of physical window
     BYTE rows
     BYTE columns
 89h set maximum size of physical window
     BYTE rows
     BYTE cols
 8Ah set primary asynchronous notification routine
     DWORD address of routine, 0000:0000 means none
    on entry ES:DI = handle of window, DS:SI is secondary routine
    routine should restore all registers before returning
 8Bh set secondary async notification routine
     DWORD address of routine, passed to primary routine in DS:SI,
    rather than called directly
 AEh
 AFh ???
     BYTE ???
 BCh
 BDh   opposite of BCh
 BEh
 BFh   opposite of BEh
 C0h move current window in front of all other windows
 C1h ???
 C2h move current window in front of all other windows
 C3h ??? (like C4h, but uses defaults)
 C4h ???
     BYTE ???
     BYTE ???
 C5h hide current window
 C6h ???
 C7h hide all windows for this process and switch to previous process
 C8h hide all windows for this process and switch to previous process
 C9h switch to previous process
 CAh move current window back behind other windows for this process
 CBh ???
 CCh closes current window???
 CEh reorder windows
     DWORD pointer to null-terminated list of words
    each word is segment of object handle for a window
MODES 14h to 1Fh ("user streams"???)
 normally NOPs, but may be defined (don't know how yet) to invoke FAR
 routines, one for each mode number
   on entry to handler,
  DS:SI = first byte of actual stream (not header)
  CX = #bytes in stream
  ES:DI = window's handle???
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SIZEOF" - GET OBJECT SIZE
 AH = 12h
 BH = 08h
 BL = object
     00h handle in DWORD on top of stack
  timer: elapsed time since timer started
  pointer: number of messages queued to pointer object
  panel: number of panels in panel file
     01h total chars in current task's default window
     02h number of messages in task's mailbox (task's handle on stack)
     03h number of messages in current task's mailbox
     04h number of input buffers queued in task's kbd (handle on stack)
     05h number of input buffers queued for current task's default kbd
     06h number of objects queued in OBJECTQ (task's handle on stack)
     07h number of objects queued in current task's OBJECTQ
Return: DWORD on stack is result
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "LEN" - GET OBJECT LENGTH
 AH = 12h
 BH = 09h
 BL = object
     00h handle in DWORD on top of stack
  window: chars/line
  timer: timer remaining before timer expires
     01h number of chars/line in current task's default window
Return: DWORD on top of stack is length
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "ADDTO" - SET OBJECT BITS
 AH = 12h
 BH = 0Ah
 BL = object
     00h handle is DWORD on top of stack
  window: write characters and attributes
  timer: start timer for specified interval
  pointer: set control flags
     01h write characters and attributes to task's default window
     02h send message/status by value to mailbox (task's handle on stack)
     03h send message/status by value to current task's default mailbox
     04h set control flags on KEYBOARD object (handle on top of stack)
     05h set control flags on task's default KEYBOARD object
 STACK: (if mailbox) DWORD status
       DWORD length of message
       DWORD address
        (otherwise)  DWORD bits to set
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - RESET OBJECT BITS
 AH = 12h
 BH = 0Bh
 BL = object
     00h handle is DWORD on top of stack
  pointer: reset control flags
     01h write attributes only to task's default window
     02h send message/status by reference to box (task's handle on stack)
     03h send message/status by reference to current task's mailbox
     04h clear control flags on KEYBOARD object (handle on top of stack)
     05h clear control flags on task's default KEYBOARD object
     06h remove specific object from OBJECTQ (handle on top of stack)
     07h remove specific object from task's default OBJECTQ
 STACK: DWORD indicates which bits to clear
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "OPEN" - OPEN OBJECT
 AH = 12h
 BH = 0Ch
 BL = object
     00h handle is DWORD on top of stack
  timer: open
  pointer: start taking input for window
  panel: associate with a panel file
     01h fill task's default window with given character
     02h open given task's mailbox for input (task's handle on stack)
     03h open current task's mailbox
     04h attach a KEYBOARD to a window (handle on top of stack)
     05h attach task's default KEYBOARD to a window
     06h open a task's OBJECTQ (task's handle on top of stack)
     07h open current task's OBJECTQ
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "CLOSE" - CLOSE OBJECT
 AH = 12h
 BH = 0Dh
 BL = object
     00h handle is DWORD on top of stack
  timer: close
  pointer: stop taking input
  panel: close
     02h close given task's mailbox (task's handle on top of stack)
     03h close task's default mailbox
     04h close KEYBOARD object (handle on top of stack)
     05h close task's default KEYBOARD
     06h close givent task's OBJECTQ (task's handle on top of stack)
     07h close current task's OBJECTQ
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "ERASE" - ERASE OBJECT
 AH = 12h
 BH = 0Eh
 BL = object
     00h handle is DWORD on top of stack
  window: clear
  timer: cancel current interval
  pointer: discard all pending messages
     01h clear task's default window
     02h discard all queued messages in mailbox (handle on top of stack)
     03h discard all queued messages in current task's default mailbox
     04h discard all input queued to KEYBOARD (handle on top of stack)
     05h discard all input queued to task's default KEYBOARD
     06h remove all objects from OBJECTQ (task's handle on top of stack)
     07h remove all objects from current task's OBJECTQ
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "STATUS" - GET OBJECT STATUS
 AH = 12h
 BH = 0Fh
 BL = object
     00h handle is DWORD on top of stack
  timer: is it running?
  pointer: return status of last message
  panel: verify success of last OPEN or APPLY
     02h return status of last msg READ from mailbox (handle on stack)
     03h return status of last msg READ from task's default mailbox
     04h get scan code for last key read from KEYBOARD (handle on stack)
     05h get scan code for last key read from task's default KEYBOARD
     06h return whether OBJECTQ is open or not (handle on top of stack)
     07h return whether task's default OBJECTQ is open or not
Return: DWORD on top of stack is status
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "EOF" - GET OBJECT EOF STATUS
 AH = 12h
 BH = 10h
 BL = object
     00h handle is DWORD on top of stack
     01h returns TRUE if logical cursor past end of task's def window
Return: DWORD on top of stack is status
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "AT" - POSITION OBJECT CURSOR
 AH = 12h
 BH = 11h
 BL = object
     00h handle is DWORD on top of stack
     01h position logical cursor on task's default window
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SETSCALE" - SET POINTER SCALE FACTOR
 AH = 12h
 BX = 1100h
 STACK: DWORD object handle for pointer object
        DWORD ???
        DWORD ???
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "READN" - GET NEXT N OBJECT BYTES
 AH = 12h
 BH = 12h
 BL = object
     00h handle is DWORD on top of stack
     01h read next N chars/attributes on task's default window
 STACK: DWORD count
Return: STACK: DWORD count actually read
        DWORD address
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "GETSCALE" - GET POINTER SCALE FACTOR
 AH = 12h
 BX = 1200h
 STACK: DWORD object handle for pointer
Return: STACK: DWORD ???
        DWORD ???
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "REDRAW" - REDRAW WINDOW
 AH = 12h
 BH = 13h
 BL = object
     00h DWORD on top of stack is handle for window to redraw
     01h redraw task's default window
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SETICON" - SPECIFY POINTER ICON
 AH = 12h
 BX = 1300h
 STACK: DWORD object handle for pointer
        ???
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SETESC" - SET ESCAPE ROUTINE ADDRESS
 AH = 12h
 BH = 14h
 BL = message modifier
     00h handle is DWORD on top of stack
     04h intercept keystrokes from KEYBOARD to a window (handle on stack)
     05h intercept keystrokes from task's default KEYBOARD to a window
-----------------------------------------------------------
INT 15 - PRINT.COM - ??? (AT,XT286,PS50+)
 AH = 20h
 AL = subfunction
     00h ???
     01h ???
     10h setup of SYSREQ routine (OS hook)
     11h completion of SYSREQ function (OS hook)
Note: AL = 0,1 set or reset some flags which affect what PRINT does when it
      tries to access the disk
-----------------------------------------------------------
INT 15 - SYSTEM - POWER-ON SELF-TEST ERROR LOG (PS50+)
 AH = 21h
 ???
Return: ???
-----------------------------------------------------------
INT 15 - READ/MODIFY PROFILES (CONVERTIBLE)
 AH = 40h
 AL = subfunction
     0: get system profile in CX and BX
     1: set system profile from CX and BX
     2: get internal modem profile in BX
     3: set internal modem profile from BX
-----------------------------------------------------------
INT 15 - SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE)
 AH = 41h
 AL = condition type
     bits 0-2: condition to wait for
       0 any external event
       1 compare and return if equal
       2 compare and return if not equal
       3 test and return if not zero
       4 test and return if zero
     bit 3:    reserved
     bit 4:    1=port address, 0=user byte
     bits 5-7: reserved
 BH = condition compare or mask value
 BL = timeout value times 55 milliseconds
     0 means no timeout
 DX = I/O port address if AL bit 4 set
 ES:DI = pointer to user byte if AL bit 4 clear
-----------------------------------------------------------
INT 15 - SYSTEM - REQUEST POWER OFF (CONVERTIBLE)
 AH = 42h
 AL = 0 to use system profile
      1 to force suspend regardless of system profile
-----------------------------------------------------------
INT 15 - SYSTEM - READ SYSTEM STATUS (CONVERTIBLE)
 AH = 43h
Return: AL = status bits
     bit 0: LCD detached
     bit 1: reserved
     bit 2: RS232/parallel adapter powered on
     bit 3: internal modem powered on
     bit 4: power activated by alarm
     bit 5: standby power lost
     bit 6: external power in use
     bit 7: power low
-----------------------------------------------------------
INT 15 - SYSTEM - (DE)ACTIVATE INTERNAL MODEM POWER (CONVERTIBLE)
 AH = 44h
 AL = 0 to power off
      1 to power on
-----------------------------------------------------------
INT 15 - OS HOOK - KEYBOARD INTERCEPT (AT model 3x9,XT2,XT286,CONV,PS)
 AH = 4Fh
 AL = scan code
 CF set
Return: AL = scan code
 CF set
Note: Called by INT 9 handler to translate scan codes
-----------------------------------------------------------
INT 15 - OS HOOK - DEVICE OPEN (AT,XT2,XT286,PS)
 AH = 80h
 BX = device ID
 CX = process type
-----------------------------------------------------------
INT 15 - OS HOOK - DEVICE CLOSE (AT,XT2,XT286,PS)
 AH = 81h
 BX = device ID
 CX = process type
-----------------------------------------------------------
INT 15 - OS HOOK - DEVICE PROGRAM TERMINATE (AT,XT2,XT286,PS)
 AH = 82h
 BX = device ID
-----------------------------------------------------------
INT 15 - SYSTEM - EVENT WAIT (AT,XT286,CONV,PS)
 AH = 83h
 AL = subservice
     0 = set interval
     1 = cancel
 ES:BX = pointer to event flag (bit 7 set when interval expires)
 CX:DX = number of microseconds to wait (only accurate to 977 us)
Return: CF set if function already busy
-----------------------------------------------------------
INT 15 - SYSTEM - READ JOYSTICK (AT,XT2,XT286,PS)
 AH = 84h
 DX = subservice
     0 get switch settings
       Return: AL = switch settings (bits 7-4)
     1 read joystick inputs
       Return: AX = A(x) value
        BX = A(y) value
        CX = B(x) value
        DX = B(y) value
-----------------------------------------------------------
INT 15 - OS HOOK - SYSTEM REQUEST KEY PRESSED (AT,XT2,XT286,CONV,PS)
 AH = 85h
 AL = 0 press
    = 1 release
Note: called by keyboard decode routine
-----------------------------------------------------------
INT 15 - SYSTEM - WAIT (AT,XT2,XT286,CONV,PS)
 AH = 86h
 CX,DX = number of microseconds to wait (only accurate to 977 us)
Return: after wait elapses
-----------------------------------------------------------
INT 15 - EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)
 AH = 87h
 CX = number of words to move
 ES:SI = pointer to global descriptor table
        offset 0h  null descriptor (need not be initialized)
        8h  uninitialized, will be made into GDT descriptor
       10h  descriptor for source of move
       18h  descriptor for destination of move
       20h  uninitialized, used by BIOS
       28h  uninitialized, will be made into SS descriptor
Return: source copied into destination
-----------------------------------------------------------
INT 15 - EXTENDED MEMORY - GET MEMORY SIZE (AT,XT286,PS)
 AH = 88h
Return: AX = memory size
-----------------------------------------------------------
INT 15 - SYSTEM - SWITCH TO VIRTUAL MODE (AT,XT286,PS50+)
 AH = 89h
 BL = interrupt number of IRQ0 (IRQ1-7 use next 7 interrupts)
 BH = interrupt number of IRQ8 (IRQ9-F use next 7 interrupts)
 DS:SI = pointer to GDT for protected mode
        offset 0h  null descriptor
        8h  GDT descriptor
       10h  IDT descriptor
       18h  DS
       20h  ES
       28h  SS
       30h  CS
       38h  uninitialized, used to build descriptor for BIOS CS
 CX = offset into protected-mode CS to jump to
Return: CF set on error
    AH = 0FFh  error enabling address line 20
-----------------------------------------------------------
INT 15 - OS HOOK - DEVICE BUSY LOOP (AT,XT2,XT286,CONV,PS)
 AH = 90h
 AL = TYPE CODE
     00h: disk
     01h: diskette
     02h: keyboard
     80h: network
  ES:BX = NCB
     FCh: disk reset
     FDh: diskette motor start
     FEh: printer
Return: CF set if wait time satisfied
Note: type codes are allocated as follows:
 00-7F non-reentrant devices; OS must arbitrate access
 80-BF reentrant devices; ES:BX points to a unique control block
 C0-FF wait-only calls, no complementary INT 15/AH=91h call
-----------------------------------------------------------
INT 15 - OS HOOK - SET FLAG AND COMPLETE INTERRUPT (AT,XT2,XT286,CONV,PS)
 AH = 91h
 AL = type code, see AH=90h above
-----------------------------------------------------------
INT 15 - SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
 AH = C0h
Return: CF = 1 if BIOS doesn't support call
 ES:BX pointer to ROM table
      byte_count  dw   ?   ; number of bytes following
      model  db   ?   ; PC=ff, XT=fe or fb, PCjr = fd, etc, etc
      submodel  db   ?   ; distingushes between AT and XT/286, etc.
      BIOS_rev  db   ?   ; 0 for first release, 1 for 2nd, etc.
      featbyte  db   ?   ; 80h = DMA channel 3 used by hd BIOS
      ; 40h = 2nd 8259 installed
      ; 20h = Real-Time Clock installed
      ; 10h = INT 15h/AH=4Fh called upon INT 9h
      ;  8h = wait for external event supported
      ;  4h = extended BIOS area allocated at 640K
      ;  2h = bus is Micro Channel instead of PC
      ;  1h   reserved
      res1  dw   0
      res2  dw   0
Note: the 1/10/86 XT BIOS returns an incorrect value for featbyte.
-----------------------------------------------------------
INT 15 - SYSTEM - RETURN EXTENDED-BIOS DATA-AREA SEGMENT ADDRESS (PS)
 AH = C1h
 ???
Return: ???
-----------------------------------------------------------
INT 15 - POINTING DEVICE BIOS INTERFACE (PS)
 AH = C2h
 ???
Return: ???
-----------------------------------------------------------
INT 15 - DESQview - ???
 AH = C2h
 AL = subfunction
     00h ???
        BH = ???
     01h set something to default values
     02h ???
        BH = ???
     03h ???
        BH = ???
     04h NOP, points to RET instruction
     05h same as 01h, but also takes input value in BH
        BH = ???
     06h ???
        BH = 01h or 02h stored, otherwise ignored
     07h ???
        ES:BX = pointer to ???
        Return: AL = 00h
Note: the values in BH for those functions that take it as input are stored
      in different locations for each subfunction
----------------------------------------------------------
INT 15 - ENABLE/DISABLE WATCHDOG TIMEOUT (PS50+)
 AH = C3h
 ???
Return: ???
-----------------------------------------------------------
INT 15 - PROGRAMMABLE OPTION SELECT (PS50+)
 AH = C4h
 ???
Return: ???
-----------------------------------------------------------
INT 15 - DESQview - GET PROGRAM NAME
 AX = DE00h
Return: AX = offset into DESQVIEW.DVO of current program:
        BYTE  length of name
      N BYTES name
      2 BYTES keys to invoke program (second = 00h if only one key used)
      3 BYTES ??? (I see 0 always)
-----------------------------------------------------------
INT 15 - DESQview - UPDATE OPEN MENU???
 AX = DE01h
 ???
Return: nothing
Note: reads DESQVIEW.DVO, disables Open menu if file not in current directory
-----------------------------------------------------------
INT 15 - DESQview - UNIMPLEMENTED IN DV 2.00
 AX = DE02h
Return: nothing (NOP in DV 2.00)
-----------------------------------------------------------
INT 15 - DESQview - UNIMPLEMENTED IN DV 2.00
 AX = DE03h
Return: nothing (NOP in DV 2.00)
-----------------------------------------------------------
INT 15 - DESQview - GET AVAILABLE COMMON MEMORY
 AX = DE04h
Return: BX = bytes of common memory available
 CX = largest block available
 DX = total common memory in bytes
-----------------------------------------------------------
INT 15 - DESQview - GET AVAILABLE CONVENTIONAL MEMORY
 AX = DE05h
Return: BX = K of memory available
 CX = largest block available
 DX = total conventional memory in K
-----------------------------------------------------------
INT 15 - DESQview - GET AVAILABLE EXPANDED MEMORY
 AX = DE06h
Return: BX = K of expanded memory available
 CX = largest block available
 DX = total expanded memory in K
-----------------------------------------------------------
INT 15 - DESQview - "APPNUM" - GET CURRENT PROGRAM'S NUMBER
 AX = DE07h
Return: AX = number of program as it appears on the "Switch Windows" menu
-----------------------------------------------------------
INT 15 - DESQview - GET ???
 AX = DE08h
Return: AX = 0 ???
      1 ???
-----------------------------------------------------------
INT 15 - DESQview - UNIMPLEMENTED IN DV 2.00
 AX = DE09h
Return: nothing (NOP in DV 2.00)
-----------------------------------------------------------
INT 15 - DESQview 2.0 - "DBGPOKE" - DISPLAY CHARACTER ON STATUS LINE
 AX = DE0Ah
 BL = character
Return: character displayed, next call will display in next position (which
 wraps back to the start of the line if off the right edge of screen)
Notes: displays character on bottom line of *physical* screen, regardless
 of current size of window (even entirely hidden)
 does not know about graphics display modes, just pokes the characters
 into display memory
-----------------------------------------------------------
INT 15 - DESQview 2.0 - "APILEVEL" - DEFINE MINIMUM API LEVEL REQUIRED
 AX = DE0Bh
 BL = API level
      >2 pops up "You need a newer version" error window in DV 2.00
 BH = ???
Return: ???
-----------------------------------------------------------
INT 15 - DESQview 2.0 - "GETMEM" - ALLOCATE "SYSTEM" MEMORY
 AX = DE0Ch
 BX = number of bytes
Return: ES:DI = pointer to allocated block
-----------------------------------------------------------
INT 15 - DESQview 2.0 - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY
 AX = DE0Dh
 ES:DI = pointer to previously allocated block
Return: nothing
-----------------------------------------------------------
INT 15 - DESQview 2.0 - FIND MAILBOX BY NAME???
 AX = DE0Eh
 ES:DI = pointer to string
 CX = length of name
Return: BX = 0 not found
      1 found
  DS:SI = object handle???
-----------------------------------------------------------
INT 15 - DESQview 2.0 - ???
 AX = DE0Fh
Return: AX and BX destroyed (seems to be bug, weren't saved&restored)
Note: sends a manager stream with opcodes AEh, BDh, and BFh to task's window
-----------------------------------------------------------
INT 15 - DESQview 2.0 - "PUSHKEY" - PUT KEY INTO KEYBOARD INPUT STREAM
 AX = DE10h
 BH = scan code
 BL = character
Return: BX = ??? (sometimes, but not always, same as BX passed in)
Note: a later read will get the keystroke as if it had been typed by the user
-----------------------------------------------------------
INT 15 - DESQview 2.0 - ENABLE/DISABLE AUTOMATIC JUSTIFICATION OF WINDOW
 AX = DE11h
 BL = 0        viewport will not move automatically
      nonzero  viewport will move to keep cursor visible
Return: nothing
-----------------------------------------------------------
INT 16 - KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
 AH = 00h
Return: AH = scan code
 AL = character
-----------------------------------------------------------
INT 16 - KEYBOARD - CHECK BUFFER, DO NOT CLEAR
 AH = 01h
Return: ZF = 0 character in buffer
     AH = scan code
     AL = character
 ZF = 1 no character in buffer
-----------------------------------------------------------
INT 16 - KEYBOARD - GET SHIFT STATUS
 AH = 02h
 AL = shift status bits
     0 = right shift key depressed
     1 = left shift key depressed
     2 = CTRL depressed
     3 = ALT depressed
     4 = SCROLL LOCK active
     5 = NUM LOCK active
     6 = CAPS LOCK active
     7 = INSERT state active
-----------------------------------------------------------
INT 16 - KEYBOARD - SET DELAYS (Jr,AT model 339,XT286,PS)
 AH = 03h
 AL = subfunction
     0 reset typematic (PCjr)
     1 increase initial delay (PCjr)
     2 increase continuing delay (PCjr)
     3 increase both delays (PCjr)
     4 turn off typematic (PCjr)
     5 Set typematic rate (AT or PS/2)
 BH = 00 - 03 for delays of 250ms, 500ms, 750ms, or 1s
 BL = 00 - 1F for typematic rates of 30cps down to 2cps
-----------------------------------------------------------
INT 16 - KEYBOARD - KEYCLICK (Jr,CONV)
 AH = 04h
 AL =
     0 click off
     1 click on
-----------------------------------------------------------
INT 16 - KEYBOARD - WRITE TO KEYBOARD BUFFER (AT model 339,XT2,XT286,PS)
 AH = 05h
 CH = scan code
 CL = character
Return: AL = 1 if buffer full
-----------------------------------------------------------
INT 16 - KEYBOARD - GET ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS)
 AH = 10h
Return: AH = scan code
 AL = character
-----------------------------------------------------------
INT 16 - KEYBOARD - CHECK ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS)
 AH = 11h
Return: ZF = 0 if keystroke available
     AH = scan code \ meaningless if ZF = 1
     AL = character /
 ZF = 1 if kbd buffer empty
-----------------------------------------------------------
INT 16 - KEYBOARD - GET ENHANCED SHIFT FLAGS (AT model 339,XT2,XT286,PS)
 AH = 12h
Return: AL (same as for AH=02h)
    bit 7: Ins ON
    bit 6: CapsLock ON
    bit 5: NumLock ON
    bit 4: ScrollLock ON
    bit 3: Either ALT key down
    bit 2: Either CTRL key down
    bit 1: Left shift key down
    bit 0: Right shift key down
 AH
    bit 7: SysReq key down
    bit 6: CapsLock key down
    bit 5: NumLock key down
    bit 4: ScrollLock key down
    bit 3: Right Alt key down
    bit 2: Right Ctrl key down
    bit 1: Left Alt key down
    bit 0: Right Alt key down
-----------------------------------------------------------
INT 17 - PRINTER - OUTPUT CHARACTER
 AH = 00h
 AL = character
Return: AH = status bits
     0 = time out
     1 = unused
     2 = unused
     3 = I/O error
     4 = selected
     5 = out of paper
     6 = acknowledge
     7 = not busy
-----------------------------------------------------------
INT 17 - PRINTER - INITIALIZE
 AH = 01h
Return: AH = status (see AH = 00h above)
-----------------------------------------------------------
INT 17 - PRINTER - GET STATUS
 AH = 02h
Return: AH = status (see AH = 00h above)
-----------------------------------------------------------
INT 18 - TRANSFER TO ROM BASIC
   causes transfer to ROM-based BASIC (IBM-PC)
   often reboots a compatible; often has no effect at all
-----------------------------------------------------------
INT 19 - DISK BOOT
   causes reboot of disk system (no memory test performed)
-----------------------------------------------------------
INT 1A - CLOCK - GET TIME OF DAY
 AH = 00h
Return: CX:DX = clock count
 AL = 0 if clock was read or written (via AH=0,1)
        within the current 24-hour period
        Otherwise, AL > 0
-----------------------------------------------------------
INT 1A - CLOCK - SET TIME OF DAY
 AH = 01h
 CX:DX = clock count
Return: time of day set
-----------------------------------------------------------
INT 1A - CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)
 AH = 02h
Return: CH = hours
 CL = minutes
 DH = seconds
-----------------------------------------------------------
INT 1A - CLOCK - SET REAL TIME CLOCK (AT,XT286,CONV,PS)
 AH = 03h
 CH = hours
 CL = minutes
 DH = seconds
 DL = 1, if daylight savings; 0 if standard time
Return: CMOS clock set
-----------------------------------------------------------
INT 1A - CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
 AH = 04h
Return: DL = day
 DH = month
 CL = year
 CH = century (19 or 20)
-----------------------------------------------------------
INT 1A - CLOCK - SET DATE IN REAL TIME CLOCK (AT,XT286,CONV,PS)
 AH = 05h
 DL = day
 DH = month
 CL = year
 CH = century (19 or 20)
Return: CMOS clock set
-----------------------------------------------------------
INT 1A - CLOCK - SET ALARM (AT,XT286,CONV,PS)
 AH = 06h
 CH = hours
 CL = minutes
 DH = seconds
Return: CF set if alarm already set or clock inoperable
 INT 4Ah will be called when alarm goes off
-----------------------------------------------------------
INT 1A - CLOCK - RESET ALARM (AT,XT286,CONV,PS)
 AH = 07h
Return: alarm disabled
-----------------------------------------------------------
INT 1A - CLOCK - SET RTC ACTIVATED POWER ON MODE (CONVERTIBLE)
 AH = 08h
 CH = hours in BCD
 CL = minutes in BCD
 DH = seconds in BCD
-----------------------------------------------------------
INT 1A - CLOCK - READ RTC ALARM TIME AND STATUS (CONV,PS30)
 AH = 09h
Return: CH = hours in BCD
 CL = minutes in BCD
 DH = seconds in BCD
 DL = alarm status
     0  alarm not enabled
     1  alarm enabled but will not power up system
     2  alarm will power up system
-----------------------------------------------------------
INT 1A - CLOCK - READ SYSTEM-TIMER DAY COUNTER (XT2,PS)
 AH = 0Ah
 ???
Return: ???
-----------------------------------------------------------
INT 1A - CLOCK - SET SYSTEM-TIMER DAY COUNTER (XT2,PS)
 AH = 0Bh
 ???
Return: ???
-----------------------------------------------------------
INT 1A - SET UP SOUND MULTIPLEXOR (PCjr ONLY)
 AH = 80h
 AL = 0 source is 8253 channel 2
      1 source is cassette input
      2 source is I/O channel "Audio IN"
      3 source is sound generator chip
-----------------------------------------------------------
INT 1B - CTRL-BREAK KEY
   This interrupt is called when the keyboard scanner of the IBM
   machines detects CTRL and BREAK pressed at the same time. It
   normally points to a short routine in DOS which sets the
   Ctrl-C flag, thus invoking INT 23h the next time DOS checks
   for Ctrl-C.
-----------------------------------------------------------
INT 1C - CLOCK TICK
   This interrupt is called (in the IBM) at the end of each time-update
   operation by the time-of-day routines.  It normally points to an IRET.
-----------------------------------------------------------
INT 1D -> 6845 VIDEO INIT TABLES
 table for modes 0 and 1   \
 table for modes 2 and 3    \ each table is 16 bytes long and
 table for modes 4,5, and 6 / contains values for 6845 registers
 table for mode 7   /
 4 words -- size of video RAM for modes 0/1, 2/3, 4/5, and 6/7
 8 bytes -- number of columns in each mode
 8 bytes -- video controller mode byte for each mode
-----------------------------------------------------------
INT 1E -> DISKETTE PARAMS (BASE TABLE)
 (Default at F000:EFC7 in PC and most compatibles)
 DB step rate & head unload times
 DB head load time & DMA
 DB motor off time in clock ticks (36 or 37 typical)
 DB sector size in bytes (0->128, 1->256, 2->512, 3->1024)
 DB last sector number (8 or 9 typical)
 DB inter-sector gap size on read/write (42 typical)
 DB data transfer length (255 typical)
 DB inter-sector gap size on format (80 typical)
 DB sector fill on format (F6h typical)
 DB head-settle time ms (typical 25, 1.10->0, 2.10->15, 3.10->1)
 DB motor start-up time (1/8 secs) (typical 4, 2.10->2)
-----------------------------------------------------------
INT 1F -> GRAPHICS SET 2
       (NOT a vector!) pointer to bitmaps for high 128 chars
-----------------------------------------------------------
INT 20 - Minix - SEND/RECEIVE MESSAGE
 AX = process ID of other process
 BX = pointer to message
 CX = 1 send
      2 receive
      3 send&receive
Note: the message contains the system call number (numbered as in V7 Unix(tm))
      and the call parameters
-----------------------------------------------------------
INT 20 - DOS - PROGRAM TERMINATION
returns to DOS--identical to INT 21/AH=00h
-----------------------------------------------------------
INT 21 - DOS - PROGRAM TERMINATION
 AH = 00h
Return: never
-----------------------------------------------------------
INT 21 - DOS - KEYBOARD INPUT
 AH = 01h
Return: AL = character read
Note: ^C/^Break are checked, and INT 23h executed if read
-----------------------------------------------------------
INT 21 - DOS - DISPLAY OUTPUT
 AH = 02h
 DL = character
-----------------------------------------------------------
INT 21 - DOS - AUX INPUT
 AH = 03h
Return: AL = character read
-----------------------------------------------------------
INT 21 - DOS - AUX OUTPUT
 AH = 04h
 DL = character to send
-----------------------------------------------------------
INT 21 - DOS - PRINTER OUTPUT
 AH = 05h
 DL = character to print
-----------------------------------------------------------
INT 21 - DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
 AH = 06h
 DL = character <> FFh
-----------------------------------------------------------
INT 21 - DOS - DIRECT CONSOLE I/O CHARACTER INPUT
 AH = 06h
 DL = 0FFh
Return: ZF set  = no character
 ZF clear = character recieved
    AL = character
Notes: Character is echoed to STDOUT if received.
       ^C/^Break are NOT checked
-----------------------------------------------------------
INT 21 - DOS - DIRECT STDIN INPUT, NO ECHO
 AH = 07h
Note: same as function 06h for input but char not echoed
-----------------------------------------------------------
INT 21 - DOS - KEYBOARD INPUT, NO ECHO
 AH = 08h
Return: AL = character
Note: same as function 07h, but ^C/^Break are checked
-----------------------------------------------------------
INT 21 - DOS - PRINT STRING
 AH = 09h
 DS:DX = address of string terminated by "$"
-----------------------------------------------------------
INT 21 - DOS - BUFFERED KEYBOARD INPUT
 AH = 0Ah
 DS:DX = address of buffer
Note: first byte of buffer must contain maximum length
      on entry, second byte contains actual length of previous line which may
 be recalled with the DOS line-editing commands
      on return the second byte contains actual length, third and
 subsequent bytes contain the input line
-----------------------------------------------------------
INT 21 - DOS - CHECK STANDARD INPUT STATUS
 AH = 0Bh
Return: AL = FFh if character available
      00h if no character
-----------------------------------------------------------
INT 21 - DOS - CLEAR KEYBOARD BUFFER
 AH = 0Ch
 AL must be 1, 6, 7, 8, or 0Ah.
Notes: Flushes all typeahead input, then executes function specified by AL
       (effectively moving it to AH and repeating the INT 21 call).
       If AL contains a value not in the list above, the keyboard buffer is
       flushed and no other action is taken.
-----------------------------------------------------------
INT 21 - DOS - DISK RESET
 AH = 0Dh
Note: Flushes all disk buffers.
-----------------------------------------------------------
INT 21 - DOS - SELECT DISK
 AH = 0Eh
 DL = new default drive number (0 = A, 1 = B, etc.)
Return: AL = number of logical drives
-----------------------------------------------------------
INT 21 - DOS - OPEN DISK FILE
 AH = 0Fh
 DS:DX = address of FCB
Return: AL = 00h file found
      FFh file not found
-----------------------------------------------------------
INT 21 - DOS - CLOSE DISK FILE
 AH = 10h
 DS:DX = address of FCB
Return: AL = 00h directory update successful
      FFh file not found in directory
-----------------------------------------------------------
INT 21 - DOS - SEARCH FIRST USING FCB
 AH = 11h
 DS:DX = address of FCB
Return: AL = status
     00h file found
     FFh file not found
Note: If file found, FCB is created at DTA address and set up to
      OPEN or DELETE it.
-----------------------------------------------------------
INT 21 - DOS - SEARCH NEXT USING FCB
 AH = 12h
 DS:DX = address of FCB
Return: AL = status
     00h file found
     FFh file not found
Note: If file found, FCB is created at DTA address and set up to
      OPEN or DELETE it.
-----------------------------------------------------------
INT 21 - DOS - DELETE FILE via FCB
 AH = 13h
 DS:DX = address of FCB
Return: AL = status
     00h file found
     FFh file not found
-----------------------------------------------------------
INT 21 - DOS - SEQUENTIAL DISK FILE READ
 AH = 14h
 DS:DX = address of FCB
Return: AL = status
     0 successful read
     1 end of file
     2 data transfer area too small
     3 partial record, EOF
-----------------------------------------------------------
INT 21 - DOS - SEQUENTIAL DISK RECORD WRITE
 AH = 15h
 DS:DX = address of FCB
Return: AL = status
     0 successful write
     1 disk full
     2 data transfer area too small
-----------------------------------------------------------
INT 21 - DOS - CREATE A DISK FILE
 AH = 16h
 DS:DX = address of FCB
Return: AL = status
     00h successful creation
     FFh directory full
-----------------------------------------------------------
INT 21 - DOS - RENAME FILE via FCB
 AH = 17h
 DS:DX = address of FCB
 FCB contains new name starting at byte 17h.
Return: AL = status
     00h file found
     FFh file not found
-----------------------------------------------------------
INT 21 - DOS Internal - UNUSED
 AH = 18h
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS - GET DEFAULT DISK NUMBER
 AH = 19h
Return: AL = current drive number (letter - 'A')
-----------------------------------------------------------
INT 21 - DOS - SET DISK TRANSFER AREA ADDRESS
 AH = 1Ah
 DS:DX = address of buffer
-----------------------------------------------------------
INT 21 - DOS - GET DEFAULT DRIVE DISK SIZE
 AH = 1Bh
Return: DS:BX points to FAT ID byte
 DX = number of allocation units on disk
 AL = number of sectors per allocation unit (cluster)
 CX = number of bytes per sector
-----------------------------------------------------------
INT 21 - DOS - GET SPECIFIC DRIVE'S DISK SIZE
 AH = 1Ch
 DL = Drive Number to check
Return: DS:BX points to FAT ID byte
 DX = number of allocation units on disk
 AL = number of sectors per allocation unit (cluster)
 CX = number of bytes per sector
-----------------------------------------------------------
INT 21 - DOS Internal - UNUSED
 AH = 1Dh
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS Internal - UNUSED
 AH = 1Eh
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS Internal - GET DEFAULT DRIVE PARAMETER BLOCK
 AH = 1Fh
Return: AL = 00h No Error
      FFh Error
 DS:BX = pointer to drive parameter block
Note: for DOS 2.x and 3.x, this just invokes function 32h with DL = 0
-----------------------------------------------------------
INT 21 - DOS Internal - UNUSED
 AH = 20h
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS - RANDOM DISK RECORD READ
 AH = 21h
 DS:DX = address of FCB
Return: AL = status
     0 successful read
     1 end of file
     2 data transfer area too small
     3 partial record, EOF
-----------------------------------------------------------
INT 21 - DOS - RANDOM DISK RECORD WRITE
 AH = 22h
 DS:DX = address of FCB
Return: AL = status (see AH = 21h above)
-----------------------------------------------------------
INT 21 - DOS - GET FILE SIZE
 AH = 23h
 DS:DX = address of FCB
Return: AL = status
     00h file found
     FFh file not found
Note: FCB set to number of records
-----------------------------------------------------------
INT 21 - DOS - SET RANDOM RECORD FIELD
 AH = 24h
 DS:DX = address of FCB
Return: Random Record Field of FCB is set to be same as Current Block
 and Current Record.
Note: FCB must be OPEN already
-----------------------------------------------------------
INT 21 - DOS - SET INTERRUPT VECTOR
 AH = 25h
 AL = interrupt number
 DS:DX = new vector to be used for specified interrupt
-----------------------------------------------------------
INT 21 - DOS - CREATE PSP
 AH = 26h
 DX = Segment number to set up PSP at
Return: Current PSP is copied to specified segment
-----------------------------------------------------------
INT 21 - DOS - RANDOM BLOCK READ
 AH = 27h
 DS:DX = address of FCB
 CX = number of records to be read
Return: AL = status
     0 successful read
     1 end of file
     2 data transfer area too small
     3 partial record, EOF
-----------------------------------------------------------
INT 21 - DOS - RANDOM BLOCK WRITE
 AH = 28h
 DS:DX = address of FCB
 CX = number of records to be written
      if zero, truncate file to current random file position
Return: AL = status
     0 successful write
     1 disk full
     2 data transfer area too small
-----------------------------------------------------------
INT 21 - DOS - PARSE FILENAME
 AH = 29h
 DS:SI = pointer to string to parse
 ES:DI = pointer to memory to fill with unopened FCB
 AL = bit mask to control parsing
     0 = 0: parsing stops if file separator found
  1: leading separator ignored
     1 = 0: drive number in FCB set to default drive if not present
     in string
  1: drive number in FCB not changed
     2 = 0: filename in FCB set to blanks if no filename in string
  1: filename in FCB not changed if string does not contain
     a filename
     3 = 0: extension in FCB set to blanks if no extension in string
  1: extension left unchanged
Return: AL = 00: no wildcards in name or extension
      01: wildcards appeared
 DS:SI = pointer to first byte after parsed string
 ES:DI = unopened FCB
-----------------------------------------------------------
INT 21 - DOS - GET CURRENT DATE
 AH = 2Ah
Return: DL = day
 DH = month
 CX = year
 AL = day of the week (0=Sunday, 1=Monday, etc.)
-----------------------------------------------------------
INT 21 - DOS - SET CURRENT DATE
 AH = 2Bh
 DL = day
 DH = month
 CX = year
Return: AL = 00h if no error
    = FFh if bad value sent to routine
Note: DOS 3.3 also sets CMOS clock
-----------------------------------------------------------
INT 21 - DESQview - INSTALLATION CHECK
 AH = 2Bh
 AL = subfunction
     01h get version
  Return: BX = version (v2.00 returns 0002h, v2.01 returns 0201h)
     02h get shadow buffer info, and start shadowing
  Return: BH = rows in shadow buffer
   BL = columns in shadow buffer
   DX = segment of shadow buffer
     04h get shadow buffer info
  Return: BH = rows in shadow buffer
   BL = columns in shadow buffer
   DX = segment of shadow buffer
     05h stop shadowing
 CX = 4445h ('DE')
 DX = 5351h ('SQ')
Return: AL = FFh if DESQview not installed
-----------------------------------------------------------
INT 21 - DOS - GET CURRENT TIME
 AH = 2Ch
Return: CH = hours
 CL = minutes
 DH = seconds
 DL = hundredths of seconds
Note: time is updated approximately every 5/100 second
-----------------------------------------------------------
INT 21 - DOS - SET CURRENT TIME
 AH = 2Dh
 CH = hours
 CL = minutes
 DH = seconds
 DL = hundredths of seconds
Return: AL = 00h if no error
    = FFh if bad value sent to routine
Note: DOS 3.3 also sets CMOS clock
-----------------------------------------------------------
INT 21 - DOS - SET VERIFY FLAG
 AH = 2Eh
 DL = 0
 AL = 1 VERIFY on
      0 VERIFY off
-----------------------------------------------------------
INT 21 - DOS 2+ - GET DISK TRANSFER AREA ADDRESS
 AH = 2Fh
Return: ES:BX = address of DTA
-----------------------------------------------------------
INT 21 - DOS 2+ - GET DOS VERSION
 AH = 30h
Return: AL = Major Version number
 AH = Minor Version number
 BH = OEM number
     00h IBM
     16h DEC
 BL:CX = 24-bit user number
-----------------------------------------------------------
INT 21 - DOS 2+ - TERMINATE BUT STAY RESIDENT
 AH = 31h
 AL = exit code
 DX = program size, in paragraphs
-----------------------------------------------------------
INT 21 - DOS Internal - GET DRIVE PARAMETER BLOCK
 AH = 32h
 DL = drive number
     0 = default, 1 = A, etc.
Return: AL = 0FFh if invalid drive number, else
 DS:BX = address of drive parameter block.
  STRUCTURE OF DOS DRIVE PARAMETER BLOCK:
DPBLOCK  STRUCT  ;Offset
DISK_OFFSET DB ? ;  0  drive number (0 = A, etc.)
UNIT_OFFSET DB ? ;  1  unit number within device driver
SECTOR_SIZE DW ? ;  2  number of bytes per sector
MAX_CLUSTER DB ? ;  4  largest sector number in cluster
    ;     add one for number of sectors/cluster
LOG2_SECTORS DB ? ;  5  log base two of the cluster size
RESERVED DW ? ;  6  number of reserved (boot) sectors
FAT_COUNT DB ? ;  8  number of copies of the FAT
ROOT_COUNT DW ? ;  9  number of root directory entries
DATA_START DW ? ; 11  first data sector on medium
MAX_NUMBER DW ? ; 13  largest possible cluster number
    ;     subtract one for number of data clusters
FAT_SECTORS DB ? ; 15  number of sectors in one FAT copy
ROOT_START DW ? ; 16  first sector of root directory
DEVICE_ADDR DD ? ; 18  address of device driver for this drive
DESCRIPTOR DB ? ; 22  media descriptor byte for medium
VALID_BYTE DB ? ; 23  0FFh indicates block must be rebuilt
NEXT_BLOCK DD ? ; 24  address of next device block in list
; from this point on, DOS 3 differs from DOS 2:
  IF DOS2
DIR_START DW ? ; 28  starting cluster of current directory
    ;     zero indicates the root directory
PATH_NAME DB 64 DUP (?)
    ; 30  ASCIZ current directory path string
  ELSE DOS3
;  on my XT, this was always:
  DW 0
  DW 0FFFFh
  ENDIF
DPBLOCK  ENDS
-----------------------------------------------------------
INT 21 - DOS 2+ - EXTENDED CONTROL-BREAK CHECKING
 AH = 33h
 AL = subfunction
     00h Get State
     01h Set
        DL = 0 for OFF or 1 for ON
     02h internal, called by PRINT.COM (DOS 3.1)
Return: DL = current BREAK setting if AL = 00h
     0 BREAK=OFF
     1 BREAK=ON
 AL = FFh if error
-----------------------------------------------------------
INT 21 - DOS Internal - RETURN CritSectFlag POINTER
 AH = 34h
Return: ES:BX points to DOS "Critical Section Flag"
Notes:
   When byte pointed to is zero, DOS is supposed to be safe to interrupt.
   NOT RELIABLE according to Chris Dunford.
   Examination of DOS 2.10 code in this area indicates that the byte
   immediately FOLLOWING this "Critical Section Flag" must be 00 to permit the
   PRINT.COM interrupt to be called.
   For DOS 3.0 and 3.1 (except COMPAQ DOS 3.0), the byte BEFORE the "Critical
   Section Flag" must be zero, and for COMPAQ DOS 3.0, the byte 01AAh before it
   must be zero.
-----------------------------------------------------------
INT 21 - DOS 2+ - GET INTERRUPT VECTOR
 AH = 35h
 AL = interrupt number
Return: ES:BX = value of interrupt vector
-----------------------------------------------------------
INT 21 - DOS 2+ - GET DISK SPACE
 AH = 36h
 DL = drive code (0 = default, 1 = A, 2 = B, etc.)
Return: AX = number of sectors per cluster
      or 0FFFFh if invalid drive
 BX = number of available clusters
 CX = bytes per sector
 DX = total clusters
Note: multiply AX x CX x BX for free space on disk
      multiply AX x CX x DX for total disk space
-----------------------------------------------------------
INT 21 - DOS Internal - SWITCHAR/AVAILDEV
 AH = 37h
 AL = subfunction
    0 Read switch character (returns current character in DL)
    1 Set switch character (specify new character in DL)
    2 (DOS 2.x only) Read device availability (as set by function AL=3)
    3 (DOS 2.x only) Set device availability, where:
      DL = 0 means /DEV/ must preceed device names
      DL <> 0 means /DEV/ need not preceed device names
Return: DL = Switch character (if AL=0 or 1)
      Device availability flag (if AL=2 or 3)
 AL=0FFh means the value in AL was not in the range 0-3.
-----------------------------------------------------------
INT 21 - DOS 2+ - GET COUNTRY-DEPENDENT INFORMATION
 AH = 38h
--DOS 2.x--
 AL = 0 get current-country info
 DS:DX = segment:offset of buffer for returned info
Return: BX = country code
 buffer at DS:DX filled as follows:
    bytes 0-1 = date format   0 = USA mm dd yy
         1 = Europe dd mm yy
         2 = Japan yy mm dd
    byte 2    = currency symbol
    byte 3    = 00h
    byte 4    = thousands separator char
    byte 5    = 00h
    byte 6    = decimal separator char
    byte 7    = 00h
    bytes 8-1Fh reserved
--DOS 3.x--
 AL = 0 for current country
 AL = 01h thru 0FEh for specific country with code <255
 AL = 0FFh for specific country with code >= 255
    BX = 16-bit country code
 DS:DX = segment:offset of buffer for returned info
 DX = 0FFFFh if setting country code, rather than getting info
Return: (if DX <> 0FFFFh)
 BX = country code
 DS:DX filled in:
       bytes 0-1 = date format (see above)
       bytes 2-6 = currency symbol string, ASCIZ
       byte 7 = thousands seaprator char
       byte 8 = 00h
       byte 9 = decimal separator char
       byte 0Ah = 00h
       byte 0Bh = date separator char
       byte 0Ch = 00h
       byte 0Dh = time separator char
       byte 0Eh = 00h
       byte 0Fh = currency format
      bit 1 = number of spaces between value and curr sym
      bit 0 = 0 if currency symbol precedes value
       1 if currency symbol follows value
       byte 10h = number of digits after decimal in currency
       byte 11h = time format
      bit 0 = 0 if 12-hour clock
       1 if 24-hour clock
       bytes 12h-15h = address of case map routine (FAR CALL)
       byte 16h = data-list separator char
       byte 17h = 00h
       bytes 18h-21h reserved
      If error:
 CF set
 AX = error code
-----------------------------------------------------------
INT 21 - DOS 2+ - CREATE A SUBDIRECTORY (MKDIR)
 AH = 39h
 DS:DX = address of ASCIZ pathname
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - REMOVE A DIRECTORY ENTRY (RMDIR)
 AH = 3Ah
 DS:DX = address of ASCIZ pathname
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - CHANGE THE CURRENT DIRECTORY (CHDIR)
 AH = 3Bh
 DS:DX = address of ASCIZ directory name
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - CREATE A FILE WITH HANDLE (CREAT)
 AH = 3Ch
 CX = attributes for file
 DS:DX = address of ASCIZ filename
Return: CF = 1 if error
     AX = Error Code
 CF = 0 successful
     AX = file handle
-----------------------------------------------------------
INT 21 - DOS 2+ - OPEN DISK FILE WITH HANDLE
 AH = 3Dh
 AL = access code
     0 = Read Only
     1 = Write Only
     2 = Read/Write
 AL bits 7-3 = file-sharing modes (DOS 3.x)
     bit 7    = inheritance flag, set for no inheritance
     bits 4-6 = sharing mode
        000 compatibility mode
        001 exclusive (deny all)
        010 write access denied (deny write)
        011 read access denied (deny read)
        100 full access permitted (deny none)
     bit 3    = reserved, should be zero
 DS:DX = address of ASCIZ filename
Return: CF = 1 if error
     AX = Error Code
 CF = 0 successful
     AX = file handle
-----------------------------------------------------------
INT 21 - DOS 2+ - CLOSE A FILE WITH HANDLE
 AH = 3Eh
 BX = file handle
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - READ FROM FILE WITH HANDLE
 AH = 3Fh
 BX = file handle
 CX = number of bytes to read
 DS:DX = address of buffer
Return: CF = 1 if error
     AX = Error Code
 CF = 0 successful
     AX = number of bytes read
-----------------------------------------------------------
INT 21 - DOS 2+ - WRITE TO FILE WITH HANDLE
 AH = 40h
 BX = file handle
 CX = number of bytes to write
 DS:DX = pointer to buffer
Return: CF = 1 if error
     AX = Error Code
 CF = 0 successful
     AX = number of bytes written
Note: if CX is zero, no data is written, and the file is truncated or extended
      to the current position
-----------------------------------------------------------
INT 21 - DOS 2+ - DELETE A FILE (UNLINK)
 AH = 41h
 DS:DX = pointer to ASCIZ name of file to delete
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 AH = 42h
 AL = method value
     0 = offset from beginning of file
     1 = offset from present location
     2 = offset from end of file
 BX = file handle
 CX:DX = offset in bytes
Return: CF = 1 if error
     AX = Error Code
 CF = 0 successful
     DX:AX = new offset
-----------------------------------------------------------
INT 21 - DOS 2+ - GET/PUT FILE ATTRIBUTES (CHMOD)
 AH = 43h
 AL =
     0 = get file attributes
     1 = put file attributes
        CX = file attribute bits
     0 = read only
     1 = hidden file
     2 = system file
     3 = volume label
     4 = subdirectory
     5 = written since backup
 DS:DX = pointer to ASCIZ file name
Return: CF = 1 if error
     AX = Error Code if any
 CX = file attributes on get
-----------------------------------------------------------
INT 21 - DOS 2+ - IOCTL
 AH = 44h
 AL =
    0 = Get device information (DX)
    1 = Set device information (DH must be 0 on entry)
        DX BITS =
   0 = console input device
   1 = console output device
   2 = null device
   3 = clock device
   5 = binary mode
   6 = EOF
   7 = device is character device if set
       if not, EOF = 0 if channel has been written
       bits 0-5 are block device number
  12 = network device
  14 = can process control strings (AL=2-5, can only be read)
  15 reserved
    2 = Read CX bytes to DS:DX from BX control channel
        Return: AX = number of bytes transferred
    3 = Write CX bytes from DS:DX from BX control channel
        Return: AX = number of bytes transferred
    4 = as 2 but for drive BL
        Return: AX = number of bytes transferred
    5 = as 3 but for drive BL
        Return: AX = number of bytes transferred
    6 = Get input status
        Return: AL = FFh for ready, 00h for not ready
    7 = Get output status
        Return: AL = FFh for ready or 00h for not ready
    8 = Is block device BL changeable? (DOS 3.x)
        Return: AX = 0 removable
       1 fixed
    9 = Is logical device BL local? (DOS 3.x)
        DX (attribute word) bit 12 (1000h) = 0 = yes
   10 = Is handle BX local? (DOS 3)
        DX (attribute word) bit 15 (8000h) = 0 = yes
   11 = Change sharing retry count to DX (def 3), (DOS 3.x)
        delay CX (def 1)
   12 = General IOCTL (DOS 3.3 [3.2?])
 BX = file handle (or BL = drive number with 0 = default)
Return: CF = 1 if error
     AX = Error Code
Note: only subfunctions 00h,06h,07h are available for files
-----------------------------------------------------------
INT 21 - DOS 2+ - CREATE DUPLICATE HANDLE (DUP)
 AH = 45h
 BX = file handle to duplicate
Return: CF = 1 if error
     AX = Error Code
 CF = 0 successful
     AX = new file handle
-----------------------------------------------------------
INT 21 - DOS 2+ - FORCE DUPLICATE HANDLE (FORCDUP,DUP2)
 AH = 46h
 BX = Existing file handle
 CX = new file handle
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - GET CURRENT DIRECTORY
 AH = 47h
 DL = drive (0=default, 1=A, etc.)
 DS:SI points to 64-byte buffer area
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - ALLOCATE MEMORY
 AH = 48h
 BX = number of 16-byte paragraphs desired
Return: CF = 1 if error
     AX = Error Code
     BX = Maximum available
 CF = 0 successful
     AX = segment of allocated memory block
-----------------------------------------------------------
INT 21 - DOS 2+ - FREE MEMORY
 AH = 49h
 ES = Segment address of area to be freed
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 AH = 4Ah
 ES = Segment address of block to change
 BX = New size in paragraphs
Return: CF = 1 if error
     AX = Error Code
     BX = Maximum size possible for the block
-----------------------------------------------------------
INT 21 - DOS 2+ - LOAD OR EXECUTE (EXEC)
 AH = 4Bh
 AL = subfunction
     0 = load and execute program
     2 = load (Internal) but do not execute
     3 = load overlay; do not create PSP
 DS:DX = filename
 ES:BX = parameter block
        AL =
  0 => WORD segment environment pointer
       DWORD command line pointer
       DWORD FCB 1
       DWORD FCB 2
  3 => WORD segment load address
       WORD segment relocation factor
Return: CF = 1 if error
     AX = Error Code
struct exec {   /* structure of .EXE file header */
 unsigned exec_magic; /* 0x4d, 0x5a signature */
 unsigned exec_isr; /* image size remainder (mod 512) */
 unsigned exec_size; /* file size in pages (512) */
 unsigned exec_nrel; /* number of relocation items */
 unsigned exec_hsize; /* header size in paragraphs */
 unsigned exec_min; /* minimum extra paragraphs */
 unsigned exec_max; /* maximum extra paragraphs */
 unsigned exec_ss; /* stack segment */
 unsigned exec_sp; /* stack offset */
 unsigned exec_cksum; /* word checksum of entire file */
 unsigned exec_pc; /* initial pc */
 unsigned exec_cs; /* code segment */
 unsigned exec_orel; /* offset of relocation table */
 unsigned exec_ovno; /* overlay number */
};
-----------------------------------------------------------
INT 21 - DOS 2+ - QUIT WITH EXIT CODE (EXIT)
 AH = 4Ch
 AL = exit code
Return: never returns
-----------------------------------------------------------
INT 21 - DOS 2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)
 AH = 4Dh
Return: AL = exit code of subprogram (functions 31h or 4Ch)
 AH = circumstance which caused termination
     0 = Terminate/abort
     1 = Control-C
     2 = Hard error
     3 = Terminate and stay resident
-----------------------------------------------------------
INT 21 - DOS 2+ - FIND FIRST ASCIZ (FIND FIRST)
 AH = 4Eh
 CX = search attributes
 DS:DX = pointer to ASCIZ filename
Return: CF = 1 if error
     AX = Error Code if any
 [DTA] = data block
       byte  00h:     drive letter (undocumented)
       bytes 01h-0Bh: search template (undocumented)
       bytes 0Ch-14h: reserved
       byte  15h:     attribute of file found
       bytes 16h-17h: file time
       bytes 18h-19h: file date
       bytes 1Ah-1Dh: file size
       bytes 1Eh-3Ah: ASCIZ filename+extension
-----------------------------------------------------------
INT 21 - DOS 2+ - FIND NEXT ASCIZ (FIND NEXT)
 AH = 4Fh
Return: CF = 1 if error
     AX = Error Code
 [DTA] = data block, see AH = 4Eh above
-----------------------------------------------------------
INT 21 - DOS Internal - SET PSP SEGMENT
 AH = 50h
 BX = Segment address of new PSP
Note: under DOS 2.xx, this function cannot be invoked inside an INT 28h handler
      without a prior call to function 5Dh
-----------------------------------------------------------
INT 21 - DOS Internal - GET PSP SEGMENT
 AH = 51h
Return: BX = Current PSP Segment
struct psp {
 char psp_int20[2]; /* 00h: exit */
 unsigned psp_msize; /* 02h: memory size in paragraphs */
 char psp_res0[1]; /* 04h: ??? (0) */
 char psp_dos[5]; /* 05h: far call to dos */
 int (*psp_term)(); /* 0ah: terminate address */
 unsigned psp_tseg; /* 0ch: terminate segment */
 int (*psp_break)(); /* 0eh: break address */
 unsigned psp_bseg; /* 10h: break segment */
 int (*psp_error)(); /* 12h: error address */
 unsigned psp_eseg; /* 14h: error segment */
 unsigned psp_ppsp; /* 16h: parent psp segment */
 char psp_ofile[20]; /* 18h: open files, 0xff = unused */
 unsigned psp_envp; /* 2ch: environment segment */
 char far *psp_oldstack; /* 2eh: far ptr to processes SS:SP??? */
 int psp_nfiles;  /* 32h: max open files */
 char *psp_aofile; /* 34h: ofile address */
 unsigned psp_aoseg; /* 36h: ofile segment */
 char psp_res3[24]; /* 38h: unused??? */
 char psp_int21[3]; /* 50h: int 21, far return */
 char psp_res4[2]; /* 53h: unused??? */
 char psp_xfcb1[7]; /* 55h: FCB #1 extension */
 char psp_fcb1[9]; /* 5ch: FCB #1 */
 char psp_xfcb2[7]; /* 65h: FCB #2 extension */
 char psp_fcb2[20]; /* 6ch: FCB #2 */
 char psp_dma[128]; /* 80h: Command Tail */
};
Note: under DOS 2.xx, this function cannot be invoked inside an INT 28h handler
      without a prior call to function 5Dh
-----------------------------------------------------------
INT 21 - DOS Internal - GET DISK LIST
 AH = 52h
Return: ES:BX points to DOS list of lists
List of Lists:
Bytes Value
-2&-1 Segment of first memory control block
0-3 Pointer to first DOS disk block (see func 36h)
4-7 ??? Partially Unknown. Pointer to a device driver. Maybe first
        resident driver?
8-B Pointer to CLOCK$ device driver, whether installable or
        resident
C-F Pointer to actual CON: device driver, whether installable
        or resident
-----DOS 2.x
10 Number of logical drives in system
11-12 Maximum bytes/block of any block device
13-16 ???
17 Beginning (not a pointer. The real beginning!) of NUL device
    driver. This is the first device on DOS's linked list
    of device drivers.
-----DOS 3.x
10-11 Maximum bytes/block of any block device (0200h)
12-15 ??? Pointer to current directory block?
16-19 Partially Undefined: Pointer to array of drive info:
        51h bytes per drive, starting with A: ...
        00-3F Current path as ASCIZ, starting with 'x:\'
        40-43 ??? I see zeros always
        44    ??? Flags? I see 40h, except for
         entry after last valid entry = 00h
        45-48 Pointer to DOS Disk Block for this drive
        49-4A ??? Current track or block? -1 if never accessed.
        4B-4E ??? I see -1 always
        4F-52 ??? I see 2 always
1A-1D ??? Pointer to data area, maybe including cluster
        allocation table?
1E-1F ??? I see zero always
20 Number of block devices.
21 Value of LASTDRIVE command in CONFIG.SYS (default 5)
22 Beginning (not a pointer. The real beginning!) of NUL device
    driver. This is the first device on DOS's linked list
    of device drivers.
-----------------------------------------------------------
INT 21 - DOS Internal - TRANSLATE BPB
 AH = 53h
 DS:SI points to BPB (Bios Parameter Block)
 ES:BP points to area for DOS Disk Block
Translates BPB (Bios Parameter Block, see below) into a DOS Disk Block
(see function call 32h).
BPB
Bytes Value
0-1 Bytes/sector. Get from DDB bytes 2-3.
2 Sectors/cluster. Get from: (DDB byte 4) + 1
3-4 Reserved sectors. Get from: DDB bytes 6-7
5 Number of FATs. Get from: DDB byte 8
6-7 Number of root dir entries. Get from: DDB bytes 9-A
8-9 Total # of sectors. Get from:
 ((DDB bytes D-E) - 1) * (sectors per cluster (BPB byte 2))
   + (DDB Bytes B-C)
A Media descriptor byte. Get from: DDB byte 16
B-C Number of sectors/FAT. Get from: DDB byte F
-----------------------------------------------------------
INT 21 - DOS 2+ - GET VERIFY FLAG
 AH = 54h
Return: AL = 0 if flag OFF
 AL = 1 if flag ON
-----------------------------------------------------------
INT 21 - DOS Internal - CREATE PSP
 AH = 55h
 DX = Segment number to set up PSP at
Note: Like func 26h but creates "child" PSP rather than copying existing one.
-----------------------------------------------------------
INT 21 - DOS 2+ - RENAME A FILE
 AH = 56h
 DS:DX = pointer to ASCIZ old name
 ES:DI = pointer to ASCIZ new name
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - GET/SET FILE'S DATE/TIME
 AH = 57h
 AL = function code
     0 = get date and time
     1 = set date and time
        CX = time to be set
        DX = date to be set
 BX = file handle
Return: CF = 1 if error
     AX = Error Code
 CX = time of last write (if AL = 0)
 DX = date of last write (if AL = 0)
-----------------------------------------------------------
INT 21 - DOS 3.x - GET/SET MEMORY ALLOCATION STRATEGY
 AH = 58h
 AL = function code
     0 = get allocation strategy
     1 = set allocation strategy
        BL = strategy code
     0 first fit (use first memory block large enough)
     1 best fit (use smallest memory block large enough)
     2 last fit (use high part of last usable memory block)
Return: CF = 1 error
     AX = Error Code
 CF = 0 successful
     AX = strategy code
Note: the Set subfunction accepts any value in BL; 2 or greater means last fit.
      the Get subfunction returns the last value set, so programs should check
      whether the value is >= 2, not just equal to 2.
-----------------------------------------------------------
INT 21 - DOS 3.x - GET EXTENDED ERROR CODE
 AH = 59h
 BX = version code (0000 for DOS 3.0)
Return: AX = extended error code
 BH = class of error
 BL = suggested action code
 CH = locus (where error occurred)
Error codes:
 01 function number invalid
 02 file not found
 03 path not found
 04 too many open files
 05 access denied
 06 invalid handle
 07 memory control block destroyed
 08 insufficient memory
 09 memory block address invalid
 0A environment invalid
 0B format invalid
 0C access code invalid
 0D data invalid
 0F invalid drive
 10 attempted to remove current directory
 11 not same device
 12 no more files
 13 disk write-protected
 14 unknown unit
 15 drive not ready
 16 unknown command
 17 data error (CRC)
 18 bad request structure length
 19 seek error
 1A unknwon media type
 1B sector not found
 1C printer out of paper
 1D write fault
 1E read fault
 1F general failure
 20 sharing violation
 21 lock violation
 22 disk change invalid
 23 FCB unavailable
 24 sharing buffer overflow
 25-31 reserved
 32 Network request not supported (DOS 3.1 + MS Networks)
 33 Remote computer not listening
 34 Duplicate name on network
 35 Network name not found
 36 Network busy
 37 Network device no longer exists
 38 Network BIOS command limit exceeded
 39 Network adapter hardware error
 3A Incorrect response from network
 3B Unexpected network error
 3C Incompatible remote adapter
 3D Print queue full
 3E Queue not full
 3F Not enough space to print file
 40 Network name was deleted
 41 Network: Access denied
 42 Network device type incorrect
 43 Network name not found
 44 Network name limit exceeded
 45 Network BIOS session limit exceeded
 46 Temporarily paused
 47 Network request not accepted
 48 Print/disk redirection paused (DOS 3.1 + MS Networks)
 49-4F reserved
 50 file exists
 51 reserved
 52 cannot make directory
 53 fail on INT 24h
Error Classes:
 01 out of resource
 02 temporary situation
 03 authorization (denied access)
 04 internal
 05 hardware failure
 06 system failure
 07 application program error
 08 not found
 09 bad format
 0A locked
 0B media error
 0C already exists
 0D unknown
Suggested Action:
 01 retry
 02 delayed retry
 03 prompt user
 04 abort after cleanup
 05 immediate abort
 06 ignore
 07 retry after user intervention
Error Locus:
 01 unknown or not appropriate
 02 block device
 03 network related
 04 serial device
 05 memory related
-----------------------------------------------------------
INT 21 - DOS 3.x - CREATE TEMPORARY FILE
 AH = 5Ah
 DS:DX = pointer to ASCIZ directory path name
 CX = file attribute
Return: CF = 1 if error
     AX = Error Code if any
 DS:DX = path name
Note: The file created is not truly "temporary".  It MUST be removed by the
      user.
-----------------------------------------------------------
INT 21 - DOS 3.x - CREATE NEW FILE
 AH = 5Bh
 DS:DX = pointer to ASCIZ directory path name
 CX = file attribute
Return: CF = 1 if error
     AX = Error Code if any
 DS:DX = path name
Note: Unlike function 3Ch, function 5Bh will fail if the file already exists.
-----------------------------------------------------------
INT 21 - DOS 3.x - LOCK/UNLOCK FILE ACCESS
 AH = 5Ch
 AL = 0 if lock
      1 if unlock
 BX = file handle
 CX:DX = starting offset of region to lock
 SI:DI = size of region to lock
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 3.x Internal - GET ADDRESS OF CRITICAL ERROR FLAG
 AX = 5D06h
Return: DS:SI = pointer to critical error flag
 CX = ???
 DX = ???
Note: this call also does a lot of other work in addition to returning the
      pointer
Note: setting CritErr flag allows use of functions 50h/51h from INT 28h under
      DOS 2.x by forcing use of correct stack
-----------------------------------------------------------
INT 21 - DOS 3.x Internal - ???
 AH = 5Dh
 AL = subfunction
      07h: ???
      08h: (used by COMMAND.COM)
      09h: (used by COMMAND.COM)
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - GET MACHINE NAME
 AX = 5E00h
 DS:DX -> buffer for ASCIZ name
Return: CF = 1 if error
     AX = Error Code
 CH = 0 if name not defined
 CL = NETBIOS name number
 DS:DX -> pointer to identifier if CH <> 0
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - SET PRINTER SETUP
 AX = 5E02h
 BX = Redirection list index
 CX = length of setup string <= 64
 DS:SI -> string buffer
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - GET PRINTER SETUP
 AX = 5E03h
 BX = Redirection list index
 ES:DI -> string buffer
Return: CF = 1 if error
     AX = Error Code
 CX = length of setup string <= 64
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - GET REDIRECTION LIST ENTRY
 AX = 5F02h
 BX = Redirection list index
 DS:SI -> 16 char local device name buffer
 ES:DI -> 128 char network name buffer
Return: CF = 1 if error
     AX = Error Code
 BH = Device status flag (BIT 0 = 0 if valid)
 BL = device type (03 if printer, 04 if drive)
 CX = stored parameter value
Note: DX and BP are destroyed by this call!
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - REDIRECT DEVICE
 AX = 5F03h
 BL = device type
  03 = printer device
  04 = file device
 CX = stored parameter value
 DS:SI -> source device name
 ES:DI -> destination ASCIZ network path + ASCIZ password
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - CANCEL REDIRECTION
 AX = 5F04h
 DS:SI -> device name or network path
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 3.x Internal - RESOLVE PATH STRING TO FULLY QUALIFIED PATH STRING
 AH = 60h
 DI:SI = relative path strings
 ES:DI = buffer for fully qualified name
Return: buffer filled with qualified name; may return error code, unknown.
-----------------------------------------------------------
INT 21 - DOS 3.x Internal - UNUSED
 AH = 61h
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS 3.x - GET PSP ADDRESS
 AH = 62h
Return: BX = segment address of PSP
-----------------------------------------------------------
INT 21 - DOS 2.25 only - GET LEAD BYTE TABLE
 AH = 63h
 AL = subfunction
      0 = get system lead byte table
      1 = set/clear interim console flag
  DL = 1/0 to set/clear interim console flag
      2 = get interim console flag
Return: DS:SI -> lead byte table (AL = 0)
 DL = interim console flag (AL = 2)
-----------------------------------------------------------
INT 21 - DOS 3.3 Internal - ???
 AH = 64h
-----------------------------------------------------------
INT 21 - DOS 3.3 - GET EXTENDED COUNTRY INFORMATION
 AH = 65h
 AL = info ID (1 - 6)
 BX = code page (-1=global code page)
 DX = country ID (-1=current country)
 ES:DI = pointer to country information buffer
 CX = size of buffer
Return: AX = error code if carry set, otherwise
 CX = size of country information returned
 ES:DI = pointer to country information:
        1 BYTE info ID
        if info ID <> 1
    1 DWORD pointer to information
        if info ID == 1
    1 WORD size
    1 WORD country ID
    1 WORD code page
   34 BYTE see function 38h
-----------------------------------------------------------
INT 21 - DOS 3.3 - GET/SET GLOBAL CODE PAGE TABLE
 AH = 66h
 AL = 00h get global code page
      Return: AX = error code if carry flag set
       BX = active code page
       DX = system code page
    = 01h set global page
      BX = active code page
   437  US
   860  Portugal
   863  Canada (French)
   865  Norway/Denmark
      DX = system code page (active page at boot time)
      Return: AX = error code if carry flag set
-----------------------------------------------------------
INT 21 - DOS 3.3 - SET HANDLE COUNT
 AH = 67h
 BX = desired number of handles (max 255)
Return: Carry clear if ok
 Carry set if error (and error code in AX)
-----------------------------------------------------------
INT 21 - DOS 3.3 - COMMIT FILE, WRITE ALL BUFFERED DATA TO DISK
 AH = 68h
 BX = file handle
Return: carry flag set on error (and error code in AX)
-----------------------------------------------------------
INT 21 - DoubleDos - INSTALLATION CHECK
 AX = E400h
Return: AL <> 0 if DoubleDos is active
-----------------------------------------------------------
INT 21 - DoubleDos - TURN OFF TASK SWITCHING
 AH = EAh
Return: task switching turned off
-----------------------------------------------------------
INT 21 - DoubleDos - TURN ON TASK SWITCHING
 AH = EBh
Return: task switching turned on
-----------------------------------------------------------
INT 21 - DoubleDos - GET VIRTUAL SCREEN ADDRESS
 AH = ECh
Return: ES = segment of virtual screen
Note: Screen address can change if task-switching is on!!
-----------------------------------------------------------
INT 21 - DoubleDos - GIVE AWAY TIME TO OTHER TASKS
 AH = EEh
 AL = number of 55ms time slices to give away
Return: returns after giving away time slices
-----------------------------------------------------------
INT 21 - CED - INSTALLABLE COMMANDS
 AH = FFh
    AL = 0 add installable command
      BL = mode - bit 0 = 1 callable from DOS prompt
    bit 1 = 1 callable from application
      DS:SI pointer to CR-terminated command name
      ES:DI pointer to FAR routine entry point
    AL = 1 remove installable command
      DS:SI pointer to CR-terminated command name
    AL = 2 reserved, may be used to test for CED installation
Return: CF set on error
     AX = 01h invalid function
   02h command not found (subfunction 1 only)
   08h insufficient memory (subfunction 0 only)
   0Eh bad data (subfunction 0 only)
 AH = 0FFh if CED not installed
-----------------------------------------------------------
INT 22 - DOS - TERMINATE ADDRESS
   FAR (DWORD) address of routine to be executed when program "returns to DOS".
   Should NEVER be called directly.
-----------------------------------------------------------
INT 23 - DOS - CONTROL "C" EXIT ADDRESS
   Automatically called from keyboard scanner when CTRL-C or CTRL-BREAK is
   detected. Normally aborts program and returns to DOS, but may be changed.
-----------------------------------------------------------
INT 24 - DOS - FATAL ERROR HANDLER ADDRESS
   Automatically called upon detection of unrecoverable I/O error.
   Normally points to routine in resident part of COMMAND.COM that prints
   "Abort, Retry, Ignore?" message and takes the reply, but may be overridden
   if desired.
Provides the following values in registers on entry to interrupt handler:
 AH: bit 7 = 0 disk I/O error
    = 1 other error -- if block device, bad FAT
      -- if char device, code in DI
     bit 6  unused
     bit 5 = 1 if Ignore allowed, 0 if not (DOS 3.2 ???)
     bit 4 = 1 if Retry allowed, 0 if not (DOS 3.2 ???)
     bit 3 = 1 if Fail allowed, 0 if not (DOS 3.2+)
     bit 2 \ disk area of error 00 = DOS area  01 = FAT
     bit 1 /   10 = root dir  11 = data area
     bit 0 = 1 if write, 0 if read
 AL = drive number if AH bit 7 = 1, otherwise undefined
 BP:SI = address of device header for which error occurred
     block device if high bit of BP:SI+4 = 1
 low byte of DI:
    00h write-protect error
    01h unknown unit
    02h drive not ready
    03h unknown command
    04h data error (bad CRC)
    05h bad request structure length
    06h seek error
    07h unknown media type
    08h sector not found
    09h printer out of paper
    0Ah write fault
    0Bh read fault
    0Ch general failure
    0Dh (DOS 3.x) sharing violation
    0Eh (DOS 3.x) lock violation
    0Fh (DOS 3.x) invalid disk change
    10h (DOS 3.x) FCB unavailable
    11h (DOS 3.x) sharing buffer overflow
Handler must return
 AL = 00 ignore error
    = 01 retry operation
    = 02 terminate program through INT 22h
    = 03 fail system call in progress (DOS 3.2+)
-----------------------------------------------------------
INT 25 - DOS - ABSOLUTE DISK READ (except COMPAQ DOS 3.31 >32M partition)
 AL = Drive number (0=A, 1=B, etc)
 DS:BX = Disk Transfer Address (buffer)
 CX = Number of sectors to read
 DX = First relative sector to read
Return: CF = 1 if error
     AL = error code issued to INT 24h in low half of DI
     AH = 80h if attachment failed to respond
   40h if seek operation failed
   20h if controller failed
   10h if data error (bad CRC)
   08h if DMA failure
   04h if requested sector not found
   03h if write-protected disk
   02h if bad address mark
   01h if bad command
Note: ORIGINAL FLAGS ON STACK!
-----------------------------------------------------------
INT 25 - COMPAQ DOS 3.31 - ABSOLUTE DISK READ (>32M hard-disk partition)
 AL = Drive number (0=A, 1=B, etc)
 CX = FFFFh
 DS:BX = Packet address
    DWORD sector number
    WORD number of sectors to read
    DWORD transfer address
Return: same as above???
Note: partition is potentially >32M (and requires this form of the call) if
      bit 1 of device attribute word in device driver is set
-----------------------------------------------------------
INT 26 - DOS - ABSOLUTE DISK WRITE (except COMPAQ DOS 3.31 >32M partition)
 AL = Drive number (0=A, 1=B, etc)
 DS:BX = Disk Transfer Address (buffer)
 CX = Number of sectors to write
 DX = First relative sector to write
Return: CF = 1 if error
     AL = error code issued to INT 24h in low half of DI
     AH = same error codes as for INT 25h
Note: ORIGINAL FLAGS ON STACK!
-----------------------------------------------------------
INT 26 - COMPAQ DOS 3.31 - ABSOLUTE DISK WRITE (>32M hard-disk partition)
 AL = Drive number (0=A, 1=B, etc)
 CX = FFFFh
 DS:BX = Packet address
    DWORD sector number
    WORD number of sectors to write
    DWORD transfer address
Return: same as above???
Note: partition is potentially >32M (and requires this form of the call) if
      bit 1 of device attribute word in device driver is set
-----------------------------------------------------------
INT 27 - DOS - TERMINATE BUT STAY RESIDENT
 CS = current program segment
 DX = last program byte + 1
Return: never
-----------------------------------------------------------
INT 28 - DOS Internal - KEYBOARD BUSY LOOP
   This interrupt is called from inside the "get input from keyboard" routine
   in DOS, if and only if it is safe to use INT 21 to access the disk at that
   time.  It is used primarily by the PRINT.COM routines and TSR programs, but
   any number of other routines could be chained to it by saving the original
   vector, and calling it with a FAR call (or just JMPing to it) at the end of
   the new routine.
   The INT 28h handler may invoke any INT 21h function except functions 00h
   through 0Ch (and 50h/51h under DOS 2.xx unless DOS CritErr flag is set).
   Until some program installs its own routine, this interrupt vector simply
   points to an IRET opcode.
-----------------------------------------------------------
INT 29 - DOS Internal - FAST PUTCHAR
   This interrupt is called from the DOS output routines if output is going to
   a device rather than a file, and the device driver's attribute word has
   bit 3 (04h) set to "1".
-----------------------------------------------------------
INT 2A - Microsoft Networks - NETWORK INSTALLATION CHECK
 AH = 00h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2A - Microsoft Networks - CHECK DIRECT I/O
 AX = 0300h
 DS:SI -> ASCIZ disk device name
Return: CF == 0 if allowed
-----------------------------------------------------------
INT 2A - Microsoft Networks - EXECUTE NETBIOS
 AH = 04h
 AL = 0 for error retry, 1 for no retry
 ES:BX -> NCB
Return: AX = 0 for no error
 AH = 1, AL = error code
-----------------------------------------------------------
INT 2A - Microsoft Networks - GET NETWORK RESOURCE INFORMATION
 AX = 0500h
Return: AX = reserved
 BX = number of network names
 CX = number of commands
 DX = number of sessions
-----------------------------------------------------------
INT 2A - NETBIOS 1.10 - NETWORK PRINT-STREAM CONTROL
 AH = 06h
 ???
Return: ???
-----------------------------------------------------------
INT 2A - ???
 AH = 20h
 AL = 01h
 ???
Return: ???
Note: intercepted by DESQview 2.0
-----------------------------------------------------------
INT 2A - Microsoft Networks? - ???
 AH = 82h
Return: ???
Note: Called by the INT 21h function dispatcher in DOS 3.10
-----------------------------------------------------------
INT 2B - Internal routine for MSDOS (IRET)
-----------------------------------------------------------
INT 2C - Internal routine for MSDOS (IRET)
-----------------------------------------------------------
INT 2D - Internal routine for MSDOS (IRET)
-----------------------------------------------------------
INT 2E - DOS Internal - EXECUTE COMMAND
 DS:SI -> counted CR-terminated command string
The top-level command.com executes the command; all registers are destroyed
as in EXEC.
-----------------------------------------------------------
INT 2F notes
 AH identifies which program is to handle the interrupt
    00-7F reserved for DOS
    C0-FF reserved for applications
 AL is the function code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - INSTALLATION CHECK
 AX = 0100h
Return: AL =
     FFh installed
     01h not installed, not OK to install
     00h not installed, OK to install
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - SUBMIT FILE
 AX = 0101h
 DS:DX -> packet of one byte level and DWORD file pointer
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - REMOVE FILE
 AX = 0102h
 DS:DX -> file name (wildcards allowed)
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - REMOVE ALL FILES
 AX = 0103h
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - HOLD QUEUE/GET STATUS
 AX = 0104h
Return: CF = 1 if error
     AX = Error Code
  01h function invalid
  02h file not found
  03h path not found
  04h too many open files
  05h access denied
  08h queue full
  09h spooler busy
  0Ch name too long
  0Fh drive invalid
 DX = Error count
 DS:SI -> print queue (null-string terminated
   list of 64-byte ASCIZ file names)
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - RESTART QUEUE
 AX = 0105h
Return: Flag CF = 1 if error
 AX = Error Code if any
-----------------------------------------------------------
INT 2F - Multiplexor - ASSIGN - INSTALLATION CHECK
 AX = 0600h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - ASSIGN - ???
 AX = 0601h
 ???
Return: ???
-----------------------------------------------------------
INT 2F - Multiplexor - SHARE - ???
 AH = 10h
 AL = ???
Return: ???
-----------------------------------------------------------
INT 2F - Multiplexor - MSDOS Internal - ???
 AH = 10h
 AL =
     0     returns immediately
     nonzero sets flag in DOS, returns AX=0001 and CF=1
Note: this is without SHARE loaded, SHARE takes over this call
-----------------------------------------------------------
INT 2F - Multiplexor - MSDOS Internal - ???
 AH = 11h
 AL =
      0      returns immediately
      nonzero sets flag in DOS, returns AX=0001 and CF=1
Note: identical to AH=10h in PC-DOS 3.10 without SHARE loaded
-----------------------------------------------------------
INT 2F - Multiplexor - MSDOS Internal - ???
 AH = 12h
 ???
Note: also reads value of word on top of stack immediately before invocation
-----------------------------------------------------------
INT 2F - Multiplexor - APPEND - INSTALLATION CHECK
 AX = B700h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - APPEND - ???
 AX = B701h
 ???
-----------------------------------------------------------
INT 2F - Multiplexor - APPEND - VERSION CHECK
 AX = B702h
 ???
-----------------------------------------------------------
INT 2F - Multiplexor - Network - INSTALLATION CHECK
 AX = B800h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - Network - GET CURRENT POST ADDRESS
 AX = B803h
Return: ES:BX = post address
-----------------------------------------------------------
INT 2F - Multiplexor - Network - SET NEW POST ADDRESS
 AX = B804h
 ES:BX = new post address
-----------------------------------------------------------
INT 2F - Multiplexor - Network - VERSION CHECK
 AX = B809h
 ???
-----------------------------------------------------------
INT 30 -> (NOT A VECTOR!) FAR JuMP instruction for CP/M-style calls
INT 31
-----------------------------------------------------------
INT 32 -> not used
-----------------------------------------------------------
INT 33 - MS MOUSE - RESET DRIVER AND READ STATUS
 AX = 0000h
Return: AX = status
     0  hardware/driver not installed
     -1 hardware/driver installed
 BX = number of buttons
     -1 two buttons
     0  other than two
-----------------------------------------------------------
INT 33 - MS MOUSE - SHOW MOUSE CURSOR
 AX = 0001h
-----------------------------------------------------------
INT 33 - MS MOUSE - HIDE MOUSE CURSOR
 AX = 0002h
Note: multiple calls to hide the cursor will require multiple calls to
      function 01h to unhide it.
-----------------------------------------------------------
INT 33 - MS MOUSE - RETURN POSITION AND BUTTON STATUS
 AX = 0003h
Return: BX = button status
    bit 0  left button pressed if 1
    bit 1  right button pressed if 1
 CX = column
 DX = row
-----------------------------------------------------------
INT 33 - MS MOUSE - POSITION MOUSE CURSOR
 AX = 0004h
 CX = column
 DX = row
-----------------------------------------------------------
INT 33 - MS MOUSE - RETURN BUTTON PRESS DATA
 AX = 0005h
 BX = button
     0 left
     1 right
Return: AX = button states
     bit 0 left button pressed if 1
     bit 1 right button pressed if 1
 BX = number of times specified button has been pressed since last call
 CX = column at time specified button was last pressed
 DX = row at time specified button was last pressed
-----------------------------------------------------------
INT 33 - MS MOUSE - RETURN BUTTON RELEASE DATA
 AX = 0006h
 BX = button
     0 left
     1 right
Return: AX = button states
     bit 0 left button pressed if 1
     bit 1 right button pressed if 1
 BX = number of times specified button has been released since last call
 CX = column at time specified button was last released
 DX = row at time specified button was last released
-----------------------------------------------------------
INT 33 - MS MOUSE - DEFINE HORIZONTAL CURSOR RANGE
 AX = 0007h
 CX = minimum column
 DX = maximum column
-----------------------------------------------------------
INT 33 - MS MOUSE - DEFINE VERTICAL CURSOR RANGE
 AX = 0008h
 CX = minimum row
 DX = maximum row
-----------------------------------------------------------
INT 33 - MS MOUSE - DEFINE GRAPHICS CURSOR
 AX = 0009h
 BX = column of cursor hot spot in bitmap
 CX = row of cursor hot spot
 ES:DX = pointer to bitmap
  16 words, each defining the sixteen pixels of a row
  low bit of each word is rightmost in row
-----------------------------------------------------------
INT 33 - MS MOUSE - DEFINE TEXT CURSOR
 AX = 000Ah
 BX = hardware/software text cursor
     0 software
  CX = screen mask
  DX = cursor mask
     1 hardware
  CX = start scan line
  DX = end scan line
Note: when the software cursor is selected, the char/attribute data at the
      current screen position is ANDed with the screen mask and then XORed
      with the cursor mask
-----------------------------------------------------------
INT 33 - MS MOUSE - READ MOTION COUNTERS
 AX = 000Bh
Return: CX = number of mickeys mouse moved horizontally since last call
 DX = number of mickeys mouse moved vertically
Notes: a mickey is the smallest increment the mouse can sense
       positive values indicate up/right
-----------------------------------------------------------
INT 33 - MS MOUSE - DEFINE INTERRUPT SUBROUTINE PARAMETERS
 AX = 000Ch
 CX = call mask
      bit 0 call if mouse moves
      bit 1 call if left button pressed
      bit 2 call if left button released
      bit 3 call if right button pressed
      bit 4 call if right button released
 ES:DX = address of FAR routine
Note: when the subroutine is called, it is passed the following values:
 AX = condition mask (same bit assignments as call mask)
 BX = button state
 CX = cursor column
 DX = cursor row
 DI = horizontal mickey count
 SI = vertical mickey count
-----------------------------------------------------------
INT 33 - MS MOUSE - LIGHT PEN EMULATION ON
 AX = 000Dh
-----------------------------------------------------------
INT 33 - MS MOUSE - LIGHT PEN EMULATION OFF
 AX = 000Eh
-----------------------------------------------------------
INT 33 - MS MOUSE - DEFINE MICKEY/PIXEL RATIO
 AX = 000Fh
 CX = number of mickeys per 8 pixels horizontally
 DX = number of mickeys per 8 pixels vertically
-----------------------------------------------------------
INT 33 - MS MOUSE - DEFINE SCREEN REGION FOR UPDATING
 AX = 0010h
 ???
-----------------------------------------------------------
INT 33 - MS MOUSE - DEFINE DOUBLE-SPEED THRESHOLD
 AX = 0013h
 ???
-----------------------------------------------------------
INT 33 - MS MOUSE - EXCHANGE INTERRUPT SUBROUTINES
 AX = 0014h
 ???
-----------------------------------------------------------
INT 33 - MS MOUSE - RETURN DRIVER STORAGE REQUIREMENTS
 AX = 0015h
Return: BX = size of buffer needed to store driver state
-----------------------------------------------------------
INT 33 - MS MOUSE - SAVE DRIVER STATE
 AX = 0016h
 ES:DX = pointer to buffer
-----------------------------------------------------------
INT 33 - MS MOUSE - RESTORE DRIVER STATE
 AX = 0017h
 ES:DX = pointer to buffer containing saved state
-----------------------------------------------------------
INT 33 - MS MOUSE - DEFINE DISPLAY PAGE NUMBER
 AX = 001Dh
 ???
-----------------------------------------------------------
INT 33 - MS MOUSE - RETURN DISPLAY PAGE NUMBER
 AX = 001Eh
Return: ???
-----------------------------------------------------------
INT 34 - Turbo C/Microsoft languages - Floating Point emulation
-----------------------------------------------------------
INT 35 - Turbo C/Microsoft languages - Floating Point emulation
 This interrupt emulates opcode D9h
-----------------------------------------------------------
INT 36 - Turbo C/Microsoft languages - Floating Point emulation
-----------------------------------------------------------
INT 37 - Turbo C/Microsoft languages - Floating Point emulation
 This interrupt emulates opcode DBh
-----------------------------------------------------------
INT 38 - Turbo C/Microsoft languages - Floating Point emulation
-----------------------------------------------------------
INT 39 - Turbo C/Microsoft languages - Floating Point emulation
 This interrupt emulates opcode DDh
-----------------------------------------------------------
INT 3A - Turbo C/Microsoft languages - Floating Point emulation
 This interrupt emulates opcode DEh
-----------------------------------------------------------
INT 3B - Turbo C/Microsoft languages - Floating Point emulation
-----------------------------------------------------------
INT 3C - Turbo C/Microsoft languages - Floating Point emulation
 This interrupt emulates instructions with an ES segment override
-----------------------------------------------------------
INT 3D - Turbo C/Microsoft languages - Floating Point emulation
 This interrupt emulates a standalone FWAIT instruction
-----------------------------------------------------------
INT 3E - Turbo C/Microsoft languages - Floating Point emulation
-----------------------------------------------------------
INT 3F - Overlay manager interrupt (Microsoft LINK.EXE)
-----------------------------------------------------------
INT 40 -> Relocated (by fixed disk) Floppy Handler (original INT 13h)
-----------------------------------------------------------
INT 41 -> FIXED DISK PARAMETERS (XT,AT,XT2,XT286,PS except ESDI disks)
 dw cylinders
 db heads
 dw 0
 dw write pre-comp
 db 0
 db 0 "control byte"
 db 0, 0, 0
 dw landing zone
 db sectors/track
 db 0
-----------------------------------------------------------
INT 42 -> Relocated (by EGA) Video Handler (original INT 10h) (EGA,VGA,PS)
-----------------------------------------------------------
INT 43 -> EGA Initialization Params (EGA,VGA,PS)
-----------------------------------------------------------
INT 44 -> EGA/PCjr fonts (EGA,VGA,CONV,PS)
-----------------------------------------------------------
INT 45 -> reserved
-----------------------------------------------------------
INT 46 -> Secondary Fixed Disk Params (see INT 41h) (AT,XT286,PS except ESDI)
-----------------------------------------------------------
INT 47 -> reserved
-----------------------------------------------------------
INT 48 -> PCjr Cordless Keyboard Translation
-----------------------------------------------------------
INT 49 -> PCjr Non-keyboard Scan Code Translation Table
-----------------------------------------------------------
INT 4A -> AT User Alarm (AT,CONV,PS)
-----------------------------------------------------------
INT 4B -> reserved
-----------------------------------------------------------
INT 4C -> reserved
-----------------------------------------------------------
INT 4D -> reserved
-----------------------------------------------------------
INT 4E -> reserved
-----------------------------------------------------------
INT 4F -> reserved
-----------------------------------------------------------
INT 50-57 -> IRQ0-IRQ7 relocated by DESQview
-----------------------------------------------------------
INT 58 -> reserved
-----------------------------------------------------------
INT 59 - GSS Computer Graphics Interface (GSS*CGI)
 DS:DX = Pointer to block of 5 array pointers
Return: CF = 0
     AX = return code
 CF = 1
     AX = error code
Note: INT 59 is the means by which GSS*CGI language bindings communicate with
      GSS*CGI device drivers and the GSS*CGI device driver controller. also
      used by the IBM Graphic Development Toolkit
-----------------------------------------------------------
INT 5A - Cluster adapter BIOS entry address
 ???
-----------------------------------------------------------
INT 5B -> reserved
-----------------------------------------------------------
INT 5C - NETBIOS INTERFACE
 ES:BX -> pointer to Network Control Block
Return: AL = Error Code (0 if none)
struct ncb {
 unsigned char ncb_command;
 unsigned char ncb_retcode;
 unsigned char ncb_lsn;
 unsigned char ncb_num;
 char far *ncb_buffer;
 unsigned short ncb_length;
 char ncb_callname[16];
 char ncb_name[16];
 unsigned char ncb_rto;
 unsigned char ncb_sto;
 int (far *ncb_post)();
 unsigned char ncb_lana_num;
 unsigned char ncb_cmd_cplt;
 char ncb_reserve[14];
};
Command codes:
#define NCB_NOWAIT 0x80
#define NCB_RESET 0x32
#define NCB_CANCEL 0x35
#define NCB_ADAPTER_STATUS 0x33
#define NCB_UNLINK 0x70
#define NCB_ADD_NAME 0x30
#define NCB_ADD_GROUP_NAME 0x36
#define NCB_DELETE_NAME 0x31
#define NCB_CALL 0x10
#define NCB_LISTEN 0x11
#define NCB_HANG_UP 0x12
#define NCB_SEND 0x14
#define NCB_CHAIN_SEND 0x17
#define NCB_RECEIVE 0x15
#define NCB_RECEIVE_ANY 0x16
#define NCB_SESSION_STATUS 0x34
#define NCB_SEND_DATAGRAM 0x20
#define NCB_SEND_BROADCAST_DATAGRAM 0x22
#define NCB_RECEIVE_DATAGRAM 0x21
#define NCB_RECEIVE_BROADCAST_DATAGRAM 0x23
struct name {
 char nm_name[16];
 unsigned char nm_num;
 unsigned char nm_status;
};
struct astatus {
 unsigned char as_id[6];
 unsigned char as_jumpers;
 unsigned char as_post;
 unsigned char as_major;
 unsigned char as_minor;
 unsigned short as_interval
 unsigned short as_crcerr;
 unsigned short as_algerr;
 unsigned short as_colerr;
 unsigned short as_abterr;
 unsigned long as_tcount;
 unsigned long as_rcount;
 unsigned short as_retran;
 unsigned short as_xresrc;
 char as_res0[8];
 unsigned short as_ncbfree;
 unsigned short as_ncbmax;
 unsigned short as_ncbx;
 char as_res1[4];
 unsigned short as_sespend;
 unsigned short as_msp;
 unsigned short as_sesmax;
 unsigned short as_bufsize;
 unsigned short as_names;
 struct name as_name[16];
};
Note: Sytek PCnet card uses DMA 3.
-----------------------------------------------------------
INT 5C - TOPS INTERFACE
 ES:BX -> Network Control Block
Note: TOPS card uses DMA 1, 3 or none.
-----------------------------------------------------------
INT 5D -> reserved
-----------------------------------------------------------
INT 5E -> reserved
-----------------------------------------------------------
INT 5F -> reserved
-----------------------------------------------------------
INT 60 -> reserved for user interrupt
-----------------------------------------------------------
INT 61 -> reserved for user interrupt
-----------------------------------------------------------
INT 62 -> reserved for user interrupt
-----------------------------------------------------------
INT 63 -> reserved for user interrupt
-----------------------------------------------------------
INT 64 -> reserved for user interrupt
-----------------------------------------------------------
INT 65 -> reserved for user interrupt
-----------------------------------------------------------
INT 66 -> reserved for user interrupt
-----------------------------------------------------------
INT 67 - LIM EMS - GET MANAGER STATUS
 AH = 40h
Return: AH = status
     00h successful
     80h internal error
     81h hardware malfunction
     84h undefined function requested by application
Note: this call can be used only after establishing that the EMS driver
      is in fact present
-----------------------------------------------------------
INT 67 - LIM EMS - GET PAGE FRAME SEGMENT
 AH = 41h
Return: AH = 00h function successful
     BX = segment of page frame
 AH = error code (see AH=40h above)
-----------------------------------------------------------
INT 67 - LIM EMS - GET NUMBER OF PAGES
 AH = 42h
Return: AH = 00h function successful
     BX = number of unallocated pages
     DX = total number of pages
 AH = error code (see AH=40h above)
-----------------------------------------------------------
INT 67 - LIM EMS - GET HANDLE AND ALLOCATE MEMORY
 AH = 43h
 BX = number of logical pages to allocate
Return: AH = status
     00h function successful
  DX = handle
     80h internal error
     81h hardware malfunction
     84h undefined function requested
     85h no more handles available
     87h more pages requested than physically exist
     88h more pages requested than currently available
     89h zero pages requested
-----------------------------------------------------------
INT 67 - LIM EMS - MAP MEMORY
 AH = 44h
 AL = physical page number (0-3)
 BX = logical page number
 DX = handle
Return: AH = status
     00h function successful
     80h internal error
     81h hardware malfunction
     83h invalid handle
     84h undefined function requested
     8Ah invalid logical page number
     8Bh illegal physical-page number
-----------------------------------------------------------
INT 67 - LIM EMS - RELEASE HANDLE AND MEMORY
 AH = 45h
 DX = EMM handle
Return: AH = status
     00h successful
     80h internal error
     81h hardware malfunction
     83h invalid handle
     84h undefined function requested
     86h error in save or restore of mapping context
-----------------------------------------------------------
INT 67 - LIM EMS - GET EMM VERSION
 AH = 46h
Return: AH = status
     00h successful
  AL = EMM version number
     80h internal error
     81h hardware malfunction
     84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS - SAVE MAPPING CONTEXT
 AH = 47h
 DX = handle
Return: AH = status
     00h successful
     80h internal error
     81h hardware malfunction
     83h invalid handle
     84h undefined function requested
     8Ch page-mapping hardware state save area is full
     8Dh save of mapping context failed
-----------------------------------------------------------
INT 67 - LIM EMS - RESTORE MAPPING CONTEXT
 AH = 48h
 DX = handle
Return: AH = status
     00h successful
     80h internal error
     81h hardware malfunction
     83h invalid handle
     84h undefined function requested
     8Eh restore of mapping context failed
-----------------------------------------------------------
INT 67 - LIM EMS - reserved
 AH = 49h
Note: defined in EMS 3.0, but undocumented in EMS 3.2
-----------------------------------------------------------
INT 67 - LIM EMS - reserved
 AH = 4Ah
Note: defined in EMS 3.0, but undocumented in EMS 3.2
-----------------------------------------------------------
INT 67 - LIM EMS - GET NUMBER OF EMM HANDLES
 AH = 4Bh
Return: AH = status
     00h successful
  BX = number of EMM handles
     80h internal error
     81h hardware malfunction
     83h invalid handle
     84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS - GET PAGES OWNED BY HANDLE
 AH = 4Ch
 DX = EMM handle
Return: AH = status
     00h successful
  BX = number of logical pages
     80h internal error
     81h hardware malfunction
     83h invalid handle
     84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS - GET PAGES FOR ALL HANDLES
 AH = 4Dh
 ES:DI = pointer to array to receive information
Return: AH = status
     00h successful
  BX = number of active EMM handles
  array filled with 2-word entries, consisting of a handle
    and the number of pages allocated to that handle
     80h internal error
     81h hardware malfunction
     84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS - GET OR SET PAGE MAP
 AH = 4Eh
 AL = 00h if getting mapping registers
      01h if setting mapping registers
      02h if getting and setting mapping registers at once
      03h if getting size of page-mapping array
 DS:SI = pointer to array holding information (AL=01/02)
 ES:DI = pointer to array to receive information (AL=00/02)
Return: AH = status
     00h successful
  AL = bytes in page-mapping array (subfunction 03h only)
  array pointed to by ES:DI receives mapping info (AL=00/02)
     80h internal error
     81h hardware malfunction
     84h undefined function requested
     8Fh undefined subfunction parameter
     A3h contents of source array corrupted (EMS 4.0?)
Note: this function was designed to be used by multitasking operating systems
      and should not ordinarily be used by appplication software.
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - GET/SET PARTIAL PAGE MAP
 AH = 4Fh
 AL = subfunction
     00h get partial page map
        DS:SI = pointer to structure containing list of segments whose
         mapping contexts are to be saved
        ES:DI = pointer to array to receive page map
     01h set partial page map
        DS:SI = pointer to structure containing saved partial page map
     02h get size of partial page map
        BX = number of mappable segments in the partial map to be saved
Return: AH = status
     00h successful
     80h internal error
     81h hardware malfunction
     84h undefined function requested
     8Bh one of specified segments is not mappable
     8Fh undefined subfunction parameter
     A3h contents of partial page map corrupted or count of mappable
  segments exceeds total number of mappable segments in system
 AL = size of partial page map for subfunction 02h
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - MAP/UNMAP MULTIPLE HANDLE PAGES
 AH = 50h
 AL = subfunction
     00h
     01h
 DX = handle
 CX = number of entries in array
 DS:SI = pointer to mapping array
Return: AH = status
     00h successful
     80h internal error
     81h hardware malfunction
     83h invalid handle
     84h undefined function requested
     8Ah one or more logical pages are invalid
     8Bh one or more physical pages are invalid
     8Fh invalid subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - REALLOCATE PAGES
 AH = 51h
 DX = handle
 BX = number of pages to be allocated to handle
Return: BX = actual number of pages allocated to handle
 AH = status
     00h successful
     80h internal error
     81h hardware malfunction
     83h invalid handle
     84h undefined function requested
     87h more pages requested than present in system
     88h more pages requested than currently available
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - GET/SET HANDLE ATTRIBUTES
 AH = 52h
 AL = subfunction
     00h get handle attributes
     01h set handle attributes
        BL = new attribute (see returned AL)
     02h get attribute capability
 DX = handle
Return: AL = attribute (for subfunction 00h)
     00h handle is volatile
     01h handle is nonvolatile
 AL = attribute capability (for subfunction 02h)
     00h only volatile handles supported
     01h both volatile and non-volatile supported
 AH = status
     00h successful
     80h internal error
     81h hardware malfunction
     83h invalid handle
     84h undefined function requested
     8Fh undefined subfunction
     90h undefined attribute type
     91h feature not supported
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - GET/SET HANDLE NAME
 AH = 53h
 AL = subfunction
     00h get handle name
        ES:DI = pointer to 8-byte handle name array
     01h set handle name
        DS:SI = pointer to 8-byte handle name
 DX = handle
Return: AH = status
     00h successful
     80h internal error
     81h hardware malfunction
     83h invalid handle
     84h undefined function requested
     8Fh undefined subfunction
     A1h duplicate handle name
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - GET HANDLE DIRECTORY
 AH = 54h
 AL = subfunction
     00h get handle directory
        ES:DI = pointer to buffer for handle directory
     01h search for named handle
        DS:SI = pointer to 8-byte name
     02h get total number of handles
Return: AL = number of entries in handle directory (subfunction 00h)
 DX = value of named handle (subfunction 01h)
 BX = total number of handles (subfunction 02h)
 AH = status
     00h successful
     80h internal error
     81h hardware malfunction
     84h undefined function requested
     8Fh undefined subfunction
     A0h no such handle name
     A1h a handle found had no name
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND JUMP
 AH = 55h
 AL = subfunction
     00h physical page numbers provided by caller
     01h segment addresses provided by caller
 DX = handle
 DS:SI = pointer to structure containing map and jump address
Return: (at target address unless error)
 AH = status
     00h successful
     80h internal error
     81h hardware failure
     83h invalid handle
     84h undefined function requested
     8Ah invalid logical page number encountered
     8Bh invalid physical page number encountered
     8Fh invalid subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND CALL
 AH = 56h
 AL = subfunction
     00h physical page numbers provided by caller
        DX = handle
        DS:SI = pointer to structure containing page map and call address
     01h segment addresses provided by caller
        DX = handle
        DS:SI = pointer to structure containing page map and call address
     02h get page map stack space required
Return: (if successful, the target address is called.  Use a RETF to return and
  restore mapping context)
 BX = stack space required (subfunction 02h)
 AH = status
     00h successful
     80h internal error
     81h hardware failure
     83h invalid handle
     84h undefined function requested
     8Ah invalid logical page number encountered
     8Bh invalid physical page number encountered
     8Fh undefined subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - MOVE/EXCHANGE MEMORY REGION
 AH = 57h
 AL = subfunction
     00h move memory region
     01h exchange memory region
 DS:SI = pointer to structure describing source and destination
Return: AH = status
     00h successful
     80h internal error
     81h hardware failure
     83h invalid handle
     84h undefined function requested
     8Ah invalid logical page number encountered
     8Fh undefined subfunction
     92h successful, but a portion of the source region has been
  overwritten
     93h length of source or destination region exceeds length of region
  allocated to either source or destination handle
     94h conventional and expanded memory regions overlap
     95h offset within logical page exceeds size of logical page
     96h region length exceeds 1M
     97h source and destination EMS regions have same handle and overlap
     98h memory source or destination type undefined
     A2h attempted to wrap around 1M conventional address space
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - GET MAPPABLE PHYSICAL ADDRESS ARRAY
 AH = 58h
 AL = subfunction
     00h get mappable physical address array
        ES:DI = pointer to buffer to be filled with array
     01h get number of entries in m.p.a. array
Return: CX = number of entries in array
 AH = status
     00h successful
     80h internal error
     81h hardware failure
     84h undefined function requested
     8Fh undefined subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - GET EXPANDED MEMORY HARDWARE INFORMATION
 AH = 59h
 AL = subfunction
     00h get hardware configuration array
        ES:DI = pointer to buffer to be filled with array
     01h get unallocated raw page count
Return: BX = unallocated raw pages (subfunction 01h)
 DX = total raw pages (subfunction 01h)
 AH = status
     00h successful
     80h internal error
     81h hardware failure
     84h undefined function requested
     8Fh undefined subfunction
     A4h access denied by operating system
Note: subfunction 00h is for use by operating systems only, and can be
      enabled or disabled at any time by the operating system
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - ALLOCATE STANDARD/RAW PAGES
 AH = 5Ah
 AL = subfunction
     00h allocate standard pages
     01h allocate raw pages
 BX = number of pages to allocate
Return: DX = handle
 AH = status
     00h successful
     80h internal error
     81h hardware failure
     84h undefined function requested
     85h no more handles available
     87h insufficient memory pages in system
     88h insufficient memory pages available
     8Fh undefined subfunction
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET
 AH = 5Bh
 AL = subfunction
     00h get alternate map register set
     01h set alternate map register set
        BL = new alternate map register set number
        ES:DI = pointer to map register context save area if BL=0
     02h get alternate map save array size
     03h allocate alternate map register set
     04h deallocate alternate map register set
        BL = number of alternate map register set
Return: BL = current active alternate map register set number if nonzero (AL=0)
 ES:DI = pointer to a map register context save area if BL=0 (AL=0)
 DX = array size in bytes (subfunction 02h)
 BL = number of alternate map register set; zero if not supported (AL=3)
 AH = status
     00h successful
     80h internal error
     81h hardware malfunction
     84h undefined function requested
     8Fh undefined subfunction
     9Ah specified alternate map register set not supported
     9Bh all alternate map register sets currently allocated
     9Ch alternate map register sets not supported
     9Dh undefined or unallocated alternate map register set
     A3h source array corrupted
     A4h operating system denied access
Note: this function is for use by operating systems only, and can be
      enabled or disabled at any time by the operating system
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET - DMA REGISTERS
 AH = 5Bh
 AL = subfunction
     05h allocate DMA register set
     06h enable DMA on alternate map register set
        BL = DMA register set number
        DL = DMA channel number
     07h disable DMA on alternate map register set
        BL = DMA register set number
     08h deallocate DMA register set
        BL = DMA register set number
Return: BL = DMA register set number; zero if not supported (subfunction 05h)
 AH = status
     00h successful
     80h internal error
     81h hardware malfunction
     84h undefined function requested
     8Fh undefined subfunction
     9Ah specified DMA register set not supported
     9Bh all DMA register sets currently allocated
     9Ch alternate DMA sets not supported
     9Dh undefined or unallocated DMA register set
     9Eh dedicated DMA channels not supported
     9Fh specified dedicated DMA channel not supported
     A3h source array corrupted
     A4h operating system denied access
Note: this function is for use by operating systems only, and can be
      enabled or disabled at any time by the operating system
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - PREPARE EXPANDED MEMORY HARDWARE FOR WARM BOOT
 AH = 5Ch
Return: AH = status
     00h successful
     80h internal error
     81h hardware malfunction
     84h undefined function requested
-----------------------------------------------------------
INT 67 - LIM EMS 4.0 - ENABLE/DISABLE OS FUNCTION SET FUNCTIONS
 AH = 5Dh
 AL = subfunction
     00h enable OS Function Set
     01h disable OS Function Set
     02h return access key (resets memory manager, returns access key at
  next invocation)
 BX,CX = access key returned by first invocation
Return: BX,CX = access key, returned only on first invocation of function
 AH = status
     00h successful
     80h internal error
     81h hardware malfunction
     84h undefined function requested
     8Fh undefined subfunction
     A4h operating system denied access
-----------------------------------------------------------
INT 67 - LIM EMS ??? - GET PHYSICAL WINDOW ARRAY
 AH = 60h
 ???
Return: ???
-----------------------------------------------------------
INT 68 -> unused
-----------------------------------------------------------
INT 69 -> unused
-----------------------------------------------------------
INT 6A -> unused
-----------------------------------------------------------
INT 6B -> unused
-----------------------------------------------------------
INT 6C - system resume vector (CONVERTIBLE)
       - DOS 3.2 Realtime Clock update
-----------------------------------------------------------
INT 6D -> unused
-----------------------------------------------------------
INT 6E -> unused
-----------------------------------------------------------
INT 6F -> unused
-----------------------------------------------------------
INT 70-77 -> AT/XT286/PS50+ VECTORED HARDWARE LINES
 IRQ8 real-time clock
 IRQ9 LAN adapter 1 (rerouted to INT 0Ah by BIOS)
 IRQ10 reserved
 IRQ11 reserved
 IRQ12 (PS50+) mouse interrupt
 IRQ13 80287 error (rerouted to INT 2 by BIOS)
 IRQ14 fixed disk
 IRQ15 reserved
-----------------------------------------------------------
INT 78 -> not used
-----------------------------------------------------------
INT 79 -> not used
-----------------------------------------------------------
INT 7A -> not used
-----------------------------------------------------------
INT 7B -> not used
-----------------------------------------------------------
INT 7C -> not used
-----------------------------------------------------------
INT 7D -> not used
-----------------------------------------------------------
INT 7E -> not used
-----------------------------------------------------------
INT 7F -> not used
-----------------------------------------------------------
INT 80 -> reserved for BASIC
-----------------------------------------------------------
INT 81 -> reserved for BASIC
-----------------------------------------------------------
INT 82 -> reserved for BASIC
-----------------------------------------------------------
INT 83 -> reserved for BASIC
-----------------------------------------------------------
INT 84 -> reserved for BASIC
-----------------------------------------------------------
INT 85 -> reserved for BASIC
-----------------------------------------------------------
INT 86 -> Relocated (by NETBIOS) INT 18
-----------------------------------------------------------
INT 86-F0 -> used by BASIC while in interpreter
-----------------------------------------------------------
INT E0 - CP/M-86 function calls
-----------------------------------------------------------
INT E4 - Logitech Modula v2.0 - MonitorEntry
 AX = 0005h
 BX = priority
-----------------------------------------------------------
INT E4 - Logitech Modula v2.0 - MonitorExit
 AX = 0006h
-----------------------------------------------------------
INT F1 - reserved for user interrupt
-----------------------------------------------------------
INT F2 - reserved for user interrupt
-----------------------------------------------------------
INT F3 - reserved for user interrupt
-----------------------------------------------------------
INT F4 - reserved for user interrupt
-----------------------------------------------------------
INT F5 - reserved for user interrupt
-----------------------------------------------------------
INT F6 - reserved for user interrupt
-----------------------------------------------------------
INT F7 - reserved for user interrupt
-----------------------------------------------------------
INT F8 - 10 ms INTERVAL TIMER (TANDY???)
-----------------------------------------------------------
INT F9 - reserved for user interrupt
-----------------------------------------------------------
INT FA - USART READY (RS-232C) (TANDY???)
-----------------------------------------------------------
INT FB - USART Rx READY (keyboard) (TANDY???)
-----------------------------------------------------------
INT FC - reserved for user interrupt
-----------------------------------------------------------
INT FD - reserved for user interrupt
-----------------------------------------------------------
INT FE - destroyed by return from protected mode on PC/AT
-----------------------------------------------------------
INT FF - destroyed by return from protected mode on PC/AT
-----------------------------------------------------------
-----------------------------------------------------------
INT 00 - DIVIDE ERROR (internal interrupt)
   Automatically called at end of DIV or IDIV operation that results in error.
   Normally set by DOS to display an error message and abort the program.
-----------------------------------------------------------
INT 01 - SINGLE-STEP (internal interrupt)
   Generated at end of each machine instruction if TF bit in FLAGS is set.
   This is what makes the T command of DEBUG work for single-stepping. It is
   not generated after MOV to segment register or POP of segment register
   (unless you have a very early 8088 with a microcode bug).
-----------------------------------------------------------
INT 02 - NMI (NON-MASKABLE INTERRUPT)
   Generated by NMI signal in hardware.  This signal has various uses:
   Parity error: all except Jr and CONV
   Coprocessor interrupt: all except Jr and CONV
   Keyboard interrupt: Jr, CONV
   I/O channel check: CONV, PS50+
   Disk-controller power-on request: CONV
   System suspend: CONV
   Real-time clock: CONV
   System watch-dog timer, time-out interrupt: PS50+
   DMA timer time-out interrupt: PS50+
-----------------------------------------------------------
INT 03 - 1-BYTE INTERRUPT (internal interrupt)
   Generated by opcode CCh. Similar to 8080's RST instruction. Generally
   used to set breakpoints for DEBUG.
   Also used by Turbo Pascal versions 1,2,3 when {$U+} specified
-----------------------------------------------------------
INT 04 - OVERFLOW (internal interrupt)
   Generated by INTO instruction if OF flag is set.  If flag is not set, INTO
   is effectively a NOP.  Used to trap any arithmetic errors when program is
   ready to handle them rather than immediately when they occur.
-----------------------------------------------------------
INT 05 - PRINT-SCREEN KEY
   Automatically called by keyboard scan when print-screen key is pressed.
   Normally executes routine to print the screen, but may call any routine that
   can safely be executed from inside the keyboard scanner.  Status and result
   byte for default handler is at address 0050:0000.
-----------------------------------------------------------
INT 05 - BOUND CHECK FAILED (80186/80286 internal interrupt)
   Generated by BOUND instruction when the value to be tested is less than the
   indicated lower bound or greater than the indicated upper bound.
-----------------------------------------------------------
INT 06 - UNDEFINED OPCODE (80286 internal interrupt)
-----------------------------------------------------------
INT 07 - NO MATH UNIT AVAILABLE (80286 protected-mode internal)
-----------------------------------------------------------
INT 08 thru 0F - VECTORED HARDWARE LINES
   In IBM, these 8 interrupts are generated in response to IRQ 0 through
   IRQ 7 (if enabled via port 21h).
         [Tandy 1000] [Adapters]
     IRQ0 - timer interrupt
     IRQ1 - keyboard interrupt
     IRQ2 - EGA vertical retrace     [fixed disk] [TOPS&PCnet default]
     IRQ3 - serial port 2 (com2:)   [TOPS&PCnet alternate]
     IRQ4 - serial port 1 (com1:)
     IRQ5 - fixed disk (PC/AT: LPT2) [60 Hz ram refresh]
     IRQ6 - diskette interrupt
     IRQ7 - PPI interrupt (lpt1:, lpt2:)
-----------------------------------------------------------
INT 08 - DOUBLE FAULT (80286 protected-mode internal)
   Called when multiple exceptions occur on one instruction, or an exception
   occurs in an exception handler.  If an exception occurs in the double fault
   handler, the CPU goes into SHUTDOWN mode (which circuitry in the PC/AT
   converts to a reset).
-----------------------------------------------------------
INT 09 - MATH UNIT PROTECTION FAULT (80286 protected-mode internal)
-----------------------------------------------------------
INT 0A - INVALID TASK STATE SEGMENT (80286 protected-mode internal)
-----------------------------------------------------------
INT 0B - NOT PRESENT (80286 protected-mode internal)
   Generated when loading a segment register if the segment descriptor
   indicates that the segment is not currently in memory.
-----------------------------------------------------------
INT 0C - STACK FAULT (80286 protected-mode internal)
   Generated on stack overflow/underflow.  Note that the 80286 will shut down
   in real mode if SP=1 before a push.
-----------------------------------------------------------
INT 0D - GENERAL PROTECTION VIOLATION (80286 internal interrupt)
   Called in real mode when an instruction attempts to access a word operand
   located at offset FFFFh
-----------------------------------------------------------
INT 0E - PAGE FAULT (80386 native-mode internal interrupt)
-----------------------------------------------------------
INT 10 - VIDEO - SET VIDEO MODE
 AH = 00h
 AL = mode (graphics mode if graphics resolution listed)
   text  pixel graphic color disp scrn  system
   resol box  resoltn    page addr
    00h = 40x25 8x8      B&W     8 B800 CGA
    01h = 40x25 8x8      16      8 B800 CGA
    02h = 80x25 8x8      B&W     4 B800 CGA
    03h = 80x25 8x8      16      4 B800 CGA
    04h = 40x25 8x8  320x200 4      1 B800 CGA
    05h = 40x25 8x8  320x200 4 gray  1 B800 CGA
    06h = 80x25 8x8  640x200 B&W     1 B800 CGA
    07h = 80x25 8x14      mono    1 B000 MDA/Hercules
    08h =      160x200 16     ??? B800 PCjr/Tandy 1000
    09h =      320x200 16     ??? B800 PCjr/Tandy 1000
    0Ah =      640x200 4     ??? B800 PCjr/Tandy 1000
    0Bh = reserved (used internally by EGA BIOS)
    0Ch = reserved (used internally by EGA BIOS)
    0Dh =      320x200 16     ??? A000 EGA/VGA
    0Eh =      640x200 16     ??? A000 EGA/VGA
    0Fh =      640x350 mono   ??? A000 EGA/VGA
    10h =      640x350 4or16  ??? A000 EGA/VGA
    11h =      640x480 mono   ??? A000 VGA/MCGA
    12h =      640x480 16     ??? A000 VGA
    13h =      320x200 256    ??? A000 VGA/MCGA
    18h = 132x44 8x8      mono      Tseng Labs EVA
    19h = 132x25 8x14      mono      Tseng Labs EVA
    1Ah = 132x28 8x13      mono      Tseng Labs EVA
    22h = 132x44 8x8      ???      Tseng, Ahead
    23h = 132x25 6x14      ???      Tseng Labs EVA
        = 132x25 8x14      ???      Ahead Systems EGA2001
    24h = 132x28 6x13      ???      Tseng Labs EVA
    25h = 80x60 8x8  640x480 ???      Tseng Labs EVA
    26h = 80x60 8x8      ???      Tseng Labs EVA
        = 80x60 8x8  640x480 ???      Ahead Systems EGA2001
    30h =      ???x??? ???      AT&T 6300
    40h =             640x400   2        B800 AT&T 6300
    48h = 80x50       640x400   2        B800 AT&T 6300
    50h = 132x25 9x14      mono      Ahead Systems EGA2001
        = 80x30 8x16 640x480 ???      Paradise EGA-480
    51h = 80x30 8x16      ???      Paradise EGA-480
    52h = 132x44 9x8      mono      Ahead Systems EGA2001
    54h = 132x43 8x8      ???      Paradise EGA-480
    55h = 132x25 8x14      ???      Paradise EGA-480
    56h = 132x43 8x8      3???   2 B000 NSI Smart EGA+
    57h = 132x25 8x14      3???   4 B000 NSI Smart EGA+
    60h = 80x???      ???x400 ???      Corona/Cordata BIOS v4.10+
    61h =      ???x400 ???      Corona/Cordata BIOS v4.10+
    71h = 100x35 8x16 800x600 16of64 A000 NSI Smart EGA+
    74h =      640x400 ???      Toshiba 3100
    D0h =      640x400   2      DEC VAXmate AT&T mode
    ??? =      640x225 ???      Z-100
    ??? =      640x400 ???      Z-100
-----------------------------------------------------------
INT 10 - VIDEO - SET CURSOR CHARACTERISTICS
 AH = 01h
 CH bits 0-4 = start line for cursor in character cell
    bits 5-6 = blink attribute
       (00=normal, 01=invisible, 10=slow, 11=fast)
 CL bits 0-4 = end line for cursor in char. cell
-----------------------------------------------------------
INT 10 - VIDEO - SET CURSOR POSITION
 AH = 02h
 DH,DL = row, column (0,0 = upper left)
 BH = page number
     0 in graphics modes
     0-3 in modes 2&3
     0-7 in modes 0&1
-----------------------------------------------------------
INT 10 - VIDEO - READ CURSOR POSITION
 AH = 03h
 BH = page number
     0 in graphics modes
     0-3 in modes 2&3
     0-7 in modes 0&1
Return: DH,DL = row,column
 CH = cursor start line
 CL = cursor end line
-----------------------------------------------------------
INT 10 - VIDEO - READ LIGHT PEN POSITION (all but PS)
 AH = 04h
Return: AH = 0: light pen switch not activated
 AH = 1: light pen values in registers
     DH,DL = row,column of current position
     CH = raster line (0-199) (EGA) old graphics modes
     CX = (EGA) raster line (0-nnn) new graphics modes
     BX = pixel column (0-319 or 0-639)
-----------------------------------------------------------
INT 10 - VIDEO - SELECT DISPLAY PAGE
 AH = 05h
 AL =
     0-7: new page value for modes 0 & 1
     0-3: new page value for modes 2 & 3
     80h: read CRT/CPU page registers [PCjr only]
     81h: set CPU page register to value in BL [PCjr only]
     82h: set CRT page register to value in BH [PCjr only]
     83h: set both display registers [PCjr only]
     {Corona/Cordata BIOS v4.10+}
     0: set address of graphics bitmap buffer (video modes 60h,61h)
        BX = segment of buffer
     0Fh: get address of graphics bitmap buffer (video modes 60h,61h)
Return: BH = CRT page register (if AL >= 80h)
 BL = CPU page register (if AL >= 80h)
 DX = segment of graphics bitmap buffer (video modes 60h,61h; AL=0Fh)
-----------------------------------------------------------
INT 10 - VIDEO - SCROLL PAGE UP
 AH = 06h
 AL = number of lines to scroll window (0 = blank whole window)
 BH = attributes to be used on blanked lines
 CH,CL = row,column of upper left corner of window to scroll
 DH,DL = row,column of lower right corner of window
-----------------------------------------------------------
INT 10 - VIDEO - SCROLL PAGE DOWN
 AH = 07h
 AL = number of lines to scroll window (0 = blank whole window)
 BH = attributes to be used on blanked lines
 CH,CL = row,column of upper left corner of window to scroll
 DH,DL = row,column of lower right corner of window
-----------------------------------------------------------
INT 10 - VIDEO - READ ATTRIBUTES/CHARACTER AT CURSOR POSITION
 AH = 08h
 BH = display page
Return: AL = character
 AH = attribute of character (alpha modes)
-----------------------------------------------------------
INT 10 - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POS
 AH = 09h
 AL = character
 BH = display page - alpha modes
 BL = attributes of char (alpha modes) or color (graphics modes)
      if bit 7 == 1 in graphics mode, character is xor'ed onto screen
 CX = number of times to write character
-----------------------------------------------------------
INT 10 - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POS
 AH = 0Ah
 AL = character
 BH = display page - alpha mode
 BL = color of character (graphics mode)
 CX = number of times to write character
      (EGA) in graphics modes, replication count in CX works correctly
      only if all character written are contains on the same row
-----------------------------------------------------------
INT 10 - VIDEO - SET COLOR PALETTE
 AH = 0Bh
 BH = 0
     BL = border color (0-15) (text modes)
   border color and background color (graphics modes)
     (EGA)
     BL = border color (0-15) and high-intensity background color
    (16-31??? maybe should be high nybble?)
 BH = 1
     BL = palette (0/1)
-----------------------------------------------------------
INT 10 - VIDEO - WRITE DOT ON SCREEN
 AH = 0Ch
 AL = color of dot (0/1 in mode 6, 0-3 in modes 4 and 5)
      if bit 7 set, new color will be XORed with current pixel
 DX = row (0 - 199)
 CX = column (0 - 319 in modes 4/5/13, 0 - 639 in modes 6/14/15/16)
Note: only valid in graphics modes
-----------------------------------------------------------
INT 10 - VIDEO - READ DOT ON SCREEN
 AH = 0Dh
 CX = column (0 - 319 or 639)
 DX = row (0 - 199)
Return: AL = color read
-----------------------------------------------------------
INT 10 - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
 AH = 0Eh
 AL = character
 BH = display page (alpha modes)
 BL = foreground color (graphics modes)
-----------------------------------------------------------
INT 10 - VIDEO - GET CURRENT VIDEO MODE
 AH = 0Fh
Return: AH = number of columns on screen
 AL = current video mode (see INT 10h/AH=00h)
 BH = current active display page
-----------------------------------------------------------
INT 10 - VIDEO - SET PALETTE REGISTERS (Jr, PS, TANDY 1000, EGA, VGA)
 AH = 10h
 AL = 0: set palette register
  BL = palette register to set
  BH = color value to store
 AL = 1: set border color register
  BH = color value to store
 AL = 2: set all palette registers and overscan
  ES:DX = pointer to 17-byte list
   bytes 0-15 = values for palette regs. 0-15
   byte 16 = value for border register
 (EGA/VGA/MCGA)
 AL = 3: toggle intensity/blinking bit
  BL = 0: enable intensity
  BL = 1: enable blink
 (VGA/MCGA)
 AL = 07h: read individual palette register (VGA only)
  BL = palette register number
  Return: BH = palette register value
 AL = 08h: read overscan (border color) register (VGA only)
  Return: BH = value
 AL = 09h: read all palette registers and overscan register (VGA only)
  ES:DX = buffer address (17 bytes)
 AL = 10h: set individual DAC register
  BX = register number
  CH = new value for green (0-63)
  CL = new value for blue (0-63)
  DH = new value for red (0-63)
 AL = 12h: set block of DAC registers
  BX = starting color register
  CX = number of registers to set
  ES:DX = Table of 3*CX bytes where each 3 byte
  group represents one byte each of red, green and blue (0-63)
 AL = 13h: select video DAC color page (VGA only)
  BL = 00h Select paging mode
   BH = 00h Select 4 blocks of 64
   BH = 01h Select 16 blocks of 16
  BL = 01h Select Page
   BH = page number (00h to 03h) or (00h to 0Fh)
 AL = 15h: read individual DAC register
  BL = palette register number
  Return: DH = red value
   CH = green value
   CL = blue value
 AL = 17h: read block of DAC registers
  BX = starting palette register
  CX = number of palette registers to read
  ES:DX = buffer (3 * CX bytes in size)
  Return: CX number of red, green and blue triples
  in buffer
 AL = 18h *UNDOCUMENTED* set PEL mask
  BL = new PEL value
 AL = 19h *UNDOCUMENTED* read PEL mask
  BL = value read
 AL = 1Ah: read video DAC color-page state (VGA only)
  Return: BL = paging mode
   BH = current page
 AL = 1Bh: perform gray-scale summing
  BX = starting palette register
  CX = number of registers to convert
-----------------------------------------------------------
INT 10 - VIDEO - CHARACTER GENERATOR FUNCTIONS (PS, EGA, VGA)
 AH = 11h
 The following functions will cause a mode set, completely resetting
 the video environment, but without clearing the video buffer
 AL = 00h, 10h: load user-specified patterns
     ES:BP = pointer to user table
     CX   = count of patterns to store
     DX   = character offset into map 2 block
     BL   = block to load in map 2
     BH   = number of bytes per character pattern
 AL = 01h, 11h: load ROM monochrome patterns (8 by 14)
     BL   = block to load
 AL = 02h, 12h: load ROM 8 by 8 double-dot patterns
     BL   = block to load
 AL = 03h: set block specifier
     BL   = block specifier
 AL = 04h, 14h: load ROM 8x16 character set (VGA)
 The routines called with AL=1xh are designed to be called only
 immediately after a mode set and are similar to the routines called
 with AL=0xh, except that:
       Page 0 must be active.
       Bytes/character is recalculated.
       Max character rows is recalculated.
       CRT buffer length is recalculated.
       CRTC registers are reprogrammed as follows:
       R09 = bytes/char-1 ; max scan line (mode 7 only)
       R0A = bytes/char-2 ; cursor start
       R0B = 0  ; cursor end
       R12 = ((rows+1)*(bytes/char))-1 ; vertical display end
       R14 = bytes/char ; underline loc
      (*** BUG: should be 1 less ***)
 The following functions are meant to be called only after a mode set:
 AL = 20h: user 8 by 8 graphics characters (INT 1Fh)
     ES:BP = pointer to user table
 AL = 21h: user graphics characters
     ES:BP = pointer to user table
     CX   = bytes per character
     BL   = row specifier
     0: user set
        DL = number of rows
     1: 14 rows
     2: 25 rows
     3: 43 rows
 AL = 22h: ROM 8 by 14 set
     BL   = row specifier
 AL = 23h: ROM 8 by 8 double dot
     BL   = row specifier
 AL = 24h: load 8x16 graphics characters (VGA)
 AL = 30h: return information
     BH   = pointer specifier
     0: INT 1Fh pointer
     1: INT 44h pointer
     2: ROM 8 by 14 character font pointer
     3: ROM 8 by 8 double dot font pointer
     4: ROM 8 by 8 DD font (top half)
     5: ROM alpha alternate (9 by 14) pointer
     Returns: ES:BP = specified pointer value
       CX    = bytes/character
       DL    = character rows on screen
-----------------------------------------------------------
INT 10 - VIDEO - ALTERNATE FUNCTION SELECT (PS, EGA, VGA, MCGA)
 AH = 12h
 BL = 10h: return EGA information
      Returns:
      BH = 0: color mode in effect (3Dx)
    1: mono mode in effect (3Bx)
      BL = 0:  64k bytes memory installed
    1: 128k bytes memory installed
    2: 192k bytes memory installed
    3: 256k bytes memory installed
      CH = feature bits
      CL = switch settings
 BL = 20h: select alternate print screen routine
 BL = 30h: select vertical resolution for alphanumeric modes (VGA only)
      AL = 00h 200 scan lines
    01h 350 scan lines
    02h 400 scan lines
      Return: AL = 12h if function supported
 BL = 31h: enable/disable default palette loading (VGA/MCGA)
      AL = 00h enable default palette loading
    01h disable default palette loading
      Return: AL = 12h if function was supported
 BL = 32h: enable/disable video addressing (VGA/MCGA)
      AL = 00h enable video
    01h disable video
      Return: AL = 12h if function was supported
 BL = 33h: enable/disable default gray-scale summing (VGA/MCGA)
      AL = 00h enable gray scale summing
    01h disable gray scale summing
      Return: AL = 12h if function was supported
 BL = 34h: enable/disable alphanumeric cursor emulation (VGA only)
      AL = 00h enable cursor emulation
    01h disable cursor emulation
      Return: AL = 12h if function was supported
 BL = 35h: PS/2 display-switch interface
      AL = 00h initial adapter video off
    01h initial planar video on
    02h switch active video off
    03h switch inactive video on
    80h *UNDOCUMENTED* set system board video active flag
      ES:DX = buffer (128 byte save area if AL = 0, 2 or 3)
 BL = 36h: video refresh control (VGA/PS)
      AL = 0 enable refresh
    1 disable refresh
      Return: AL = 12h if function supported
-----------------------------------------------------------
INT 10 - VIDEO - WRITE STRING (AT,XT286,PS,EGA,VGA)
 AH = 13h
 AL = mode
     bit 0: set in order to move cursor after write
     bit 1: set if string contains alternating characters and attributes
 BL = attribute if AL bit 1 clear
 BH = display page number
 DH,DL = row,column of starting cursor position
 CX = length of string
 ES:BP = pointer to start of string
-----------------------------------------------------------
INT 10 - VIDEO - LOAD LCD CHARACTER FONT (CONVERTIBLE)
 AH = 14h
 AL = 0 load user-specified font
     ES:DI = pointer to character font
     BH = number of bytes per character
     BL = 0: load main font (block 0)
   1: load alternate font (block 1)
     CX = number of characters to store
     DX = character offset into RAM font area
 AL = 1 load system rom default font
     BL = 0: load main font (block 0)
   1: load alternate font (block 1)
 AL = 2 set mapping of LCD high intensity attributes
     BL = 0: ignore high intensity attribute
   1: map high intensity to underscore
   2: map high intensity to revrese video
   3: map high intensity to selected alternate font
-----------------------------------------------------------
INT 10 - VIDEO - GET PHYSICAL DISPLAY PARAMETERS (CONVERTIBLE)
 AH = 15h
Return: AX = alternate display adapter type
 ES:DI = pointer to parameter table
        word 0: monitor model number
      1: vertical pixels per meter
      2: horizontal pixels per meter
      3: total vertical pixels
      4: total horizontal pixels
      5: horizontal pixel separation in micrometers
      6: vertical pixel separation in micrometers
-----------------------------------------------------------
INT 10 - VIDEO - DISPLAY COMBINATION (PS,VGA/MCGA)
 AH = 1Ah
 AL = 0: read display combination code
      Return: BL = active display code
       BH = alternate display code
      1: set display combination code
       BL = active display code
       BH = alternate display code
Return: AL = 1Ah if function was supported
Display combination codes:
 00h no display
 01h monochrome adapter w/ monochrome display
 02h CGA w/ color display
 03h reserved
 04h EGA w/ color display
 05h EGA w/ monochrome display
 06h PGA w/ color display
 07h VGA w/ monochrome analog display
 08h VGA w/ color analog display
 09h reserved
 0Ah reserved
 0Bh MCGA w/ monochrome analog display
 0Ch MCGA w/ color analog display
 FFh unknown display type
-----------------------------------------------------------
INT 10 - VIDEO - FUNCTIONALITY/STATE INFORMATION (PS,VGA/MCGA)
 AH = 1Bh
 BX = implementation type
 BX = 0000h return funtionality/state information
    ES:DI buffer (64 bytes)
       DI+00 static funtionality table
       DI+04 video mode in effect
       DI+05 number of columns
       DI+07 length of regen buffer in bytes
       DI+09 starting address og regen buffer
       DI+0B cursor position for page 0
       DI+0D cursor position for page 1
       DI+0F cursor position for page 2
       DI+11 cursor position for page 3
       DI+13 cursor position for page 4
       DI+15 cursor position for page 5
       DI+17 cursor position for page 6
       DI+19 cursor position for page 7
       DI+1B cursor type
       DI+1D active display page
       DI+1E CRTC port address
       DI+20 current setting of register (3?8)
       DI+21 current setting of register (3?9)
       DI+22 number of rows
       DI+23 bytes/character
       DI+25 DCC of active display
       DI+26 DCC of alternate display
       DI+27 number of colors supported in current mode
       DI+29 number of pages supported in current mode
       DI+2A number of scan lines active
       (0,1,2,3) = (200,350,400,480)
       DI+2B primary character block
       DI+2C secondary character block
       DI+2D Miscellaneous flags
   bit 0 all modes on all displayss on
       1 gray summing on
       2 monochrome display attached
       3 default palette loading disabled
       4 cursor emulation enabled
       5 0 = intensity; 1 = blinking
       6 reserved
       7 reserved
       DI+2E to DI+30 reserved
       DI+32 save pointer state flags
   bit 0 512 character set active
       1 dynamic save area present
       2 alpha font override active
       3 graphics font override active
       4 palette override active
       5 DCC override active
       6 reserved
       7 reserved
       DI+33 to DI+3F reserved
State Functionality Table format (16 bytes)
address+00 modes supported #1
 bit 0 to bit 7 = 1 modes 0,1,2,3,4,5,6 supported
       +01 modes supported #2
 bit 0 to bit 7 = 1 modes 8,9,A,B,C,D,E,F supported
       +02 modes supported #3
 bit 0 to bit 3 = 1 modes 10,11,12,13 supported
 bit 4 to bit 7 reserved
       +03 to +06 reserved
       +07 scan lines supported
 bit 0 to bit 2 = 1 scan lines 200,350,400 supported
       +08 maximum number of active character blocks in text modes
       +09 total blocks available in text modes
       +0A miscellaneous function flags #1
 bit 0 all modes on all displays function supported
     1 gray summing function supported
     2 character font loading function supported
     3 default palette loading enable/disable supported
     4 cursor emulation function supported
     5 EGA palette present
     6 color palette present
     7 color paging function supported
       +0B miscellaneous function flags #2
 bit 0 light pen supported
     1 save/restore state function 1C supported
     2 intensity blinking function supported
     3 Display Combination Code supported
     4 reserved
     5 reserved
     6 reserved
     7 reserved
       +0C to +0D reserved
       +0E Save pointer function flags
 bit 0 512 character set supported
     1 dynamic save area supported
     2 alpha font override supported
     3 graphics font override supported
     4 palette override supported
     5 DCC extension supported
     6 reserved
     7 reserved
       +07 reserved
-----------------------------------------------------------
INT 10 - VIDEO - SAVE/RESTORE VIDEO STATE (PS50+,VGA)
 AH = 1Ch
 CX = requested states
      bit 0 video hardware
   1 BIOS data areas
   2 color registers and state
   3 reserved
   4 reserved
   5 reserved
   6 reserved
   7 reserved
 AL = 0: return state buffer size in 64 byte blocks
      1: save video state
  ES:BX = buffer address
      2: restore video state
  ES:BX = buffer address of previously saved state
Return: AL = 1Ch if function supported
-----------------------------------------------------------
INT 10 - VIDEO - SET GRAPHICS MODE (Hercules GRAFIX)
 AH = 40h
-----------------------------------------------------------
INT 10 - VIDEO - SET TEXT MODE (Hercules GRAFIX)
 AH = 41h
-----------------------------------------------------------
INT 10 - VIDEO - CLEAR CURRENT PAGE (Hercules GRAFIX)
 AH = 42h
-----------------------------------------------------------
INT 10 - VIDEO - SELECT DRAWING PAGE (Hercules GRAFIX)
 AH = 43h
 AL = Page number (0,1)
-----------------------------------------------------------
INT 10 - VIDEO - SELECT DRAWING FUNCTION (Hercules GRAFIX)
 AH = 44h
 AL = 0 : Clear pixels
 AL = 1 : Set pixels
 AL = 2 : Invert pixels
-----------------------------------------------------------
INT 10 - VIDEO - SELECT PAGE TO DISPLAY (Hercules GRAFIX)
 AH = 45h
 AL = Page number (0,1)
-----------------------------------------------------------
INT 10 - VIDEO - DRAW ONE PIXEL (Hercules GRAFIX)
 AH = 46h
 DI = x (0-720)
 BP = y (0-347)
Note: Function 44h determines operation and function 43h
 page to use.
-----------------------------------------------------------
INT 10 - VIDEO - FIND PIXEL VALUE (Hercules GRAFIX)
 AH = 47h
 DI = x (0-720)
 BP = y (0-347)
Return: AL = 0 Pixel clear
 AL = 1 Pixel set
Note: Function 43h specifies page that is used.
-----------------------------------------------------------
INT 10 - VIDEO - MOVE TO POINT (Hercules GRAFIX)
 AH = 48h
 DI = x (0-720)
 BP = y (0-347)
-----------------------------------------------------------
INT 10 - VIDEO - DRAW TO POINT (Hercules GRAFIX)
 AH = 49h
 DI = x (0-720)
 BP = y (0-347)
Note: Function 48h or 49h specify first point, 44h operation
 and 43h page to use.
-----------------------------------------------------------
INT 10 - VIDEO - BLOCK FILL (Hercules GRAFIX)
 AH = 4Ah
-----------------------------------------------------------
INT 10 - VIDEO - DISPLAY CHARACTER (Hercules GRAFIX)
 AH = 4Bh
 AL = Character to display
 DI = x (0-720)
 BP = y (0-347)
Note: Unlike the other BIOS character functions character
 position is specified in pixels rather than rows and
 columns.
-----------------------------------------------------------
INT 10 - VIDEO - DRAW ARC (Hercules GRAFIX)
 AH = 4Ch
-----------------------------------------------------------
INT 10 - VIDEO - DRAW CIRCLE (Hercules GRAFIX)
 AH = 4Dh
-----------------------------------------------------------
INT 10 - VIDEO - FILL AREA (Hercules GRAFIX)
 AH = 4Eh
-----------------------------------------------------------
INT 10 - Direct Graphics Interface Standard (DGIS) - INQUIRE AVAILABLE DEVICES
 AX = 6A00h
 BX = 0
 CX = 0
 DX = buffer length (may be 0)
 ES:DI = address of buffer
Return: BX = number of bytes stored in buffer
 CX = bytes required for all descriptions (0 if no DGIS)
Note: buffer contains descriptions and addresses of DGIS-compatible
 display(s) and printer(s)
-----------------------------------------------------------
INT 10 - DGIS - REDIRECT CHARACTER OUTPUT
 AX = 6A01h
 CX = 0
 ES:DI = address of device to send INT 10 output to
Return: CX = 0   output could not be redirected
      else INT 10h output now routed to requested display
-----------------------------------------------------------
INT 10 - DGIS - INQUIRE INT 10 OUTPUT DEVICE
 AX = 6A02h
 ES:DI = 0:0
Return: ES:DI = 0:0  if current display is non-DGIS
  else address of the current DGIS INT 10 display
-----------------------------------------------------------
INT 10 - VIDEO - GET VIDEO RAM ADDRESS (TANDY 1000)
 AH = 70h
Return: AX  = segment address of the following
 [BX] = offset address of green plane
 [CX] = segment address of green plane
 [DX] = segment address of red/blue plane
        (red offset = 0, blue offset = 4000)
-----------------------------------------------------------
INT 10 - VIDEO - GET INCRAM ADDRESSES (TANDY 1000)
 AH = 71h
Return: AX  = segment address of the following
 [BX] = segment address of INCRAM
 [CX] = offset address of INCRAM
-----------------------------------------------------------
INT 10 - VIDEO - SCROLL SCREEN RIGHT (TANDY 1000)
 AH = 72h
 AL = number of columns blanked at left of window
      0 = blank entire window
 BH = attributes to be used on blank columns
 CH,CL = row, column of upper left corner of window
 DH,DL = row, column of lower right corner
----------------------------------------------------------
INT 10 - VIDEO - SCROLL SCREEN LEFT (TANDY 1000)
 AH = 73h
 AL = number of columns blanked at right of window
      0 = blank entire window
 BH = attributes to be used on blank columns
 CH,CL = row, column of upper left corner of window
 DH,DL = row, column of lower right corner
-----------------------------------------------------------
INT 10 - VIDEO (DESQview) - ???
 AH = 80h
 DX = 4456h ('DV')
 ES:DI = pointer to ???
Return: DS = segment of DESQview data structure for video buffer
Note: this function is probably meant for internal use only, due to the magic
      value required in DX
-----------------------------------------------------------
INT 10 - VIDEO (DESQview) - ???
 AH = 81h
 DX = 4456h
Return: ES = segment of DESQview data structure for video buffer
     BYTE ES:[0] = current window number
Note: this function is probably meant for internal use only, due to the magic
      value required in DX
-----------------------------------------------------------
INT 10 - VIDEO (DESQview) - ???
 AH = 82h
 DX = 4456h
Return: DS = segment in DESQview for ???
 ES = segment of DESQview data structure for video buffer
 AL = current window number
 AH = ???
 BL = direct screen writes
     0 program does not do direct writes
     1 program does direct writes, so shadow buffer not usable
 BH = ???
 CL = ???
 CH = ???
Note: this function is probably meant for internal use only, due to the magic
      value required in DX
-----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ ONE REGISTER
 AH = F0h
 BH = 00h
 BL = pointer for pointer/data chips
     Pointer/data chips
        00h CRTC (3B4h mono modes, 3D4h color modes)
        08h Sequencer 3C4h
        10h Graphics Controller 3CEh
        18h Attribute Controller 3C0h
     Single registers
        20h Miscellaneous Output register 3C2h
        28h Feature Control register (3BAh mono modes, 3DAh color modes)
        30h Graphics 1 Position register 3CCh
        38h Graphics 2 Position register 3CAh
 DX = port number
 Return: BL = data
-----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - WRITE ONE REGISTER
 AH = F1h
 BH = 00h
 BL = pointer for pointer/data chips
     Pointer/data chips
        00h CRTC (3B4h mono modes, 3D4h color modes)
        08h Sequencer 3C4h
        10h Graphics Controller 3CEh
        18h Attribute Controller 3C0h
     Single registers
        20h Miscellaneous Output register 3C2h
        28h Feature Control register (3BAh mono modes, 3DAh color modes)
        30h Graphics 1 Position register 3CCh
        38h Graphics 2 Position register 3CAh
 DX = port number
 Return: BL = data
-----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ REGISTER RANGE
 AH = F2h
 CH = starting pointer value
 CL = Number of registers (>1)
 DX = port number
      00h CRTC (3B4h mono modes, 3D4h color modes)
      08h Sequencer 3C4h
      10h Graphics Controller 3CEh
      18h Attribute Controller 3C0h
 ES:BX buffer size of CL
-----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - WRITE REGISTER RANGE
 AH = F3h
 CH = starting pointer value
 CL = Number of registers (>1)
 DX = port number
      00h CRTC (3B4h mono modes, 3D4h color modes)
      08h Sequencer 3C4h
      10h Graphics Controller 3CEh
      18h Attribute Controller 3C0h
 ES:BX buffer size of CL
-----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ REGISTER SET
 AH = F4h
 CX = number of registers (>1)
 ES:BX address of table of records in this format:
      bytes 1-2 port number
  Pointer/data chips
     00h CRTC (3B4h mono modes, 3D4h color modes)
     08h Sequencer 3C4h
     10h Graphics Controller 3CEh
     18h Attribute Controller 3C0h
  Single registers
     20h Miscellaneous Output register 3C2h
     28h Feature Control register (3BAh mono modes, 3DAh color)
     30h Graphics 1 Position register 3CCh
     38h Graphics 2 Position register 3CAh
      byte 3 pointer value (0 for single registers)
      byte 4 EGA Register Interface returns data here
-----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - READ REGISTER SET
 AH = F5h
 CX = number of registers (>1)
 ES:BX address of table of records in this format:
      bytes 1-2 port number
  Pointer/data chips
     00h CRTC (3B4h mono modes, 3D4h color modes)
     08h Sequencer 3C4h
     10h Graphics Controller 3CEh
     18h Attribute Controller 3C0h
  Single registers
     20h Miscellaneous Output register 3C2h
     28h Feature Control register (3BAh mono modes, 3DAh color)
     30h Graphics 1 Position register 3CCh
     38h Graphics 2 Position register 3CAh
      byte 3 pointer value (0 for single registers)
      byte 4 EGA Register Interface writes data here
----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - REVERT TO DEFAULT REGISTERS
 AH = F6h
----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - DEFINE DEFAULT REGISTER TABLE
 AH = F7h
 DX = port number
    Pointer/data chips
       00h CRTC (3B4h mono modes, 3D4h color modes)
       08h Sequencer 3C4h
       10h Graphics Controller 3CEh
       18h Attribute Controller 3C0h
    Single registers
       20h Miscellaneous Output register 3C2h
       28h Feature Control register (3BAh mono modes, 3DAh color modes)
       30h Graphics 1 Position register 3CCh
       38h Graphics 2 Position register 3CAh
 ES:BX address of table of one byte entries, one byte
       to be written to each register
----------------------------------------------------------
INT 10 - Microsoft Mouse driver EGA support - INTERROGATE DRIVER
 AH = FAh
 BX = 0
 Return: BX = 0 if mouse driver not present
  ES:BX pointer to EGA Register Interface
  version number, if present:
      byte 1 = major release number
      byte 2 = minor release number
----------------------------------------------------------
INT 10 - VIDEO (TopView) - GET VIDEO BUFFER
 AH = FEh
 ES:DI = segment:offset of assumed video buffer
Return: ES:DI = segment:offset of actual video buffer
-----------------------------------------------------------
INT 10 - VIDEO (TopView) - UPDATE REAL SCREEN FROM VIDEO BUFFER
 AH = FFh
 CX = number of sequential characters that have been modified
 DI = offset of first character that has been modified
 ES = segment of video buffer
Note: avoid CX=0
-----------------------------------------------------------
INT 11 - EQUIPMENT DETERMINATION
Return: AX = equipment flag bits
     0       diskette installed
     1     8087 present
     2,3     always = 11
     4,5     initial video mode
      01 = 40x25 color
      10 = 80x25 color
      11 = 80X25 IBM monochrome
     6,7     number of diskette drives (only if bit 0 = 1)
      00 = 1, 01 = 2, 10 = 3, 11 = 4
     8     0 = dma present, 1 = no dma on system (PCjr???)
     9,10,11 number of RS232 cards
     12     game I/O attached
     13     serial printer installed (IBM-PCjr)
      internal modem installed (Convertible)
     14,15   number of printers
-----------------------------------------------------------
INT 12 - MEMORY SIZE
Return: AX = number of contiguous 1K blocks of memory
-----------------------------------------------------------
INT 13 - DISK - RESET DISK SYSTEM
 AH = 00h
-----------------------------------------------------------
INT 13 - DISK - STATUS OF DISK SYSTEM
 AH = 01h
Return: AL = status
     00h = successful completion
     01h = bad command
     02h = address mark not found
     03h = write attempted on write-protected disk
     04h = sector not found
     05h = reset failed (hard disk)
     06h = diskette changed
     07h = parameter act. failed (hard disk)
     08h = DMA overrun
     09h = DMA across 64K boundary
     0Ah = bad sector detected (hard disk)
     0Bh = bad track detected (hard disk)
     0Ch = unsupported track
     10h = bad CRC/ECC
     11h = data ECC corrected
     20h = controller failure
     40h = seek failed
     80h = time out
     AAh = drive not ready (hard disk)
     BBh = undefined error (hard disk)
-----------------------------------------------------------
INT 13 - DISK - READ SECTORS INTO MEMORY
 AH = 02h
 AL = number of sectors to read
 CH = track (for hard disk, bits 8,9 in high bits of CL)
 CL = sector
 DH = head
 DL = drive
 ES:BX = address of buffer to fill
Return: CF = set if error occurred
 AH = status (see AH=1 above)
 AL = number of sectors read
-----------------------------------------------------------
INT 13 - DISK - WRITE SECTORS FROM MEMORY
 AH = 03h
 AL = number of sectors to write
 CH = track (for hard disk, bits 8,9 in high bits of CL)
 CL = sector
 DH = head
 DL = drive
 ES:BX = address of buffer
Return: CF = set if error occurred
 AH = status (see AH=1 above)
 AL = number of sectors written
-----------------------------------------------------------
INT 13 - DISK - VERIFY SECTORS
 AH = 04h
 AL = number of sectors to verify
 CH = track (for hard disk, bits 8,9 in high bits of CL)
 CL = sector
 DH = head
 DL = drive
Return: CF = set if error occurred
 AH = status (see AH=1 above)
 AL = number of sectors verified
-----------------------------------------------------------
INT 13 - FLOPPY - FORMAT TRACK
 AH = 05h
 AL = number of sectors to create on this track
 CH = track
 CL = sector
 DH = head
 DL = drive
 ES:BX = pointer to array of 4-byte address fields
        byte 1 = track
        byte 2 = head
        byte 3 = sector
        byte 4 = bytes/sector  0=128, 1=256, 2=512, 3=1024
Return: CF set if error occurred
 AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - FORMAT TRACK
 AH = 05h
 AL = interleave value (XT only)
 ES:BX = 512-byte format buffer
  the first 2*(sectors/track) bytes contain F,N for each sector
     F = 00 for good sector, 80h for bad sector
     N = sector number
 CH = cylinder number (bits 8,9 in high bits of CL)
 CL = sector number
 DH = head
 DL = drive
Return: AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - FORMAT TRACK AND SET BAD SECTOR FLAGS (XT,PORT)
 AH = 06h
 AL = interleave value (XT only)
 ES:BX = 512-byte format buffer
  the first 2*(sectors/track) bytes contain F,N for each sector
     F = 00 for good sector, 80h for bad sector
     N = sector number
 CH = cylinder number (bits 8,9 in high bits of CL)
 CL = sector number
 DH = head
 DL = drive
Return: AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - FORMAT DRIVE STARTING AT GIVEN TRACK (XT,PORT)
 AH = 07h
 AL = interleave value (XT only)
 ES:BX = 512-byte format buffer, see AH=6 above
 CH = cylinder number (bits 8,9 in high bits of CL)
 CL = sector number
 DH = head
 DL = drive
Return: AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
 AH = 08h
 DL = drive number
Return: CF set on error
 AH = status code (see AH=1 above)
 DL = number of consecutive acknowledging drives
 DH = maximum value for head number
 CL = maximum value fo sector number
 CH = maximum value for cylinder number
-----------------------------------------------------------
INT 13 - FIXED DISK - INITIALIZE TWO FIXED DISK BASE TABLES (XT,AT,XT286,PS)
 AH = 09h
Return: CF set on error
 AH = status code (see AH=1 above)
 INT 41h points to table for drive 0
 INT 46h points to table for drive 1
-----------------------------------------------------------
INT 13 - FIXED DISK - READ LONG (XT,AT,XT286,PS)
 AH = 0Ah
 DL = drive ID
 DH = head
 CH = cylinder (bits 8,9 in high bits of CL)
 CL = sector
 ES:BX = pointer to buffer to fill
Return: CF set on error
 AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - WRITE LONG (XT,AT,XT286,PS)
 AH = 0Bh
 DL = drive ID
 DH = head
 CH = cylinder (bits 8,9 in high bits of CL)
 CL = sector
 ES:BX = pointer to buffer containing data
Return: CF set on error
 AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - SEEK TO CYLINDER (XT,AT,XT286,PS)
 AH = 0Ch
 DL = drive ID
 DH = head
 CH = cylinder (bits 8,9 in high bits of CL)
Return: CF set on error
 AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - ALTERNATE DISK RESET (XT,PORT,AT,XT286,PS)
 AH = 0Dh
 DL = drive ID
Return: CF set on error
 AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - READ SECTOR BUFFER (XT,PORT,PS)
 AH = 0Eh
 AL = number of sectors
 CH = cylinder (bits 8,9 in top two bits of CL)
 CL = sector number
 DH = head number
 DL = drive number
 ES:BX = pointer to buffer
Return: AL = number of sectors actually transferred
 AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - WRITE SECTOR BUFFER (XT,PORT,PS)
 AH = 0Fh
 AL = number of sectors
 CH = cylinder (bits 8,9 in top two bits of CL)
 CL = sector number
 DH = head number
 DL = drive number
 ES:BX = pointer to buffer
Return: AL = number of sectors actually transferred
 AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - TEST FOR DRIVE READY (XT,AT,XT286,PS)
 AH = 10h
 DL = drive ID
Return: CF set on error
 AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - RECALIBRATE DRIVE (XT,PORT,AT,XT286,PS)
 AH = 11h
 DL = drive ID
Return: CF set on error
 AH = status code (see AH=1 above)
-----------------------------------------------------------
INT 13 - FIXED DISK - CONTROLER RAM DIAGNOSTIC (XT,PORT,PS)
 AH = 12h
Return: AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - DRIVE DIAGNOSTIC (XT,PORT,PS)
 AH = 13h
Return: AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - FIXED DISK - CONTROLLER DIAGNOSTICS (XT,PORT,AT,XT286,PS)
 AH = 14h
Return: CF set on error
 AH = status code (see AH=1 above)
Note: used for diagnostics only on PS/2 systems
-----------------------------------------------------------
INT 13 - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)
 AH = 15h
 DL = drive ID
Return: AH = disk type
     0 = disk not there
     1 = floppy, no change detection present
     2 = floppy with change detection
     3 = fixed disk
        CX:DX = number of 512-byte sectors
-----------------------------------------------------------
INT 13 - DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
 AH = 16h
 DL = drive to check
Return: AH = disk change status
     0 = no disk change
     6 = disk changed
-----------------------------------------------------------
INT 13 - DISK - SET TYPE (AT,XT2,XT286,CONV,PS)
 AH = 17h
 AL = disk type
     00 = no disk
     01 = regular disk in regular drive
     02 = regular disk in high-capacity drive
     03 = high-capacity disk in high-capacity drive
 DL = drive ID
-----------------------------------------------------------
INT 13 - DISK - SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)
 AH = 18h
 DL = drive number
 CH = lower 8 bits of number of tracks
 CL = sectors per track (bits 0-5)
      top 2 bits of number of tracks (bits 6,7)
Return: AH = 00h  requested combination supported
      01h  function not available
      0Ch  not supported or drive type unknown
      80h  there is no disk in the drive
 ES:DI = pointer to 11-byte parameter table
-----------------------------------------------------------
INT 13 - FIXED DISK - PARK HEADS (XT286,PS)
 AH = 19h
-----------------------------------------------------------
INT 13 - ESDI FIXED DISK - FORMAT UNIT (PS50+)
 AH = 1Ah
 ???
-----------------------------------------------------------
INT 14 - SERIAL I/O - INITIALIZE USART
 AH = 00h
 AL = initializing parameters
     7 - 6 - 5    4 - 3     2   1 - 0
     -BAUD RATE-    PARITY   STOP   WORD
        BITS  LENGTH
     000  110 bd    00 none  0-1   10 - 7
     001  150 bd    01 odd   1-2   11 - 8
     010  300 bd    11 even
     011  600 bd
     100 1200 bd
     101 2400 bd
     110 4800 bd
     111 9600 bd (4800 on PCjr)
 DX = port number
Return: AH = RS-232 status code bits
     0: data ready
     1: overrun error
     2: parity error
     3: framing error
     4: break detected
     5: transmission buffer register empty
     6: transmission shift register empty
     7: time out--if set, other bits invalid
 AL = modem status bits
     0: delta Clear-To-Send
     1: delta Data-Set-Ready
     2: trailing edge of ring detected
     3: change in receive line signal detected
     4: Clear-To-Send
     5: Data-Set-Ready
     6: ring detected
     7: receive line signal detected
-----------------------------------------------------------
INT 14 - SERIAL I/O - TRANSMIT CHARACTER
 AH = 01h
 AL = character
 DX = port number
Return: AX = port status (see AH = 00h above)
-----------------------------------------------------------
INT 14 - SERIAL I/O - RECEIVE CHARACTER
 AH = 02h
Return: AL = character received
 AH = RS-232 status code (see AH = 00h above)
-----------------------------------------------------------
INT 14 - SERIAL I/O - GET USART STATUS
 AH = 03h
Return: AX = port status code (see AH = 00h above)
-----------------------------------------------------------
INT 14 - SERIAL I/O - EXTENDED INITIALIZE (CONVERTIBLE???,PS)
 AH = 04h
 AL = break status
     0 if break
     1 if no break
 BH = parity
     0 no parity
     1 odd parity
     2 even parity
     3 stick parity odd
     4 stick parity even
 BL = number of stop bits
     0: one stop bit
     1: two stop bits (1.5 if 5 bit word length)
 CH = word length
     0: 5 bits
     1: 6 bits
     2: 7 bits
     3: 8 bits
 CL = baud rate
     0: 110
     1: 150
     2: 300
     3: 600
     4: 1200
     5: 2400
     6: 4800
     7: 9600
     8: 19200
Return: AX = port status code (see AH = 00h above)
-----------------------------------------------------------
INT 14 - SERIAL I/O - EXTENDED COMMUNICATION PORT CONTROL (CONVERTIBLE???,PS)
 AH = 05h
 AL = 0 read modem control register
       Return: BL = modem control register (see below)
        AH = status
 AL = 1 write modem control register
       BL = modem control register
    bit 0: data terminal ready
    bit 1: request to send
    bit 2: OUT1
    bit 3: OUT2
    bit 4: LOOP
    bits 5-7 reserved
       Return: AH = status
-----------------------------------------------------------
INT 15 - CASSETTE - TURN ON MOTOR (PC,Jr)
 AH = 00h
Return: motor turned on
-----------------------------------------------------------
INT 15 - CASSETTE - TURN OFF MOTOR (PC,Jr)
 AH = 01h
Return: motor turned off
-----------------------------------------------------------
INT 15 - CASSETTE - READ DATA BLOCKS (PC,Jr)
 AH = 02h
 CX = count of bytes
 ES:BX = pointer to data area
Return: CF set on error
 DX = count of bytes read
 ES:BX = pointer past last byte read
-----------------------------------------------------------
INT 15 - CASSETTE - WRITE DATA BLOCKS (PC,Jr)
 AH = 03h
 CX = count of bytes to write
 ES:BX = pointer to data area
Return: ES:BX = pointer past last byte written
-----------------------------------------------------------
Int 15 - SYSTEM - FORMAT UNIT PERIODIC INTERRUPT (PS ESDI drives only)
 AH = 0Fh
 ???
Return: ???
-----------------------------------------------------------
INT 15 - TopView - "PAUSE" - GIVE UP CPU TIME
 AX = 1000h
Return: after other processes run
-----------------------------------------------------------
INT 15 - TopView - "GETMEM" - ALLOCATE "SYSTEM" MEMORY
 AX = 1001h
 BX = number of bytes to allocate
Return: ES:DI = pointer to block of memory
-----------------------------------------------------------
INT 15 - TopView - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY
 AX = 1002h
 ES:DI = pointer to previously allocated block
Return: block freed
-----------------------------------------------------------
INT 15 - TopView - "PRINTC" - DISPLAY CHARACTER/ATTRIBUTE ON SCREEN
 AX = 1003h
 BH = attribute
 BL = character
 DX = segment of object handle for window
Note: BX=0 does not display anything, it only positions the hardware cursor
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.00
 AH = 10h
 AL = 04h thru 12h
Return: pops up "Programming error" window in DV 2.00
-----------------------------------------------------------
INT 15 - TopView - "GETBIT" - DEFINE A 2ND-LEVEL INTERRUPT HANDLER
 AX = 1013h
 ES:DI = pointer to FAR service routine
Return: BX = bit mask indicating which bit was allocated
      0 if no more bits available
-----------------------------------------------------------
INT 15 - TopView - "FREEBIT" - UNDEFINE A 2ND-LEVEL INTERRUPT HANDLER
 AX = 1014h
 BX = bit mask from INT 15/AX=1013h
-----------------------------------------------------------
INT 15 - TopView - "SETBIT" - SCHEDULE ONE OR MORE 2ND-LEVEL INTERRUPTS
 AX = 1015h
 BX = bit mask for interrupts to post
Return: indicated routines will be called at next ???
-----------------------------------------------------------
INT 15 - TopView - "ISOBJ" - VERIFY OBJECT HANDLE
 AX = 1016h
 ES:DI = possible object handle
Return: BX = 0 if ES:DI is a valid object handle
     -1 if ES:DI is not
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.00
 AX = 1017h
Return: pops up "Programming error" window in DV 2.00
-----------------------------------------------------------
INT 15 - TopView - "LOCATE" - FIND WINDOW AT A GIVEN SCREEN LOCATION
 AX = 1018h
 BH = column
 BL = row
 ES = segment of object handle???
      (0 = use default)
Return: ES = segment of object handle for window which is visible at the
      indicated position
-----------------------------------------------------------
INT 15 - TopView - "SOUND" - MAKE TONE
 AX = 1019h
 BX = frequency in Hertz
 CX = duration in clock ticks (18.2 ticks/sec)
Return: immediately, tone continues to completion
Notes: if another tone is already playing, the new tone does not start until
       completion of the previous one. In DV 2.00, it is possible to enqueue
       about 32 tones before the process is blocked until a note completes.
       in DV 2.00, the lowest tone allowed is 20 Hz
-----------------------------------------------------------
INT 15 - TopView - "OSTACK" - SWITCH TO TASK'S INTERNAL STACK
 AX = 101Ah
Return: stack switched
-----------------------------------------------------------
INT 15 - TopView - "BEGINC" - BEGIN CRITICAL REGION
 AX = 101Bh
Return: task-switching temporarily disabled
Note: will not task-switch until END CRITICAL REGION (AX = 101Ch) called
-----------------------------------------------------------
INT 15 - TopView - "ENDC" - END CRITICAL REGION
 AX = 101Ch
Return: task-switching enabled
-----------------------------------------------------------
INT 15 - TopView - "STOP" - STOP TASK
 AX = 101Dh
 ES = segment of object handle for task to be stopped
      (== handle of main window for that task)
Return: indicated task will no longer get CPU time
-----------------------------------------------------------
INT 15 - TopView - "START" - START TASK
 AX = 101Eh
 ES = segment of object handle for task to be started
      (== handle of main window for that task)
Return: indicated task is started up again
-----------------------------------------------------------
INT 15 - TopView - "DISPEROR" - POP-UP ERROR WINDOW
 AX = 101Fh
 BX = bit fields
      bits 0-12: number of characters to display
      bits 13,14: which mouse button may be pressed to remove window
    00 = either
    01 = left
    10 = right
    11 = either (maybe should read "both" or "center"???)
      bit 15: beep if 1
 DS:DI = pointer to text of message
 CH = width of error window (0 = default)
 CL = height of error window (0 = default)
 DX = segment of object handle
Return: BX = ???
Note: window remains on-screen until ESC or indicated mouse button is pressed
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.00
 AX = 1020h
Return: pops up "Programming error" window in DV 2.00
-----------------------------------------------------------
INT 15 - TopView - "PGMINT" - INTERRUPT ANOTHER TASK
 AX = 1021h
 BX = segment of object handle for task to interrupt
 DX:CX = address of FAR routine to jump to (next time task is run???)
Return: nothing???
Note: the current ES, DS, SI, DI, and BP are passed to the FAR routine
-----------------------------------------------------------
INT 15 - TopView - "GETVER" - GET VERSION
 AX = 1022h
 BX = 0
Return: BX nonzero, TopView or compatible loaded
 (BL = major version, BH = minor version)
Notes: TaskView returns BX = 0001h, DESQview 2.0 returns BX = 0A01h
-----------------------------------------------------------
INT 15 - TopView - "POSWIN" - POSITION WINDOW
 AX = 1023h
 BX = segment of object handle for parent window within which to
      position the window (0 = full screen)
 DL = bit flags
      bits 0,1: horizontal position
  00 = current
  01 = center
  10 = left
  11 = right
      bits 2,3: vertical position
  00 = current
  01 = center
  10 = top
  11 = bottom
      bit 4: don't redraw screen if set
      bits 5-7 not used
 ES = segment of object handle for window
Return: ???
-----------------------------------------------------------
INT 15 - TopView - "GETBUF" - GET VIRTUAL SCREEN INFO
 AX = 1024h
 BX = segment of object handle for window
       (0 = use default)
Return: ES:DI = address of virtual screen
 CX = size of virtual screen in bytes
 DL = 0 ???
      1 ???
-----------------------------------------------------------
INT 15 - TopView - "USTACK" - SWITCH BACK TO USER'S STACK
 AX = 1025h
Return: stack switched back
Note: call only after INT 15h/AX=101Ah
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - UNIMPLEMENTED IN DV 2.00
 AH = 10h
 AL = 26h thru 2Ah
Return: pops up "Programming error" window in DV 2.00
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - "POSTTASK"??? - AWAKEN TASK ???
 AX = 102Bh
 BX = segment of object handle for task's OBJECTQ ???
Return: nothing
Note: calls INT 15/AH=12/BX=0506
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - SET .PIF ???
 AX = 102Ch
 BX = number of bytes to copy
      >416 changed to 367, then values <= 369 get some additional code
 ES:DI = pointer to contents of .PIF file ???
Return: BX = ???
-----------------------------------------------------------
INT 15 - DESQview (TopView???) - ???
 AX = 102Dh
 BL = subfunction
      00h
      01h
      02h
Return: ???
-----------------------------------------------------------
INT 15 - TopView commands
 AH = 11h
 AL = various
Note: in DESQview 2.00, these function calls are identical to AH=DEh, so
      see those below
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "HANDLE" - RETURN OBJECT HANDLE
 AH = 12h
 BH = 00h
 BL = which handle to return
     00h handle in DWORD on top of stack
     01h current task's window handle
     02h given task's mailbox handle (task's handle on stack)
     03h current task's mailbox handle
     04h given task's keyboard handle (task's handle on stack)
     05h current task's keyboard object handle
     06h given task's OBJECTQ handle (task's handle on stack)
     07h current task's OBJECTQ handle
     08h   \
       thru > returns 0000:0000
     10h   /
Return: DWORD on top of stack is object handle
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "NEW" - CREATE NEW OBJECT
 AH = 12h
 BH = 01h
 BL = object
     00h handle is DWORD on top of stack
     01h use task's window handle
  takes 8 DWORD parameters on stack
     02h given task's mailbox (task's handle on top of stack)
     03h current task's mailbox
     04h given task's keyboard (task's handle on top of stack)
     05h current task's keyboard object
     08h WINDOW class
  takes 8 DWORD parameters on stack
     09h MAILBOX class
     0Ah KEYBOARD class
     0Bh TIMER object (counts down 32-bit time in 10ms increments)
     0Fh POINTER object
     10h PANEL object
Return: DWORD on top of stack is new object handle
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "FREE" - FREE AN OBJECT
 AH = 12h
 BH = 02h
 BL = object
     00h handle in DWORD on top of stack
  window: close window and free
  timer: free timer
  panel: free panel object
  pointer: free pointer
     01h task's window handle - kills task, never returns
     02h given task's mailbox (task's handle on top of stack)
     03h current task's mailbox
     04h given task's keyboard (task's handle on top of stack)
     05h current task's keyboard object
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "ADDR" - GET OBJECT HANDLE
 AH = 12h
 BH = 03h
 BL = object
     00h handle in DWORD on top of stack
     02h sender of last msg read from mailbox (task's handle on stack)
     03h sender of last msg read from current task's mailbox
Return: DWORD on stack is handle
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "DIR" - GET PANEL FILE DIRECTORY
 AH = 12h
 BX = 0300h
 STACK: DWORD handle of panel object
Return: ???
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "READ" - GET NEXT RECORD
 AH = 12h
 BH = 04h
 BL = object
     00h handle is DWORD on top of stack
  window: read next logical line
  timer: wait for timer to expire
  pointer: wait for next message
     01h read the next logical line from task's default window
     02h get next message from mailbox (task's handle on top of stack)
     03h get next message from current task's mailbox
     04h get the next input from keyboard (handle on top of stack)
     05h get the next input from task's default keyboard
     06h wait for input from any object in OBJECTQ (handle on stack)
     07h wait for input from any object in task's default OBJECTQ
Return: STACK: DWORD number of bytes
        DWORD address
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "APPLY" - WRITE PANEL TO WINDOW
 AH = 12h
 BX = 0400h
 STACK: DWORD handle of panel object
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "WRITE" - WRITE STRING TO OBJECT
 AH = 12h
 BH = 05h
 BL = object
     00h handle is DWORD on top of stack
  window: write string
  timer: start timer to end at a specified time
  pointer: move pointer icon to specified position
     01h write string to task's default window
     02h send message by value/status=0 to mbox (task's handle on stack)
     03h send message by value/status=0 to current task's mailbox
     04h add input buffer to KEYBOARD queue (handle on top of stack)
     05h add input buffer to task's default KEYBOARD queue
     06h add an object to OBJECTQ (handle on top of stack)
     07h add an object to task's default OBJECTQ
 STACK: DWORD object handle if handle passed on stack
        DWORD total length of string (high word == 0)
        DWORD address of string to display
Note: service routine will pop stack
-----------
IF OBJECT IS A WINDOW, THEN
Return: indicated actions performed
 a. non-control characters are displayed
 b. CR/LF/BS/Tab cause the usual cursor movement
 c. ESC starts a data structure with additional commands
Data Structure:
 MAGIC  DB  1Bh
 MODE   DB  ?   ; 00h, 01h, 10h, 14h-1Fh legal
 LENGTH DW  ?   ; length of remainder in bytes
 var-length fields follow, each an OPCODE followed by
      zero or more args
MODE 00h (set or display values) "WINDOW STREAM"
    Opcodes:args
 00h  display 20h blanks with the default attribute
 01h-1Fh display OPCODE blanks with the default attribute
 20h  display char with default attribute 20h times
      BYTE char to repeat
 21h-3Fh display char with default attribute OPCODE-20h times
      BYTE char to repeat
 40h  display 20h blanks with specified attribute
      BYTE attribute of blanks
 41h-5Fh display OPCODE-40h blanks with specified attribute
      BYTE attribute of blanks
 60h  display next 20h characters
      20h BYTES characters to display
 61h-7Fh display next OPCODE-60h characters
      N BYTES characters to display
 80h-87h  display N blanks with default attribute
      BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
        [000h means 800h]
 88h-8Fh display N copies of the character
      BYTE low 8 bits of 11-bit count (high 3 in low 3 bits of OPCODE)
        [000h means 800h]
      BYTE character to repeat
 90h-97h  display N blanks with specified attribute
      BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
        [000h means 800h]
      BYTE attribute
 98h-9FH  display string at logical cursor pos
      BYTE low 8 bits of 11-bit length (high 3 in low 3 bits of OPCODE)
        [000h means 800h]
      N BYTES string to display
 A0h  set logical cursor row
      BYTE row number (0 is top)
 A1h  set logical cursor column
      BYTE column number (0 is leftmost)
 A2h  ???
      BYTE ???
 A3h  ???
      BYTE ???
 A4h  set row of physical window position
      BYTE line
 A5h  set column of physical window position
      BYTE column
 A6h  set height of physical window
      BYTE #rows
 A7h  set width of physical window
      BYTE #columns
 A8h  set viewport row
      BYTE row
 A9h  set viewport column
      BYTE column
 AAh  set virtual screen height
      BYTE rows
 ABh  set virtual screen width
      BYTE columns
 ACh-AEh  unused
 AFh  ???
      BYTE ??? (ANDed with current value of something)
 B0h  move logical cursor down
      BYTE #rows (signed, negative values move up)
 B1h  move logical cursor right
      BYTE #cols (signed, negative values move left)
 B2h  ???
      BYTE ??? (signed)
 B3h  ???
      BYTE ??? (signed)
 B4h  shift window down
      BYTE #lines (signed)
 B5h  shift window right
      BYTE #columns (signed)
 B6h  expand physical window vertically
      BYTE #lines (signed)
 B7h  expand physical window horizontally
      BYTE #columns (signed)
 B8h  adjust viewport row
      BYTE #rows (signed)
 B9h  adjust viewport column
      BYTE #columns (signed)
 BAh  adjust virtual screen height
      BYTE #rows to increase (signed)
 BBh  adjust virtual screen width
      BYTE #cols to increase (signed)
 BCh-BFh  unused
 C0h  set logical cursor position
      BYTE row number (0 is top border)
      BYTE column number (0 is left border)
 C1h  ???
      BYTE ???
      BYTE ???
 C2h  set window pos
      BYTE upper left row (no top border if 0)
      BYTE upper left column (no left border if 0)
 C3h  set current window size
      BYTE #rows
      BYTE #cols
 C4h  set upper left corner of viewport (portion of virtual screen
      displayed in window)
      BYTE row
      BYTE column
 C5h  set size of virtual screen
      BYTE #rows
      BYTE #cols
 C6h  unused
 C7h  unused
 C8h  set logical cursor relative to current position
      BYTE number of rows to move down (signed)
      BYTE number of columns to move right (signed)
 C9h  ???
      BYTE ???
      BYTE ???
 CAh  set window pos relative to current position
      BYTE number of rows to shift down (signed)
      BYTE number of columns to shift right (signed)
 CBh  set window size relative to current size
      BYTE number of rows to expand (signed)
      BYTE number of cols to expand (signed)
 CCh  shift viewport relative to current position
      BYTE rows to shift (signed)
      BYTE cols to shift (signed)
 CDh  resize virtual screen (guess)
      BYTE #rows to expand (signed)
      BYTE #cols to expand (signed)
 CEh  clear ???
 CFh  set ???
 D0h  turn on ??? (default)
 D1h  turn off ???
 D2h  turn on ???
 D3h  turn off ??? (default)
 D4h  window is visible
 D5h  window is hidden
 D6h  window has frame
 D7h  window unframed
 D8h  turn on ??? (default)
 D9h  turn off ???
 DAh  use logical attributes, which may be remapped
  attributes
     1 normal text
     2 highlighted normal text
     3 help text
     4 highlighted help text
     5 error message
     6 highlighted error message
     7 emphasized text
     8 marked text
     others???
 DBh  use physical attributes for characters
 DCh  enable special actions for control characters (default)
 DDh  disable special control char handling, all chars displayable by
      BIOS TTY call
 DEh  write both character and attribute (default)
 DFh  write character only, leave attribute untouched
 E0h  repeat following commands
      BYTE number of times
 E1h  end of commands to repeat, start repeating them
 E2h  set color
      BYTE color
 E3h  clear virtual screen
 E4h  redraw window
 E5h  ???
      BYTE ???
 E6h  create new window and perform rest of manipulations in new window
      BYTE number of rows
      BYTE number of columns
      Return: DWORD object handle returned on stack at end
 E7h  unused
 E8h  ???
      BYTE ???
      BYTE ???
      additional args???
 E9h  ???
      BYTE ???
      BYTE ???
      additional args???
 EAh  ???
      BYTE ???
      BYTE ???
      additional args???
 EBh  ???
      BYTE ???
      BYTE ???
      additional args???
 ECh  ???
      BYTE ???
      BYTE count of remaining args \ counted string maybe???
      N BYTES remaining args   /
 EDh  ???
      BYTE ???
      BYTE ???
      var-length args
 EEh  same as EDh, but ???
      BYTE ???
      BYTE ???
      var-length args
 EFh  set window name
      BYTE length of name
      N BYTES name
 F0h  clear input field to blanks
      BYTE field number
 F1h  fill input field with character
      BYTE field number
      BYTE char
 F2h  set color of input field
      BYTE field number (1-N)
      BYTE attribute
 F3h  set initial contents of input field
      BYTE field number (1-N)
      N BYTES enough chars to exactly fill field as defined by op FFh
 F4h  position cursor to specific input field
      BYTE field number (1-N)
 F5h  change field table entry
      BYTE field number
      7-8 BYTEs field table entry (see FFh)
 F6h  set field type??? (guess)
      BYTE field number
      BYTE type???
 F7h  ???
      STRING??? (I saw 20h 20h 20h 20h)
 F8h  ???
      BYTE field number
      additional args???
 F9h  ???
      BYTE field number
      additional args???
 FAh  ???
      BYTE field number
      additional args???
 FBh  ???
      BYTE field number
      additional args???
 FCh  set field table header??? (guess)
      BYTE field number
      BYTE ???
      6 BYTES ???
      additional args???
 FDh  ???
      no args???
 FEh  ??? (no args)
 FFh  set up input fields
      table header
   BYTE number of fields
   BYTE screen type ??? (I see 47h, 52h, 53h, 55h, 57h, and 5Bh)
   WORD ??? (I see 0 always)
   BYTE color of field currently pointed to
   BYTE color of input fields which have been selected
      the field table entries, one for each field
   BYTE start row
   BYTE start column
   BYTE end row
   BYTE end column
   BYTE field type (A0h allows user entry, 00h/40h don't)
        80h is a fill-in field
        C0h is a menu selection
   BYTE modifier
        if type is 80h, then bit flags to determine behavior
     bit 7  if set, beep when field is full
     bit 6  move to next field when current field is full
     bit 5  if set, enter text from right end (for numbers)
     bit 4  if set, force input to uppercase
     bit 3  if set, clear old contents on first keystroke
     bit 2,1,0 ???
        if type is C0h, key to press to activate menu sel
          00h if have to point-and-click
   BYTE ???
   BYTE second key for activating menu selection if field type is
        C0h (0 = only single key).  Only present if SCREEN TYPE
     is 5Bh
MODE 01h "QUERY STREAM" (valid only for those opcodes listed here)
 A0h return logical cursor row in next byte
 A1h return logical cursor column in next byte
 A2h
 A3h
 A4h return row of physical window origin in next byte
 A5h return column of physical window origin in next byte
 A6h return height of physcial window in next byte
 A7h return width of physical window in next byte
 A8h return row of viewport origin in next byte
 A9h return column of viewport origin in next byte
 AAh return height of virtual screen in next byte
 ABh return width of virtual screen in next byte
 AFh return ??? in next byte
 C0h return current logical cursor position in next two bytes
 C1h return ??? in next two bytes
 C2h return current window position in next two bytes
 C3h return current window size in next two bytes
 C4h return current viewport origin in next two bytes
 C5h return current virtual screen size in next two bytes
 D0h \ overwritten with D0h if ??? on
 D1h /         D1h if ??? off
 D2h \ overwritten with D2h if ??? on
 D3h /         D3h if ??? off
 D4h \ overwritten with D4h if window visible
 D5h /         D5h if window hidden
 D6h \ overwritten with D6h if window has frame
 D7h /         D7h if window unframed
 D8h \ overwritten with D8h if ??? on
 D9h /         D9h if ??? off
 DAh \ overwritten with DAh if using logical attributes
 DBh /         DBh if using physical attributes
 DCh \ overwritten with DCh if TTY control char interpretation on
 DDh /         DDh if TTY control char interpretation off
 DEh \ overwritten with DEh if writing both characters and attributes
 DFh /                  DFh if leaving attributes untouched
 E2h return current color in next byte
 ECh
 EDh
 EEh
 EFh return current window name
     BYTE    max length of returned name
     N BYTES buffer to hold window name
 F3h return contents of input field
     BYTE field number
     N BYTES buffer to hold field contents (size exactly equal to field
      size)
 F5h get field table entry
     BYTE field number
     7-8 BYTES buffer to hold field table entry
 F6h get type of a field??? (guess)
     BYTE field number
     BYTE type???
 FCh get field table header??? (guess)
     BYTE field number
     BYTE ???
     6 BYTES ???
     additional args???
MODE 10h "MANAGER STREAM" (valid only for opcodes listed here)
 00h allow window to be moved horizontally
 01h allow window to be moved vertically
 02h allow window to change width
 03h allow window to change height
 04h allow window to be scrolled horizontally
 05h allow window to be scrolled vertically
 06h allow "Close Window" menu selection
 07h allow window to be hidden
 08h allow "Mark" menu
 0Eh allow "Scissors" menu
 10h allow DESQview main menu to be popped up
 11h allow "Switch Windows" menu
 12h allow "Open Window" menu
 13h allow "Quit" menu selection
 20h-33h opposite of 00h-13h, disallow specified action
 40h notify if horizontal position of window changes
 41h notify if vertical position of window changes
 42h notify if width of window changes
 43h notify if height of window changes
 44h notify if window scrolled horizontally
 45h notify if window scrolled vertically
 46h notify if window is closed--program has to clean up and exit itself
 47h notify if window is hidden
        48h notify if "?" on main menu selected
 49h notify if ???
 4Ah notify if window is swapped out or hidden
 4Bh notify if ???
 4Ch notify if video mode changes
 4Dh notify if "Scissors" menu "Cut" option selected
 4Eh notify if "Scissors" menu "Copy" option selected
 4Fh notify if "Scissors" menu "Paste" option selected
 50h notify if DESQview main menu popped up
 51h notify if "Switch" menu selected
 60h-71h  opposite of 40h-51h: don't notify on specified event
 84h
 85h
 86h disable background operation
 87h enable running in background
 88h set minimum size of physical window
     BYTE rows
     BYTE columns
 89h set maximum size of physical window
     BYTE rows
     BYTE cols
 8Ah set primary asynchronous notification routine
     DWORD address of routine, 0000:0000 means none
    on entry ES:DI = handle of window, DS:SI is secondary routine
    routine should restore all registers before returning
 8Bh set secondary async notification routine
     DWORD address of routine, passed to primary routine in DS:SI,
    rather than called directly
 AEh
 AFh ???
     BYTE ???
 BCh
 BDh   opposite of BCh
 BEh
 BFh   opposite of BEh
 C0h move current window in front of all other windows
 C1h ???
 C2h move current window in front of all other windows
 C3h ??? (like C4h, but uses defaults)
 C4h ???
     BYTE ???
     BYTE ???
 C5h hide current window
 C6h ???
 C7h hide all windows for this process and switch to previous process
 C8h hide all windows for this process and switch to previous process
 C9h switch to previous process
 CAh move current window back behind other windows for this process
 CBh ???
 CCh closes current window???
 CEh reorder windows
     DWORD pointer to null-terminated list of words
    each word is segment of object handle for a window
MODES 14h to 1Fh ("user streams"???)
 normally NOPs, but may be defined (don't know how yet) to invoke FAR
 routines, one for each mode number
   on entry to handler,
  DS:SI = first byte of actual stream (not header)
  CX = #bytes in stream
  ES:DI = window's handle???
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SIZEOF" - GET OBJECT SIZE
 AH = 12h
 BH = 08h
 BL = object
     00h handle in DWORD on top of stack
  timer: elapsed time since timer started
  pointer: number of messages queued to pointer object
  panel: number of panels in panel file
     01h total chars in current task's default window
     02h number of messages in task's mailbox (task's handle on stack)
     03h number of messages in current task's mailbox
     04h number of input buffers queued in task's kbd (handle on stack)
     05h number of input buffers queued for current task's default kbd
     06h number of objects queued in OBJECTQ (task's handle on stack)
     07h number of objects queued in current task's OBJECTQ
Return: DWORD on stack is result
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "LEN" - GET OBJECT LENGTH
 AH = 12h
 BH = 09h
 BL = object
     00h handle in DWORD on top of stack
  window: chars/line
  timer: timer remaining before timer expires
     01h number of chars/line in current task's default window
Return: DWORD on top of stack is length
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "ADDTO" - SET OBJECT BITS
 AH = 12h
 BH = 0Ah
 BL = object
     00h handle is DWORD on top of stack
  window: write characters and attributes
  timer: start timer for specified interval
  pointer: set control flags
     01h write characters and attributes to task's default window
     02h send message/status by value to mailbox (task's handle on stack)
     03h send message/status by value to current task's default mailbox
     04h set control flags on KEYBOARD object (handle on top of stack)
     05h set control flags on task's default KEYBOARD object
 STACK: (if mailbox) DWORD status
       DWORD length of message
       DWORD address
        (otherwise)  DWORD bits to set
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SUBFROM" - RESET OBJECT BITS
 AH = 12h
 BH = 0Bh
 BL = object
     00h handle is DWORD on top of stack
  pointer: reset control flags
     01h write attributes only to task's default window
     02h send message/status by reference to box (task's handle on stack)
     03h send message/status by reference to current task's mailbox
     04h clear control flags on KEYBOARD object (handle on top of stack)
     05h clear control flags on task's default KEYBOARD object
     06h remove specific object from OBJECTQ (handle on top of stack)
     07h remove specific object from task's default OBJECTQ
 STACK: DWORD indicates which bits to clear
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "OPEN" - OPEN OBJECT
 AH = 12h
 BH = 0Ch
 BL = object
     00h handle is DWORD on top of stack
  timer: open
  pointer: start taking input for window
  panel: associate with a panel file
     01h fill task's default window with given character
     02h open given task's mailbox for input (task's handle on stack)
     03h open current task's mailbox
     04h attach a KEYBOARD to a window (handle on top of stack)
     05h attach task's default KEYBOARD to a window
     06h open a task's OBJECTQ (task's handle on top of stack)
     07h open current task's OBJECTQ
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "CLOSE" - CLOSE OBJECT
 AH = 12h
 BH = 0Dh
 BL = object
     00h handle is DWORD on top of stack
  timer: close
  pointer: stop taking input
  panel: close
     02h close given task's mailbox (task's handle on top of stack)
     03h close task's default mailbox
     04h close KEYBOARD object (handle on top of stack)
     05h close task's default KEYBOARD
     06h close givent task's OBJECTQ (task's handle on top of stack)
     07h close current task's OBJECTQ
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "ERASE" - ERASE OBJECT
 AH = 12h
 BH = 0Eh
 BL = object
     00h handle is DWORD on top of stack
  window: clear
  timer: cancel current interval
  pointer: discard all pending messages
     01h clear task's default window
     02h discard all queued messages in mailbox (handle on top of stack)
     03h discard all queued messages in current task's default mailbox
     04h discard all input queued to KEYBOARD (handle on top of stack)
     05h discard all input queued to task's default KEYBOARD
     06h remove all objects from OBJECTQ (task's handle on top of stack)
     07h remove all objects from current task's OBJECTQ
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "STATUS" - GET OBJECT STATUS
 AH = 12h
 BH = 0Fh
 BL = object
     00h handle is DWORD on top of stack
  timer: is it running?
  pointer: return status of last message
  panel: verify success of last OPEN or APPLY
     02h return status of last msg READ from mailbox (handle on stack)
     03h return status of last msg READ from task's default mailbox
     04h get scan code for last key read from KEYBOARD (handle on stack)
     05h get scan code for last key read from task's default KEYBOARD
     06h return whether OBJECTQ is open or not (handle on top of stack)
     07h return whether task's default OBJECTQ is open or not
Return: DWORD on top of stack is status
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "EOF" - GET OBJECT EOF STATUS
 AH = 12h
 BH = 10h
 BL = object
     00h handle is DWORD on top of stack
     01h returns TRUE if logical cursor past end of task's def window
Return: DWORD on top of stack is status
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "AT" - POSITION OBJECT CURSOR
 AH = 12h
 BH = 11h
 BL = object
     00h handle is DWORD on top of stack
     01h position logical cursor on task's default window
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SETSCALE" - SET POINTER SCALE FACTOR
 AH = 12h
 BX = 1100h
 STACK: DWORD object handle for pointer object
        DWORD ???
        DWORD ???
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "READN" - GET NEXT N OBJECT BYTES
 AH = 12h
 BH = 12h
 BL = object
     00h handle is DWORD on top of stack
     01h read next N chars/attributes on task's default window
 STACK: DWORD count
Return: STACK: DWORD count actually read
        DWORD address
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "GETSCALE" - GET POINTER SCALE FACTOR
 AH = 12h
 BX = 1200h
 STACK: DWORD object handle for pointer
Return: STACK: DWORD ???
        DWORD ???
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "REDRAW" - REDRAW WINDOW
 AH = 12h
 BH = 13h
 BL = object
     00h DWORD on top of stack is handle for window to redraw
     01h redraw task's default window
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SETICON" - SPECIFY POINTER ICON
 AH = 12h
 BX = 1300h
 STACK: DWORD object handle for pointer
        ???
-----------------------------------------------------------
INT 15 - TopView - SEND MESSAGE - "SETESC" - SET ESCAPE ROUTINE ADDRESS
 AH = 12h
 BH = 14h
 BL = message modifier
     00h handle is DWORD on top of stack
     04h intercept keystrokes from KEYBOARD to a window (handle on stack)
     05h intercept keystrokes from task's default KEYBOARD to a window
-----------------------------------------------------------
INT 15 - PRINT.COM - ??? (AT,XT286,PS50+)
 AH = 20h
 AL = subfunction
     00h ???
     01h ???
     10h setup of SYSREQ routine (OS hook)
     11h completion of SYSREQ function (OS hook)
Note: AL = 0,1 set or reset some flags which affect what PRINT does when it
      tries to access the disk
-----------------------------------------------------------
INT 15 - SYSTEM - POWER-ON SELF-TEST ERROR LOG (PS50+)
 AH = 21h
 ???
Return: ???
-----------------------------------------------------------
INT 15 - READ/MODIFY PROFILES (CONVERTIBLE)
 AH = 40h
 AL = subfunction
     0: get system profile in CX and BX
     1: set system profile from CX and BX
     2: get internal modem profile in BX
     3: set internal modem profile from BX
-----------------------------------------------------------
INT 15 - SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE)
 AH = 41h
 AL = condition type
     bits 0-2: condition to wait for
       0 any external event
       1 compare and return if equal
       2 compare and return if not equal
       3 test and return if not zero
       4 test and return if zero
     bit 3:    reserved
     bit 4:    1=port address, 0=user byte
     bits 5-7: reserved
 BH = condition compare or mask value
 BL = timeout value times 55 milliseconds
     0 means no timeout
 DX = I/O port address if AL bit 4 set
 ES:DI = pointer to user byte if AL bit 4 clear
-----------------------------------------------------------
INT 15 - SYSTEM - REQUEST POWER OFF (CONVERTIBLE)
 AH = 42h
 AL = 0 to use system profile
      1 to force suspend regardless of system profile
-----------------------------------------------------------
INT 15 - SYSTEM - READ SYSTEM STATUS (CONVERTIBLE)
 AH = 43h
Return: AL = status bits
     bit 0: LCD detached
     bit 1: reserved
     bit 2: RS232/parallel adapter powered on
     bit 3: internal modem powered on
     bit 4: power activated by alarm
     bit 5: standby power lost
     bit 6: external power in use
     bit 7: power low
-----------------------------------------------------------
INT 15 - SYSTEM - (DE)ACTIVATE INTERNAL MODEM POWER (CONVERTIBLE)
 AH = 44h
 AL = 0 to power off
      1 to power on
-----------------------------------------------------------
INT 15 - OS HOOK - KEYBOARD INTERCEPT (AT model 3x9,XT2,XT286,CONV,PS)
 AH = 4Fh
 AL = scan code
 CF set
Return: AL = scan code
 CF set
Note: Called by INT 9 handler to translate scan codes
-----------------------------------------------------------
INT 15 - OS HOOK - DEVICE OPEN (AT,XT2,XT286,PS)
 AH = 80h
 BX = device ID
 CX = process type
-----------------------------------------------------------
INT 15 - OS HOOK - DEVICE CLOSE (AT,XT2,XT286,PS)
 AH = 81h
 BX = device ID
 CX = process type
-----------------------------------------------------------
INT 15 - OS HOOK - DEVICE PROGRAM TERMINATE (AT,XT2,XT286,PS)
 AH = 82h
 BX = device ID
-----------------------------------------------------------
INT 15 - SYSTEM - EVENT WAIT (AT,XT286,CONV,PS)
 AH = 83h
 AL = subservice
     0 = set interval
     1 = cancel
 ES:BX = pointer to event flag (bit 7 set when interval expires)
 CX:DX = number of microseconds to wait (only accurate to 977 us)
Return: CF set if function already busy
-----------------------------------------------------------
INT 15 - SYSTEM - READ JOYSTICK (AT,XT2,XT286,PS)
 AH = 84h
 DX = subservice
     0 get switch settings
       Return: AL = switch settings (bits 7-4)
     1 read joystick inputs
       Return: AX = A(x) value
        BX = A(y) value
        CX = B(x) value
        DX = B(y) value
-----------------------------------------------------------
INT 15 - OS HOOK - SYSTEM REQUEST KEY PRESSED (AT,XT2,XT286,CONV,PS)
 AH = 85h
 AL = 0 press
    = 1 release
Note: called by keyboard decode routine
-----------------------------------------------------------
INT 15 - SYSTEM - WAIT (AT,XT2,XT286,CONV,PS)
 AH = 86h
 CX,DX = number of microseconds to wait (only accurate to 977 us)
Return: after wait elapses
-----------------------------------------------------------
INT 15 - EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)
 AH = 87h
 CX = number of words to move
 ES:SI = pointer to global descriptor table
        offset 0h  null descriptor (need not be initialized)
        8h  uninitialized, will be made into GDT descriptor
       10h  descriptor for source of move
       18h  descriptor for destination of move
       20h  uninitialized, used by BIOS
       28h  uninitialized, will be made into SS descriptor
Return: source copied into destination
-----------------------------------------------------------
INT 15 - EXTENDED MEMORY - GET MEMORY SIZE (AT,XT286,PS)
 AH = 88h
Return: AX = memory size
-----------------------------------------------------------
INT 15 - SYSTEM - SWITCH TO VIRTUAL MODE (AT,XT286,PS50+)
 AH = 89h
 BL = interrupt number of IRQ0 (IRQ1-7 use next 7 interrupts)
 BH = interrupt number of IRQ8 (IRQ9-F use next 7 interrupts)
 DS:SI = pointer to GDT for protected mode
        offset 0h  null descriptor
        8h  GDT descriptor
       10h  IDT descriptor
       18h  DS
       20h  ES
       28h  SS
       30h  CS
       38h  uninitialized, used to build descriptor for BIOS CS
 CX = offset into protected-mode CS to jump to
Return: CF set on error
    AH = 0FFh  error enabling address line 20
-----------------------------------------------------------
INT 15 - OS HOOK - DEVICE BUSY LOOP (AT,XT2,XT286,CONV,PS)
 AH = 90h
 AL = TYPE CODE
     00h: disk
     01h: diskette
     02h: keyboard
     80h: network
  ES:BX = NCB
     FCh: disk reset
     FDh: diskette motor start
     FEh: printer
Return: CF set if wait time satisfied
Note: type codes are allocated as follows:
 00-7F non-reentrant devices; OS must arbitrate access
 80-BF reentrant devices; ES:BX points to a unique control block
 C0-FF wait-only calls, no complementary INT 15/AH=91h call
-----------------------------------------------------------
INT 15 - OS HOOK - SET FLAG AND COMPLETE INTERRUPT (AT,XT2,XT286,CONV,PS)
 AH = 91h
 AL = type code, see AH=90h above
-----------------------------------------------------------
INT 15 - SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
 AH = C0h
Return: CF = 1 if BIOS doesn't support call
 ES:BX pointer to ROM table
      byte_count  dw   ?   ; number of bytes following
      model  db   ?   ; PC=ff, XT=fe or fb, PCjr = fd, etc, etc
      submodel  db   ?   ; distingushes between AT and XT/286, etc.
      BIOS_rev  db   ?   ; 0 for first release, 1 for 2nd, etc.
      featbyte  db   ?   ; 80h = DMA channel 3 used by hd BIOS
      ; 40h = 2nd 8259 installed
      ; 20h = Real-Time Clock installed
      ; 10h = INT 15h/AH=4Fh called upon INT 9h
      ;  8h = wait for external event supported
      ;  4h = extended BIOS area allocated at 640K
      ;  2h = bus is Micro Channel instead of PC
      ;  1h   reserved
      res1  dw   0
      res2  dw   0
Note: the 1/10/86 XT BIOS returns an incorrect value for featbyte.
-----------------------------------------------------------
INT 15 - SYSTEM - RETURN EXTENDED-BIOS DATA-AREA SEGMENT ADDRESS (PS)
 AH = C1h
 ???
Return: ???
-----------------------------------------------------------
INT 15 - POINTING DEVICE BIOS INTERFACE (PS)
 AH = C2h
 ???
Return: ???
-----------------------------------------------------------
INT 15 - DESQview - ???
 AH = C2h
 AL = subfunction
     00h ???
        BH = ???
     01h set something to default values
     02h ???
        BH = ???
     03h ???
        BH = ???
     04h NOP, points to RET instruction
     05h same as 01h, but also takes input value in BH
        BH = ???
     06h ???
        BH = 01h or 02h stored, otherwise ignored
     07h ???
        ES:BX = pointer to ???
        Return: AL = 00h
Note: the values in BH for those functions that take it as input are stored
      in different locations for each subfunction
----------------------------------------------------------
INT 15 - ENABLE/DISABLE WATCHDOG TIMEOUT (PS50+)
 AH = C3h
 ???
Return: ???
-----------------------------------------------------------
INT 15 - PROGRAMMABLE OPTION SELECT (PS50+)
 AH = C4h
 ???
Return: ???
-----------------------------------------------------------
INT 15 - DESQview - GET PROGRAM NAME
 AX = DE00h
Return: AX = offset into DESQVIEW.DVO of current program:
        BYTE  length of name
      N BYTES name
      2 BYTES keys to invoke program (second = 00h if only one key used)
      3 BYTES ??? (I see 0 always)
-----------------------------------------------------------
INT 15 - DESQview - UPDATE OPEN MENU???
 AX = DE01h
 ???
Return: nothing
Note: reads DESQVIEW.DVO, disables Open menu if file not in current directory
-----------------------------------------------------------
INT 15 - DESQview - UNIMPLEMENTED IN DV 2.00
 AX = DE02h
Return: nothing (NOP in DV 2.00)
-----------------------------------------------------------
INT 15 - DESQview - UNIMPLEMENTED IN DV 2.00
 AX = DE03h
Return: nothing (NOP in DV 2.00)
-----------------------------------------------------------
INT 15 - DESQview - GET AVAILABLE COMMON MEMORY
 AX = DE04h
Return: BX = bytes of common memory available
 CX = largest block available
 DX = total common memory in bytes
-----------------------------------------------------------
INT 15 - DESQview - GET AVAILABLE CONVENTIONAL MEMORY
 AX = DE05h
Return: BX = K of memory available
 CX = largest block available
 DX = total conventional memory in K
-----------------------------------------------------------
INT 15 - DESQview - GET AVAILABLE EXPANDED MEMORY
 AX = DE06h
Return: BX = K of expanded memory available
 CX = largest block available
 DX = total expanded memory in K
-----------------------------------------------------------
INT 15 - DESQview - "APPNUM" - GET CURRENT PROGRAM'S NUMBER
 AX = DE07h
Return: AX = number of program as it appears on the "Switch Windows" menu
-----------------------------------------------------------
INT 15 - DESQview - GET ???
 AX = DE08h
Return: AX = 0 ???
      1 ???
-----------------------------------------------------------
INT 15 - DESQview - UNIMPLEMENTED IN DV 2.00
 AX = DE09h
Return: nothing (NOP in DV 2.00)
-----------------------------------------------------------
INT 15 - DESQview 2.0 - "DBGPOKE" - DISPLAY CHARACTER ON STATUS LINE
 AX = DE0Ah
 BL = character
Return: character displayed, next call will display in next position (which
 wraps back to the start of the line if off the right edge of screen)
Notes: displays character on bottom line of *physical* screen, regardless
 of current size of window (even entirely hidden)
 does not know about graphics display modes, just pokes the characters
 into display memory
-----------------------------------------------------------
INT 15 - DESQview 2.0 - "APILEVEL" - DEFINE MINIMUM API LEVEL REQUIRED
 AX = DE0Bh
 BL = API level
      >2 pops up "You need a newer version" error window in DV 2.00
 BH = ???
Return: ???
-----------------------------------------------------------
INT 15 - DESQview 2.0 - "GETMEM" - ALLOCATE "SYSTEM" MEMORY
 AX = DE0Ch
 BX = number of bytes
Return: ES:DI = pointer to allocated block
-----------------------------------------------------------
INT 15 - DESQview 2.0 - "PUTMEM" - DEALLOCATE "SYSTEM" MEMORY
 AX = DE0Dh
 ES:DI = pointer to previously allocated block
Return: nothing
-----------------------------------------------------------
INT 15 - DESQview 2.0 - FIND MAILBOX BY NAME???
 AX = DE0Eh
 ES:DI = pointer to string
 CX = length of name
Return: BX = 0 not found
      1 found
  DS:SI = object handle???
-----------------------------------------------------------
INT 15 - DESQview 2.0 - ???
 AX = DE0Fh
Return: AX and BX destroyed (seems to be bug, weren't saved&restored)
Note: sends a manager stream with opcodes AEh, BDh, and BFh to task's window
-----------------------------------------------------------
INT 15 - DESQview 2.0 - "PUSHKEY" - PUT KEY INTO KEYBOARD INPUT STREAM
 AX = DE10h
 BH = scan code
 BL = character
Return: BX = ??? (sometimes, but not always, same as BX passed in)
Note: a later read will get the keystroke as if it had been typed by the user
-----------------------------------------------------------
INT 15 - DESQview 2.0 - ENABLE/DISABLE AUTOMATIC JUSTIFICATION OF WINDOW
 AX = DE11h
 BL = 0        viewport will not move automatically
      nonzero  viewport will move to keep cursor visible
Return: nothing
-----------------------------------------------------------
INT 16 - KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
 AH = 00h
Return: AH = scan code
 AL = character
-----------------------------------------------------------
INT 16 - KEYBOARD - CHECK BUFFER, DO NOT CLEAR
 AH = 01h
Return: ZF = 0 character in buffer
     AH = scan code
     AL = character
 ZF = 1 no character in buffer
-----------------------------------------------------------
INT 16 - KEYBOARD - GET SHIFT STATUS
 AH = 02h
 AL = shift status bits
     0 = right shift key depressed
     1 = left shift key depressed
     2 = CTRL depressed
     3 = ALT depressed
     4 = SCROLL LOCK active
     5 = NUM LOCK active
     6 = CAPS LOCK active
     7 = INSERT state active
-----------------------------------------------------------
INT 16 - KEYBOARD - SET DELAYS (Jr,AT model 339,XT286,PS)
 AH = 03h
 AL = subfunction
     0 reset typematic (PCjr)
     1 increase initial delay (PCjr)
     2 increase continuing delay (PCjr)
     3 increase both delays (PCjr)
     4 turn off typematic (PCjr)
     5 Set typematic rate (AT or PS/2)
 BH = 00 - 03 for delays of 250ms, 500ms, 750ms, or 1s
 BL = 00 - 1F for typematic rates of 30cps down to 2cps
-----------------------------------------------------------
INT 16 - KEYBOARD - KEYCLICK (Jr,CONV)
 AH = 04h
 AL =
     0 click off
     1 click on
-----------------------------------------------------------
INT 16 - KEYBOARD - WRITE TO KEYBOARD BUFFER (AT model 339,XT2,XT286,PS)
 AH = 05h
 CH = scan code
 CL = character
Return: AL = 1 if buffer full
-----------------------------------------------------------
INT 16 - KEYBOARD - GET ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS)
 AH = 10h
Return: AH = scan code
 AL = character
-----------------------------------------------------------
INT 16 - KEYBOARD - CHECK ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS)
 AH = 11h
Return: ZF = 0 if keystroke available
     AH = scan code \ meaningless if ZF = 1
     AL = character /
 ZF = 1 if kbd buffer empty
-----------------------------------------------------------
INT 16 - KEYBOARD - GET ENHANCED SHIFT FLAGS (AT model 339,XT2,XT286,PS)
 AH = 12h
Return: AL (same as for AH=02h)
    bit 7: Ins ON
    bit 6: CapsLock ON
    bit 5: NumLock ON
    bit 4: ScrollLock ON
    bit 3: Either ALT key down
    bit 2: Either CTRL key down
    bit 1: Left shift key down
    bit 0: Right shift key down
 AH
    bit 7: SysReq key down
    bit 6: CapsLock key down
    bit 5: NumLock key down
    bit 4: ScrollLock key down
    bit 3: Right Alt key down
    bit 2: Right Ctrl key down
    bit 1: Left Alt key down
    bit 0: Right Alt key down
-----------------------------------------------------------
INT 17 - PRINTER - OUTPUT CHARACTER
 AH = 00h
 AL = character
Return: AH = status bits
     0 = time out
     1 = unused
     2 = unused
     3 = I/O error
     4 = selected
     5 = out of paper
     6 = acknowledge
     7 = not busy
-----------------------------------------------------------
INT 17 - PRINTER - INITIALIZE
 AH = 01h
Return: AH = status (see AH = 00h above)
-----------------------------------------------------------
INT 17 - PRINTER - GET STATUS
 AH = 02h
Return: AH = status (see AH = 00h above)
-----------------------------------------------------------
INT 18 - TRANSFER TO ROM BASIC
   causes transfer to ROM-based BASIC (IBM-PC)
   often reboots a compatible; often has no effect at all
-----------------------------------------------------------
INT 19 - DISK BOOT
   causes reboot of disk system (no memory test performed)
-----------------------------------------------------------
INT 1A - CLOCK - GET TIME OF DAY
 AH = 00h
Return: CX:DX = clock count
 AL = 0 if clock was read or written (via AH=0,1)
        within the current 24-hour period
        Otherwise, AL > 0
-----------------------------------------------------------
INT 1A - CLOCK - SET TIME OF DAY
 AH = 01h
 CX:DX = clock count
Return: time of day set
-----------------------------------------------------------
INT 1A - CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)
 AH = 02h
Return: CH = hours
 CL = minutes
 DH = seconds
-----------------------------------------------------------
INT 1A - CLOCK - SET REAL TIME CLOCK (AT,XT286,CONV,PS)
 AH = 03h
 CH = hours
 CL = minutes
 DH = seconds
 DL = 1, if daylight savings; 0 if standard time
Return: CMOS clock set
-----------------------------------------------------------
INT 1A - CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
 AH = 04h
Return: DL = day
 DH = month
 CL = year
 CH = century (19 or 20)
-----------------------------------------------------------
INT 1A - CLOCK - SET DATE IN REAL TIME CLOCK (AT,XT286,CONV,PS)
 AH = 05h
 DL = day
 DH = month
 CL = year
 CH = century (19 or 20)
Return: CMOS clock set
-----------------------------------------------------------
INT 1A - CLOCK - SET ALARM (AT,XT286,CONV,PS)
 AH = 06h
 CH = hours
 CL = minutes
 DH = seconds
Return: CF set if alarm already set or clock inoperable
 INT 4Ah will be called when alarm goes off
-----------------------------------------------------------
INT 1A - CLOCK - RESET ALARM (AT,XT286,CONV,PS)
 AH = 07h
Return: alarm disabled
-----------------------------------------------------------
INT 1A - CLOCK - SET RTC ACTIVATED POWER ON MODE (CONVERTIBLE)
 AH = 08h
 CH = hours in BCD
 CL = minutes in BCD
 DH = seconds in BCD
-----------------------------------------------------------
INT 1A - CLOCK - READ RTC ALARM TIME AND STATUS (CONV,PS30)
 AH = 09h
Return: CH = hours in BCD
 CL = minutes in BCD
 DH = seconds in BCD
 DL = alarm status
     0  alarm not enabled
     1  alarm enabled but will not power up system
     2  alarm will power up system
-----------------------------------------------------------
INT 1A - CLOCK - READ SYSTEM-TIMER DAY COUNTER (XT2,PS)
 AH = 0Ah
 ???
Return: ???
-----------------------------------------------------------
INT 1A - CLOCK - SET SYSTEM-TIMER DAY COUNTER (XT2,PS)
 AH = 0Bh
 ???
Return: ???
-----------------------------------------------------------
INT 1A - SET UP SOUND MULTIPLEXOR (PCjr ONLY)
 AH = 80h
 AL = 0 source is 8253 channel 2
      1 source is cassette input
      2 source is I/O channel "Audio IN"
      3 source is sound generator chip
-----------------------------------------------------------
INT 1B - CTRL-BREAK KEY
   This interrupt is called when the keyboard scanner of the IBM
   machines detects CTRL and BREAK pressed at the same time. It
   normally points to a short routine in DOS which sets the
   Ctrl-C flag, thus invoking INT 23h the next time DOS checks
   for Ctrl-C.
-----------------------------------------------------------
INT 1C - CLOCK TICK
   This interrupt is called (in the IBM) at the end of each time-update
   operation by the time-of-day routines.  It normally points to an IRET.
-----------------------------------------------------------
INT 1D -> 6845 VIDEO INIT TABLES
 table for modes 0 and 1   \
 table for modes 2 and 3    \ each table is 16 bytes long and
 table for modes 4,5, and 6 / contains values for 6845 registers
 table for mode 7   /
 4 words -- size of video RAM for modes 0/1, 2/3, 4/5, and 6/7
 8 bytes -- number of columns in each mode
 8 bytes -- video controller mode byte for each mode
-----------------------------------------------------------
INT 1E -> DISKETTE PARAMS (BASE TABLE)
 (Default at F000:EFC7 in PC and most compatibles)
 DB step rate & head unload times
 DB head load time & DMA
 DB motor off time in clock ticks (36 or 37 typical)
 DB sector size in bytes (0->128, 1->256, 2->512, 3->1024)
 DB last sector number (8 or 9 typical)
 DB inter-sector gap size on read/write (42 typical)
 DB data transfer length (255 typical)
 DB inter-sector gap size on format (80 typical)
 DB sector fill on format (F6h typical)
 DB head-settle time ms (typical 25, 1.10->0, 2.10->15, 3.10->1)
 DB motor start-up time (1/8 secs) (typical 4, 2.10->2)
-----------------------------------------------------------
INT 1F -> GRAPHICS SET 2
       (NOT a vector!) pointer to bitmaps for high 128 chars
-----------------------------------------------------------
INT 20 - Minix - SEND/RECEIVE MESSAGE
 AX = process ID of other process
 BX = pointer to message
 CX = 1 send
      2 receive
      3 send&receive
Note: the message contains the system call number (numbered as in V7 Unix(tm))
      and the call parameters
-----------------------------------------------------------
INT 20 - DOS - PROGRAM TERMINATION
returns to DOS--identical to INT 21/AH=00h
-----------------------------------------------------------
INT 21 - DOS - PROGRAM TERMINATION
 AH = 00h
Return: never
-----------------------------------------------------------
INT 21 - DOS - KEYBOARD INPUT
 AH = 01h
Return: AL = character read
Note: ^C/^Break are checked, and INT 23h executed if read
-----------------------------------------------------------
INT 21 - DOS - DISPLAY OUTPUT
 AH = 02h
 DL = character
-----------------------------------------------------------
INT 21 - DOS - AUX INPUT
 AH = 03h
Return: AL = character read
-----------------------------------------------------------
INT 21 - DOS - AUX OUTPUT
 AH = 04h
 DL = character to send
-----------------------------------------------------------
INT 21 - DOS - PRINTER OUTPUT
 AH = 05h
 DL = character to print
-----------------------------------------------------------
INT 21 - DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
 AH = 06h
 DL = character <> FFh
-----------------------------------------------------------
INT 21 - DOS - DIRECT CONSOLE I/O CHARACTER INPUT
 AH = 06h
 DL = 0FFh
Return: ZF set  = no character
 ZF clear = character recieved
    AL = character
Notes: Character is echoed to STDOUT if received.
       ^C/^Break are NOT checked
-----------------------------------------------------------
INT 21 - DOS - DIRECT STDIN INPUT, NO ECHO
 AH = 07h
Note: same as function 06h for input but char not echoed
-----------------------------------------------------------
INT 21 - DOS - KEYBOARD INPUT, NO ECHO
 AH = 08h
Return: AL = character
Note: same as function 07h, but ^C/^Break are checked
-----------------------------------------------------------
INT 21 - DOS - PRINT STRING
 AH = 09h
 DS:DX = address of string terminated by "$"
-----------------------------------------------------------
INT 21 - DOS - BUFFERED KEYBOARD INPUT
 AH = 0Ah
 DS:DX = address of buffer
Note: first byte of buffer must contain maximum length
      on entry, second byte contains actual length of previous line which may
 be recalled with the DOS line-editing commands
      on return the second byte contains actual length, third and
 subsequent bytes contain the input line
-----------------------------------------------------------
INT 21 - DOS - CHECK STANDARD INPUT STATUS
 AH = 0Bh
Return: AL = FFh if character available
      00h if no character
-----------------------------------------------------------
INT 21 - DOS - CLEAR KEYBOARD BUFFER
 AH = 0Ch
 AL must be 1, 6, 7, 8, or 0Ah.
Notes: Flushes all typeahead input, then executes function specified by AL
       (effectively moving it to AH and repeating the INT 21 call).
       If AL contains a value not in the list above, the keyboard buffer is
       flushed and no other action is taken.
-----------------------------------------------------------
INT 21 - DOS - DISK RESET
 AH = 0Dh
Note: Flushes all disk buffers.
-----------------------------------------------------------
INT 21 - DOS - SELECT DISK
 AH = 0Eh
 DL = new default drive number (0 = A, 1 = B, etc.)
Return: AL = number of logical drives
-----------------------------------------------------------
INT 21 - DOS - OPEN DISK FILE
 AH = 0Fh
 DS:DX = address of FCB
Return: AL = 00h file found
      FFh file not found
-----------------------------------------------------------
INT 21 - DOS - CLOSE DISK FILE
 AH = 10h
 DS:DX = address of FCB
Return: AL = 00h directory update successful
      FFh file not found in directory
-----------------------------------------------------------
INT 21 - DOS - SEARCH FIRST USING FCB
 AH = 11h
 DS:DX = address of FCB
Return: AL = status
     00h file found
     FFh file not found
Note: If file found, FCB is created at DTA address and set up to
      OPEN or DELETE it.
-----------------------------------------------------------
INT 21 - DOS - SEARCH NEXT USING FCB
 AH = 12h
 DS:DX = address of FCB
Return: AL = status
     00h file found
     FFh file not found
Note: If file found, FCB is created at DTA address and set up to
      OPEN or DELETE it.
-----------------------------------------------------------
INT 21 - DOS - DELETE FILE via FCB
 AH = 13h
 DS:DX = address of FCB
Return: AL = status
     00h file found
     FFh file not found
-----------------------------------------------------------
INT 21 - DOS - SEQUENTIAL DISK FILE READ
 AH = 14h
 DS:DX = address of FCB
Return: AL = status
     0 successful read
     1 end of file
     2 data transfer area too small
     3 partial record, EOF
-----------------------------------------------------------
INT 21 - DOS - SEQUENTIAL DISK RECORD WRITE
 AH = 15h
 DS:DX = address of FCB
Return: AL = status
     0 successful write
     1 disk full
     2 data transfer area too small
-----------------------------------------------------------
INT 21 - DOS - CREATE A DISK FILE
 AH = 16h
 DS:DX = address of FCB
Return: AL = status
     00h successful creation
     FFh directory full
-----------------------------------------------------------
INT 21 - DOS - RENAME FILE via FCB
 AH = 17h
 DS:DX = address of FCB
 FCB contains new name starting at byte 17h.
Return: AL = status
     00h file found
     FFh file not found
-----------------------------------------------------------
INT 21 - DOS Internal - UNUSED
 AH = 18h
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS - GET DEFAULT DISK NUMBER
 AH = 19h
Return: AL = current drive number (letter - 'A')
-----------------------------------------------------------
INT 21 - DOS - SET DISK TRANSFER AREA ADDRESS
 AH = 1Ah
 DS:DX = address of buffer
-----------------------------------------------------------
INT 21 - DOS - GET DEFAULT DRIVE DISK SIZE
 AH = 1Bh
Return: DS:BX points to FAT ID byte
 DX = number of allocation units on disk
 AL = number of sectors per allocation unit (cluster)
 CX = number of bytes per sector
-----------------------------------------------------------
INT 21 - DOS - GET SPECIFIC DRIVE'S DISK SIZE
 AH = 1Ch
 DL = Drive Number to check
Return: DS:BX points to FAT ID byte
 DX = number of allocation units on disk
 AL = number of sectors per allocation unit (cluster)
 CX = number of bytes per sector
-----------------------------------------------------------
INT 21 - DOS Internal - UNUSED
 AH = 1Dh
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS Internal - UNUSED
 AH = 1Eh
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS Internal - GET DEFAULT DRIVE PARAMETER BLOCK
 AH = 1Fh
Return: AL = 00h No Error
      FFh Error
 DS:BX = pointer to drive parameter block
Note: for DOS 2.x and 3.x, this just invokes function 32h with DL = 0
-----------------------------------------------------------
INT 21 - DOS Internal - UNUSED
 AH = 20h
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS - RANDOM DISK RECORD READ
 AH = 21h
 DS:DX = address of FCB
Return: AL = status
     0 successful read
     1 end of file
     2 data transfer area too small
     3 partial record, EOF
-----------------------------------------------------------
INT 21 - DOS - RANDOM DISK RECORD WRITE
 AH = 22h
 DS:DX = address of FCB
Return: AL = status (see AH = 21h above)
-----------------------------------------------------------
INT 21 - DOS - GET FILE SIZE
 AH = 23h
 DS:DX = address of FCB
Return: AL = status
     00h file found
     FFh file not found
Note: FCB set to number of records
-----------------------------------------------------------
INT 21 - DOS - SET RANDOM RECORD FIELD
 AH = 24h
 DS:DX = address of FCB
Return: Random Record Field of FCB is set to be same as Current Block
 and Current Record.
Note: FCB must be OPEN already
-----------------------------------------------------------
INT 21 - DOS - SET INTERRUPT VECTOR
 AH = 25h
 AL = interrupt number
 DS:DX = new vector to be used for specified interrupt
-----------------------------------------------------------
INT 21 - DOS - CREATE PSP
 AH = 26h
 DX = Segment number to set up PSP at
Return: Current PSP is copied to specified segment
-----------------------------------------------------------
INT 21 - DOS - RANDOM BLOCK READ
 AH = 27h
 DS:DX = address of FCB
 CX = number of records to be read
Return: AL = status
     0 successful read
     1 end of file
     2 data transfer area too small
     3 partial record, EOF
-----------------------------------------------------------
INT 21 - DOS - RANDOM BLOCK WRITE
 AH = 28h
 DS:DX = address of FCB
 CX = number of records to be written
      if zero, truncate file to current random file position
Return: AL = status
     0 successful write
     1 disk full
     2 data transfer area too small
-----------------------------------------------------------
INT 21 - DOS - PARSE FILENAME
 AH = 29h
 DS:SI = pointer to string to parse
 ES:DI = pointer to memory to fill with unopened FCB
 AL = bit mask to control parsing
     0 = 0: parsing stops if file separator found
  1: leading separator ignored
     1 = 0: drive number in FCB set to default drive if not present
     in string
  1: drive number in FCB not changed
     2 = 0: filename in FCB set to blanks if no filename in string
  1: filename in FCB not changed if string does not contain
     a filename
     3 = 0: extension in FCB set to blanks if no extension in string
  1: extension left unchanged
Return: AL = 00: no wildcards in name or extension
      01: wildcards appeared
 DS:SI = pointer to first byte after parsed string
 ES:DI = unopened FCB
-----------------------------------------------------------
INT 21 - DOS - GET CURRENT DATE
 AH = 2Ah
Return: DL = day
 DH = month
 CX = year
 AL = day of the week (0=Sunday, 1=Monday, etc.)
-----------------------------------------------------------
INT 21 - DOS - SET CURRENT DATE
 AH = 2Bh
 DL = day
 DH = month
 CX = year
Return: AL = 00h if no error
    = FFh if bad value sent to routine
Note: DOS 3.3 also sets CMOS clock
-----------------------------------------------------------
INT 21 - DESQview - INSTALLATION CHECK
 AH = 2Bh
 AL = subfunction
     01h get version
  Return: BX = version (v2.00 returns 0002h, v2.01 returns 0201h)
     02h get shadow buffer info, and start shadowing
  Return: BH = rows in shadow buffer
   BL = columns in shadow buffer
   DX = segment of shadow buffer
     04h get shadow buffer info
  Return: BH = rows in shadow buffer
   BL = columns in shadow buffer
   DX = segment of shadow buffer
     05h stop shadowing
 CX = 4445h ('DE')
 DX = 5351h ('SQ')
Return: AL = FFh if DESQview not installed
-----------------------------------------------------------
INT 21 - DOS - GET CURRENT TIME
 AH = 2Ch
Return: CH = hours
 CL = minutes
 DH = seconds
 DL = hundredths of seconds
Note: time is updated approximately every 5/100 second
-----------------------------------------------------------
INT 21 - DOS - SET CURRENT TIME
 AH = 2Dh
 CH = hours
 CL = minutes
 DH = seconds
 DL = hundredths of seconds
Return: AL = 00h if no error
    = FFh if bad value sent to routine
Note: DOS 3.3 also sets CMOS clock
-----------------------------------------------------------
INT 21 - DOS - SET VERIFY FLAG
 AH = 2Eh
 DL = 0
 AL = 1 VERIFY on
      0 VERIFY off
-----------------------------------------------------------
INT 21 - DOS 2+ - GET DISK TRANSFER AREA ADDRESS
 AH = 2Fh
Return: ES:BX = address of DTA
-----------------------------------------------------------
INT 21 - DOS 2+ - GET DOS VERSION
 AH = 30h
Return: AL = Major Version number
 AH = Minor Version number
 BH = OEM number
     00h IBM
     16h DEC
 BL:CX = 24-bit user number
-----------------------------------------------------------
INT 21 - DOS 2+ - TERMINATE BUT STAY RESIDENT
 AH = 31h
 AL = exit code
 DX = program size, in paragraphs
-----------------------------------------------------------
INT 21 - DOS Internal - GET DRIVE PARAMETER BLOCK
 AH = 32h
 DL = drive number
     0 = default, 1 = A, etc.
Return: AL = 0FFh if invalid drive number, else
 DS:BX = address of drive parameter block.
  STRUCTURE OF DOS DRIVE PARAMETER BLOCK:
DPBLOCK  STRUCT  ;Offset
DISK_OFFSET DB ? ;  0  drive number (0 = A, etc.)
UNIT_OFFSET DB ? ;  1  unit number within device driver
SECTOR_SIZE DW ? ;  2  number of bytes per sector
MAX_CLUSTER DB ? ;  4  largest sector number in cluster
    ;     add one for number of sectors/cluster
LOG2_SECTORS DB ? ;  5  log base two of the cluster size
RESERVED DW ? ;  6  number of reserved (boot) sectors
FAT_COUNT DB ? ;  8  number of copies of the FAT
ROOT_COUNT DW ? ;  9  number of root directory entries
DATA_START DW ? ; 11  first data sector on medium
MAX_NUMBER DW ? ; 13  largest possible cluster number
    ;     subtract one for number of data clusters
FAT_SECTORS DB ? ; 15  number of sectors in one FAT copy
ROOT_START DW ? ; 16  first sector of root directory
DEVICE_ADDR DD ? ; 18  address of device driver for this drive
DESCRIPTOR DB ? ; 22  media descriptor byte for medium
VALID_BYTE DB ? ; 23  0FFh indicates block must be rebuilt
NEXT_BLOCK DD ? ; 24  address of next device block in list
; from this point on, DOS 3 differs from DOS 2:
  IF DOS2
DIR_START DW ? ; 28  starting cluster of current directory
    ;     zero indicates the root directory
PATH_NAME DB 64 DUP (?)
    ; 30  ASCIZ current directory path string
  ELSE DOS3
;  on my XT, this was always:
  DW 0
  DW 0FFFFh
  ENDIF
DPBLOCK  ENDS
-----------------------------------------------------------
INT 21 - DOS 2+ - EXTENDED CONTROL-BREAK CHECKING
 AH = 33h
 AL = subfunction
     00h Get State
     01h Set
        DL = 0 for OFF or 1 for ON
     02h internal, called by PRINT.COM (DOS 3.1)
Return: DL = current BREAK setting if AL = 00h
     0 BREAK=OFF
     1 BREAK=ON
 AL = FFh if error
-----------------------------------------------------------
INT 21 - DOS Internal - RETURN CritSectFlag POINTER
 AH = 34h
Return: ES:BX points to DOS "Critical Section Flag"
Notes:
   When byte pointed to is zero, DOS is supposed to be safe to interrupt.
   NOT RELIABLE according to Chris Dunford.
   Examination of DOS 2.10 code in this area indicates that the byte
   immediately FOLLOWING this "Critical Section Flag" must be 00 to permit the
   PRINT.COM interrupt to be called.
   For DOS 3.0 and 3.1 (except COMPAQ DOS 3.0), the byte BEFORE the "Critical
   Section Flag" must be zero, and for COMPAQ DOS 3.0, the byte 01AAh before it
   must be zero.
-----------------------------------------------------------
INT 21 - DOS 2+ - GET INTERRUPT VECTOR
 AH = 35h
 AL = interrupt number
Return: ES:BX = value of interrupt vector
-----------------------------------------------------------
INT 21 - DOS 2+ - GET DISK SPACE
 AH = 36h
 DL = drive code (0 = default, 1 = A, 2 = B, etc.)
Return: AX = number of sectors per cluster
      or 0FFFFh if invalid drive
 BX = number of available clusters
 CX = bytes per sector
 DX = total clusters
Note: multiply AX x CX x BX for free space on disk
      multiply AX x CX x DX for total disk space
-----------------------------------------------------------
INT 21 - DOS Internal - SWITCHAR/AVAILDEV
 AH = 37h
 AL = subfunction
    0 Read switch character (returns current character in DL)
    1 Set switch character (specify new character in DL)
    2 (DOS 2.x only) Read device availability (as set by function AL=3)
    3 (DOS 2.x only) Set device availability, where:
      DL = 0 means /DEV/ must preceed device names
      DL <> 0 means /DEV/ need not preceed device names
Return: DL = Switch character (if AL=0 or 1)
      Device availability flag (if AL=2 or 3)
 AL=0FFh means the value in AL was not in the range 0-3.
-----------------------------------------------------------
INT 21 - DOS 2+ - GET COUNTRY-DEPENDENT INFORMATION
 AH = 38h
--DOS 2.x--
 AL = 0 get current-country info
 DS:DX = segment:offset of buffer for returned info
Return: BX = country code
 buffer at DS:DX filled as follows:
    bytes 0-1 = date format   0 = USA mm dd yy
         1 = Europe dd mm yy
         2 = Japan yy mm dd
    byte 2    = currency symbol
    byte 3    = 00h
    byte 4    = thousands separator char
    byte 5    = 00h
    byte 6    = decimal separator char
    byte 7    = 00h
    bytes 8-1Fh reserved
--DOS 3.x--
 AL = 0 for current country
 AL = 01h thru 0FEh for specific country with code <255
 AL = 0FFh for specific country with code >= 255
    BX = 16-bit country code
 DS:DX = segment:offset of buffer for returned info
 DX = 0FFFFh if setting country code, rather than getting info
Return: (if DX <> 0FFFFh)
 BX = country code
 DS:DX filled in:
       bytes 0-1 = date format (see above)
       bytes 2-6 = currency symbol string, ASCIZ
       byte 7 = thousands seaprator char
       byte 8 = 00h
       byte 9 = decimal separator char
       byte 0Ah = 00h
       byte 0Bh = date separator char
       byte 0Ch = 00h
       byte 0Dh = time separator char
       byte 0Eh = 00h
       byte 0Fh = currency format
      bit 1 = number of spaces between value and curr sym
      bit 0 = 0 if currency symbol precedes value
       1 if currency symbol follows value
       byte 10h = number of digits after decimal in currency
       byte 11h = time format
      bit 0 = 0 if 12-hour clock
       1 if 24-hour clock
       bytes 12h-15h = address of case map routine (FAR CALL)
       byte 16h = data-list separator char
       byte 17h = 00h
       bytes 18h-21h reserved
      If error:
 CF set
 AX = error code
-----------------------------------------------------------
INT 21 - DOS 2+ - CREATE A SUBDIRECTORY (MKDIR)
 AH = 39h
 DS:DX = address of ASCIZ pathname
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - REMOVE A DIRECTORY ENTRY (RMDIR)
 AH = 3Ah
 DS:DX = address of ASCIZ pathname
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - CHANGE THE CURRENT DIRECTORY (CHDIR)
 AH = 3Bh
 DS:DX = address of ASCIZ directory name
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - CREATE A FILE WITH HANDLE (CREAT)
 AH = 3Ch
 CX = attributes for file
 DS:DX = address of ASCIZ filename
Return: CF = 1 if error
     AX = Error Code
 CF = 0 successful
     AX = file handle
-----------------------------------------------------------
INT 21 - DOS 2+ - OPEN DISK FILE WITH HANDLE
 AH = 3Dh
 AL = access code
     0 = Read Only
     1 = Write Only
     2 = Read/Write
 AL bits 7-3 = file-sharing modes (DOS 3.x)
     bit 7    = inheritance flag, set for no inheritance
     bits 4-6 = sharing mode
        000 compatibility mode
        001 exclusive (deny all)
        010 write access denied (deny write)
        011 read access denied (deny read)
        100 full access permitted (deny none)
     bit 3    = reserved, should be zero
 DS:DX = address of ASCIZ filename
Return: CF = 1 if error
     AX = Error Code
 CF = 0 successful
     AX = file handle
-----------------------------------------------------------
INT 21 - DOS 2+ - CLOSE A FILE WITH HANDLE
 AH = 3Eh
 BX = file handle
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - READ FROM FILE WITH HANDLE
 AH = 3Fh
 BX = file handle
 CX = number of bytes to read
 DS:DX = address of buffer
Return: CF = 1 if error
     AX = Error Code
 CF = 0 successful
     AX = number of bytes read
-----------------------------------------------------------
INT 21 - DOS 2+ - WRITE TO FILE WITH HANDLE
 AH = 40h
 BX = file handle
 CX = number of bytes to write
 DS:DX = pointer to buffer
Return: CF = 1 if error
     AX = Error Code
 CF = 0 successful
     AX = number of bytes written
Note: if CX is zero, no data is written, and the file is truncated or extended
      to the current position
-----------------------------------------------------------
INT 21 - DOS 2+ - DELETE A FILE (UNLINK)
 AH = 41h
 DS:DX = pointer to ASCIZ name of file to delete
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 AH = 42h
 AL = method value
     0 = offset from beginning of file
     1 = offset from present location
     2 = offset from end of file
 BX = file handle
 CX:DX = offset in bytes
Return: CF = 1 if error
     AX = Error Code
 CF = 0 successful
     DX:AX = new offset
-----------------------------------------------------------
INT 21 - DOS 2+ - GET/PUT FILE ATTRIBUTES (CHMOD)
 AH = 43h
 AL =
     0 = get file attributes
     1 = put file attributes
        CX = file attribute bits
     0 = read only
     1 = hidden file
     2 = system file
     3 = volume label
     4 = subdirectory
     5 = written since backup
 DS:DX = pointer to ASCIZ file name
Return: CF = 1 if error
     AX = Error Code if any
 CX = file attributes on get
-----------------------------------------------------------
INT 21 - DOS 2+ - IOCTL
 AH = 44h
 AL =
    0 = Get device information (DX)
    1 = Set device information (DH must be 0 on entry)
        DX BITS =
   0 = console input device
   1 = console output device
   2 = null device
   3 = clock device
   5 = binary mode
   6 = EOF
   7 = device is character device if set
       if not, EOF = 0 if channel has been written
       bits 0-5 are block device number
  12 = network device
  14 = can process control strings (AL=2-5, can only be read)
  15 reserved
    2 = Read CX bytes to DS:DX from BX control channel
        Return: AX = number of bytes transferred
    3 = Write CX bytes from DS:DX from BX control channel
        Return: AX = number of bytes transferred
    4 = as 2 but for drive BL
        Return: AX = number of bytes transferred
    5 = as 3 but for drive BL
        Return: AX = number of bytes transferred
    6 = Get input status
        Return: AL = FFh for ready, 00h for not ready
    7 = Get output status
        Return: AL = FFh for ready or 00h for not ready
    8 = Is block device BL changeable? (DOS 3.x)
        Return: AX = 0 removable
       1 fixed
    9 = Is logical device BL local? (DOS 3.x)
        DX (attribute word) bit 12 (1000h) = 0 = yes
   10 = Is handle BX local? (DOS 3)
        DX (attribute word) bit 15 (8000h) = 0 = yes
   11 = Change sharing retry count to DX (def 3), (DOS 3.x)
        delay CX (def 1)
   12 = General IOCTL (DOS 3.3 [3.2?])
 BX = file handle (or BL = drive number with 0 = default)
Return: CF = 1 if error
     AX = Error Code
Note: only subfunctions 00h,06h,07h are available for files
-----------------------------------------------------------
INT 21 - DOS 2+ - CREATE DUPLICATE HANDLE (DUP)
 AH = 45h
 BX = file handle to duplicate
Return: CF = 1 if error
     AX = Error Code
 CF = 0 successful
     AX = new file handle
-----------------------------------------------------------
INT 21 - DOS 2+ - FORCE DUPLICATE HANDLE (FORCDUP,DUP2)
 AH = 46h
 BX = Existing file handle
 CX = new file handle
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - GET CURRENT DIRECTORY
 AH = 47h
 DL = drive (0=default, 1=A, etc.)
 DS:SI points to 64-byte buffer area
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - ALLOCATE MEMORY
 AH = 48h
 BX = number of 16-byte paragraphs desired
Return: CF = 1 if error
     AX = Error Code
     BX = Maximum available
 CF = 0 successful
     AX = segment of allocated memory block
-----------------------------------------------------------
INT 21 - DOS 2+ - FREE MEMORY
 AH = 49h
 ES = Segment address of area to be freed
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 AH = 4Ah
 ES = Segment address of block to change
 BX = New size in paragraphs
Return: CF = 1 if error
     AX = Error Code
     BX = Maximum size possible for the block
-----------------------------------------------------------
INT 21 - DOS 2+ - LOAD OR EXECUTE (EXEC)
 AH = 4Bh
 AL = subfunction
     0 = load and execute program
     2 = load (Internal) but do not execute
     3 = load overlay; do not create PSP
 DS:DX = filename
 ES:BX = parameter block
        AL =
  0 => WORD segment environment pointer
       DWORD command line pointer
       DWORD FCB 1
       DWORD FCB 2
  3 => WORD segment load address
       WORD segment relocation factor
Return: CF = 1 if error
     AX = Error Code
struct exec {   /* structure of .EXE file header */
 unsigned exec_magic; /* 0x4d, 0x5a signature */
 unsigned exec_isr; /* image size remainder (mod 512) */
 unsigned exec_size; /* file size in pages (512) */
 unsigned exec_nrel; /* number of relocation items */
 unsigned exec_hsize; /* header size in paragraphs */
 unsigned exec_min; /* minimum extra paragraphs */
 unsigned exec_max; /* maximum extra paragraphs */
 unsigned exec_ss; /* stack segment */
 unsigned exec_sp; /* stack offset */
 unsigned exec_cksum; /* word checksum of entire file */
 unsigned exec_pc; /* initial pc */
 unsigned exec_cs; /* code segment */
 unsigned exec_orel; /* offset of relocation table */
 unsigned exec_ovno; /* overlay number */
};
-----------------------------------------------------------
INT 21 - DOS 2+ - QUIT WITH EXIT CODE (EXIT)
 AH = 4Ch
 AL = exit code
Return: never returns
-----------------------------------------------------------
INT 21 - DOS 2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)
 AH = 4Dh
Return: AL = exit code of subprogram (functions 31h or 4Ch)
 AH = circumstance which caused termination
     0 = Terminate/abort
     1 = Control-C
     2 = Hard error
     3 = Terminate and stay resident
-----------------------------------------------------------
INT 21 - DOS 2+ - FIND FIRST ASCIZ (FIND FIRST)
 AH = 4Eh
 CX = search attributes
 DS:DX = pointer to ASCIZ filename
Return: CF = 1 if error
     AX = Error Code if any
 [DTA] = data block
       byte  00h:     drive letter (undocumented)
       bytes 01h-0Bh: search template (undocumented)
       bytes 0Ch-14h: reserved
       byte  15h:     attribute of file found
       bytes 16h-17h: file time
       bytes 18h-19h: file date
       bytes 1Ah-1Dh: file size
       bytes 1Eh-3Ah: ASCIZ filename+extension
-----------------------------------------------------------
INT 21 - DOS 2+ - FIND NEXT ASCIZ (FIND NEXT)
 AH = 4Fh
Return: CF = 1 if error
     AX = Error Code
 [DTA] = data block, see AH = 4Eh above
-----------------------------------------------------------
INT 21 - DOS Internal - SET PSP SEGMENT
 AH = 50h
 BX = Segment address of new PSP
Note: under DOS 2.xx, this function cannot be invoked inside an INT 28h handler
      without a prior call to function 5Dh
-----------------------------------------------------------
INT 21 - DOS Internal - GET PSP SEGMENT
 AH = 51h
Return: BX = Current PSP Segment
struct psp {
 char psp_int20[2]; /* 00h: exit */
 unsigned psp_msize; /* 02h: memory size in paragraphs */
 char psp_res0[1]; /* 04h: ??? (0) */
 char psp_dos[5]; /* 05h: far call to dos */
 int (*psp_term)(); /* 0ah: terminate address */
 unsigned psp_tseg; /* 0ch: terminate segment */
 int (*psp_break)(); /* 0eh: break address */
 unsigned psp_bseg; /* 10h: break segment */
 int (*psp_error)(); /* 12h: error address */
 unsigned psp_eseg; /* 14h: error segment */
 unsigned psp_ppsp; /* 16h: parent psp segment */
 char psp_ofile[20]; /* 18h: open files, 0xff = unused */
 unsigned psp_envp; /* 2ch: environment segment */
 char far *psp_oldstack; /* 2eh: far ptr to processes SS:SP??? */
 int psp_nfiles;  /* 32h: max open files */
 char *psp_aofile; /* 34h: ofile address */
 unsigned psp_aoseg; /* 36h: ofile segment */
 char psp_res3[24]; /* 38h: unused??? */
 char psp_int21[3]; /* 50h: int 21, far return */
 char psp_res4[2]; /* 53h: unused??? */
 char psp_xfcb1[7]; /* 55h: FCB #1 extension */
 char psp_fcb1[9]; /* 5ch: FCB #1 */
 char psp_xfcb2[7]; /* 65h: FCB #2 extension */
 char psp_fcb2[20]; /* 6ch: FCB #2 */
 char psp_dma[128]; /* 80h: Command Tail */
};
Note: under DOS 2.xx, this function cannot be invoked inside an INT 28h handler
      without a prior call to function 5Dh
-----------------------------------------------------------
INT 21 - DOS Internal - GET DISK LIST
 AH = 52h
Return: ES:BX points to DOS list of lists
List of Lists:
Bytes Value
-2&-1 Segment of first memory control block
0-3 Pointer to first DOS disk block (see func 36h)
4-7 ??? Partially Unknown. Pointer to a device driver. Maybe first
        resident driver?
8-B Pointer to CLOCK$ device driver, whether installable or
        resident
C-F Pointer to actual CON: device driver, whether installable
        or resident
-----DOS 2.x
10 Number of logical drives in system
11-12 Maximum bytes/block of any block device
13-16 ???
17 Beginning (not a pointer. The real beginning!) of NUL device
    driver. This is the first device on DOS's linked list
    of device drivers.
-----DOS 3.x
10-11 Maximum bytes/block of any block device (0200h)
12-15 ??? Pointer to current directory block?
16-19 Partially Undefined: Pointer to array of drive info:
        51h bytes per drive, starting with A: ...
        00-3F Current path as ASCIZ, starting with 'x:\'
        40-43 ??? I see zeros always
        44    ??? Flags? I see 40h, except for
         entry after last valid entry = 00h
        45-48 Pointer to DOS Disk Block for this drive
        49-4A ??? Current track or block? -1 if never accessed.
        4B-4E ??? I see -1 always
        4F-52 ??? I see 2 always
1A-1D ??? Pointer to data area, maybe including cluster
        allocation table?
1E-1F ??? I see zero always
20 Number of block devices.
21 Value of LASTDRIVE command in CONFIG.SYS (default 5)
22 Beginning (not a pointer. The real beginning!) of NUL device
    driver. This is the first device on DOS's linked list
    of device drivers.
-----------------------------------------------------------
INT 21 - DOS Internal - TRANSLATE BPB
 AH = 53h
 DS:SI points to BPB (Bios Parameter Block)
 ES:BP points to area for DOS Disk Block
Translates BPB (Bios Parameter Block, see below) into a DOS Disk Block
(see function call 32h).
BPB
Bytes Value
0-1 Bytes/sector. Get from DDB bytes 2-3.
2 Sectors/cluster. Get from: (DDB byte 4) + 1
3-4 Reserved sectors. Get from: DDB bytes 6-7
5 Number of FATs. Get from: DDB byte 8
6-7 Number of root dir entries. Get from: DDB bytes 9-A
8-9 Total # of sectors. Get from:
 ((DDB bytes D-E) - 1) * (sectors per cluster (BPB byte 2))
   + (DDB Bytes B-C)
A Media descriptor byte. Get from: DDB byte 16
B-C Number of sectors/FAT. Get from: DDB byte F
-----------------------------------------------------------
INT 21 - DOS 2+ - GET VERIFY FLAG
 AH = 54h
Return: AL = 0 if flag OFF
 AL = 1 if flag ON
-----------------------------------------------------------
INT 21 - DOS Internal - CREATE PSP
 AH = 55h
 DX = Segment number to set up PSP at
Note: Like func 26h but creates "child" PSP rather than copying existing one.
-----------------------------------------------------------
INT 21 - DOS 2+ - RENAME A FILE
 AH = 56h
 DS:DX = pointer to ASCIZ old name
 ES:DI = pointer to ASCIZ new name
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 2+ - GET/SET FILE'S DATE/TIME
 AH = 57h
 AL = function code
     0 = get date and time
     1 = set date and time
        CX = time to be set
        DX = date to be set
 BX = file handle
Return: CF = 1 if error
     AX = Error Code
 CX = time of last write (if AL = 0)
 DX = date of last write (if AL = 0)
-----------------------------------------------------------
INT 21 - DOS 3.x - GET/SET MEMORY ALLOCATION STRATEGY
 AH = 58h
 AL = function code
     0 = get allocation strategy
     1 = set allocation strategy
        BL = strategy code
     0 first fit (use first memory block large enough)
     1 best fit (use smallest memory block large enough)
     2 last fit (use high part of last usable memory block)
Return: CF = 1 error
     AX = Error Code
 CF = 0 successful
     AX = strategy code
Note: the Set subfunction accepts any value in BL; 2 or greater means last fit.
      the Get subfunction returns the last value set, so programs should check
      whether the value is >= 2, not just equal to 2.
-----------------------------------------------------------
INT 21 - DOS 3.x - GET EXTENDED ERROR CODE
 AH = 59h
 BX = version code (0000 for DOS 3.0)
Return: AX = extended error code
 BH = class of error
 BL = suggested action code
 CH = locus (where error occurred)
Error codes:
 01 function number invalid
 02 file not found
 03 path not found
 04 too many open files
 05 access denied
 06 invalid handle
 07 memory control block destroyed
 08 insufficient memory
 09 memory block address invalid
 0A environment invalid
 0B format invalid
 0C access code invalid
 0D data invalid
 0F invalid drive
 10 attempted to remove current directory
 11 not same device
 12 no more files
 13 disk write-protected
 14 unknown unit
 15 drive not ready
 16 unknown command
 17 data error (CRC)
 18 bad request structure length
 19 seek error
 1A unknwon media type
 1B sector not found
 1C printer out of paper
 1D write fault
 1E read fault
 1F general failure
 20 sharing violation
 21 lock violation
 22 disk change invalid
 23 FCB unavailable
 24 sharing buffer overflow
 25-31 reserved
 32 Network request not supported (DOS 3.1 + MS Networks)
 33 Remote computer not listening
 34 Duplicate name on network
 35 Network name not found
 36 Network busy
 37 Network device no longer exists
 38 Network BIOS command limit exceeded
 39 Network adapter hardware error
 3A Incorrect response from network
 3B Unexpected network error
 3C Incompatible remote adapter
 3D Print queue full
 3E Queue not full
 3F Not enough space to print file
 40 Network name was deleted
 41 Network: Access denied
 42 Network device type incorrect
 43 Network name not found
 44 Network name limit exceeded
 45 Network BIOS session limit exceeded
 46 Temporarily paused
 47 Network request not accepted
 48 Print/disk redirection paused (DOS 3.1 + MS Networks)
 49-4F reserved
 50 file exists
 51 reserved
 52 cannot make directory
 53 fail on INT 24h
Error Classes:
 01 out of resource
 02 temporary situation
 03 authorization (denied access)
 04 internal
 05 hardware failure
 06 system failure
 07 application program error
 08 not found
 09 bad format
 0A locked
 0B media error
 0C already exists
 0D unknown
Suggested Action:
 01 retry
 02 delayed retry
 03 prompt user
 04 abort after cleanup
 05 immediate abort
 06 ignore
 07 retry after user intervention
Error Locus:
 01 unknown or not appropriate
 02 block device
 03 network related
 04 serial device
 05 memory related
-----------------------------------------------------------
INT 21 - DOS 3.x - CREATE TEMPORARY FILE
 AH = 5Ah
 DS:DX = pointer to ASCIZ directory path name
 CX = file attribute
Return: CF = 1 if error
     AX = Error Code if any
 DS:DX = path name
Note: The file created is not truly "temporary".  It MUST be removed by the
      user.
-----------------------------------------------------------
INT 21 - DOS 3.x - CREATE NEW FILE
 AH = 5Bh
 DS:DX = pointer to ASCIZ directory path name
 CX = file attribute
Return: CF = 1 if error
     AX = Error Code if any
 DS:DX = path name
Note: Unlike function 3Ch, function 5Bh will fail if the file already exists.
-----------------------------------------------------------
INT 21 - DOS 3.x - LOCK/UNLOCK FILE ACCESS
 AH = 5Ch
 AL = 0 if lock
      1 if unlock
 BX = file handle
 CX:DX = starting offset of region to lock
 SI:DI = size of region to lock
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 3.x Internal - GET ADDRESS OF CRITICAL ERROR FLAG
 AX = 5D06h
Return: DS:SI = pointer to critical error flag
 CX = ???
 DX = ???
Note: this call also does a lot of other work in addition to returning the
      pointer
Note: setting CritErr flag allows use of functions 50h/51h from INT 28h under
      DOS 2.x by forcing use of correct stack
-----------------------------------------------------------
INT 21 - DOS 3.x Internal - ???
 AH = 5Dh
 AL = subfunction
      07h: ???
      08h: (used by COMMAND.COM)
      09h: (used by COMMAND.COM)
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - GET MACHINE NAME
 AX = 5E00h
 DS:DX -> buffer for ASCIZ name
Return: CF = 1 if error
     AX = Error Code
 CH = 0 if name not defined
 CL = NETBIOS name number
 DS:DX -> pointer to identifier if CH <> 0
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - SET PRINTER SETUP
 AX = 5E02h
 BX = Redirection list index
 CX = length of setup string <= 64
 DS:SI -> string buffer
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - GET PRINTER SETUP
 AX = 5E03h
 BX = Redirection list index
 ES:DI -> string buffer
Return: CF = 1 if error
     AX = Error Code
 CX = length of setup string <= 64
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - GET REDIRECTION LIST ENTRY
 AX = 5F02h
 BX = Redirection list index
 DS:SI -> 16 char local device name buffer
 ES:DI -> 128 char network name buffer
Return: CF = 1 if error
     AX = Error Code
 BH = Device status flag (BIT 0 = 0 if valid)
 BL = device type (03 if printer, 04 if drive)
 CX = stored parameter value
Note: DX and BP are destroyed by this call!
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - REDIRECT DEVICE
 AX = 5F03h
 BL = device type
  03 = printer device
  04 = file device
 CX = stored parameter value
 DS:SI -> source device name
 ES:DI -> destination ASCIZ network path + ASCIZ password
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 3.1 + Microsoft Networks - CANCEL REDIRECTION
 AX = 5F04h
 DS:SI -> device name or network path
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 21 - DOS 3.x Internal - RESOLVE PATH STRING TO FULLY QUALIFIED PATH STRING
 AH = 60h
 DI:SI = relative path strings
 ES:DI = buffer for fully qualified name
Return: buffer filled with qualified name; may return error code, unknown.
-----------------------------------------------------------
INT 21 - DOS 3.x Internal - UNUSED
 AH = 61h
Return: AL = 0
-----------------------------------------------------------
INT 21 - DOS 3.x - GET PSP ADDRESS
 AH = 62h
Return: BX = segment address of PSP
-----------------------------------------------------------
INT 21 - DOS 2.25 only - GET LEAD BYTE TABLE
 AH = 63h
 AL = subfunction
      0 = get system lead byte table
      1 = set/clear interim console flag
  DL = 1/0 to set/clear interim console flag
      2 = get interim console flag
Return: DS:SI -> lead byte table (AL = 0)
 DL = interim console flag (AL = 2)
-----------------------------------------------------------
INT 21 - DOS 3.3 Internal - ???
 AH = 64h
-----------------------------------------------------------
INT 21 - DOS 3.3 - GET EXTENDED COUNTRY INFORMATION
 AH = 65h
 AL = info ID (1 - 6)
 BX = code page (-1=global code page)
 DX = country ID (-1=current country)
 ES:DI = pointer to country information buffer
 CX = size of buffer
Return: AX = error code if carry set, otherwise
 CX = size of country information returned
 ES:DI = pointer to country information:
        1 BYTE info ID
        if info ID <> 1
    1 DWORD pointer to information
        if info ID == 1
    1 WORD size
    1 WORD country ID
    1 WORD code page
   34 BYTE see function 38h
-----------------------------------------------------------
INT 21 - DOS 3.3 - GET/SET GLOBAL CODE PAGE TABLE
 AH = 66h
 AL = 00h get global code page
      Return: AX = error code if carry flag set
       BX = active code page
       DX = system code page
    = 01h set global page
      BX = active code page
   437  US
   860  Portugal
   863  Canada (French)
   865  Norway/Denmark
      DX = system code page (active page at boot time)
      Return: AX = error code if carry flag set
-----------------------------------------------------------
INT 21 - DOS 3.3 - SET HANDLE COUNT
 AH = 67h
 BX = desired number of handles (max 255)
Return: Carry clear if ok
 Carry set if error (and error code in AX)
-----------------------------------------------------------
INT 21 - DOS 3.3 - COMMIT FILE, WRITE ALL BUFFERED DATA TO DISK
 AH = 68h
 BX = file handle
Return: carry flag set on error (and error code in AX)
-----------------------------------------------------------
INT 21 - DoubleDos - INSTALLATION CHECK
 AX = E400h
Return: AL <> 0 if DoubleDos is active
-----------------------------------------------------------
INT 21 - DoubleDos - TURN OFF TASK SWITCHING
 AH = EAh
Return: task switching turned off
-----------------------------------------------------------
INT 21 - DoubleDos - TURN ON TASK SWITCHING
 AH = EBh
Return: task switching turned on
-----------------------------------------------------------
INT 21 - DoubleDos - GET VIRTUAL SCREEN ADDRESS
 AH = ECh
Return: ES = segment of virtual screen
Note: Screen address can change if task-switching is on!!
-----------------------------------------------------------
INT 21 - DoubleDos - GIVE AWAY TIME TO OTHER TASKS
 AH = EEh
 AL = number of 55ms time slices to give away
Return: returns after giving away time slices
-----------------------------------------------------------
INT 21 - CED - INSTALLABLE COMMANDS
 AH = FFh
    AL = 0 add installable command
      BL = mode - bit 0 = 1 callable from DOS prompt
    bit 1 = 1 callable from application
      DS:SI pointer to CR-terminated command name
      ES:DI pointer to FAR routine entry point
    AL = 1 remove installable command
      DS:SI pointer to CR-terminated command name
    AL = 2 reserved, may be used to test for CED installation
Return: CF set on error
     AX = 01h invalid function
   02h command not found (subfunction 1 only)
   08h insufficient memory (subfunction 0 only)
   0Eh bad data (subfunction 0 only)
 AH = 0FFh if CED not installed
-----------------------------------------------------------
INT 22 - DOS - TERMINATE ADDRESS
   FAR (DWORD) address of routine to be executed when program "returns to DOS".
   Should NEVER be called directly.
-----------------------------------------------------------
INT 23 - DOS - CONTROL "C" EXIT ADDRESS
   Automatically called from keyboard scanner when CTRL-C or CTRL-BREAK is
   detected. Normally aborts program and returns to DOS, but may be changed.
-----------------------------------------------------------
INT 24 - DOS - FATAL ERROR HANDLER ADDRESS
   Automatically called upon detection of unrecoverable I/O error.
   Normally points to routine in resident part of COMMAND.COM that prints
   "Abort, Retry, Ignore?" message and takes the reply, but may be overridden
   if desired.
Provides the following values in registers on entry to interrupt handler:
 AH: bit 7 = 0 disk I/O error
    = 1 other error -- if block device, bad FAT
      -- if char device, code in DI
     bit 6  unused
     bit 5 = 1 if Ignore allowed, 0 if not (DOS 3.2 ???)
     bit 4 = 1 if Retry allowed, 0 if not (DOS 3.2 ???)
     bit 3 = 1 if Fail allowed, 0 if not (DOS 3.2+)
     bit 2 \ disk area of error 00 = DOS area  01 = FAT
     bit 1 /   10 = root dir  11 = data area
     bit 0 = 1 if write, 0 if read
 AL = drive number if AH bit 7 = 1, otherwise undefined
 BP:SI = address of device header for which error occurred
     block device if high bit of BP:SI+4 = 1
 low byte of DI:
    00h write-protect error
    01h unknown unit
    02h drive not ready
    03h unknown command
    04h data error (bad CRC)
    05h bad request structure length
    06h seek error
    07h unknown media type
    08h sector not found
    09h printer out of paper
    0Ah write fault
    0Bh read fault
    0Ch general failure
    0Dh (DOS 3.x) sharing violation
    0Eh (DOS 3.x) lock violation
    0Fh (DOS 3.x) invalid disk change
    10h (DOS 3.x) FCB unavailable
    11h (DOS 3.x) sharing buffer overflow
Handler must return
 AL = 00 ignore error
    = 01 retry operation
    = 02 terminate program through INT 22h
    = 03 fail system call in progress (DOS 3.2+)
-----------------------------------------------------------
INT 25 - DOS - ABSOLUTE DISK READ (except COMPAQ DOS 3.31 >32M partition)
 AL = Drive number (0=A, 1=B, etc)
 DS:BX = Disk Transfer Address (buffer)
 CX = Number of sectors to read
 DX = First relative sector to read
Return: CF = 1 if error
     AL = error code issued to INT 24h in low half of DI
     AH = 80h if attachment failed to respond
   40h if seek operation failed
   20h if controller failed
   10h if data error (bad CRC)
   08h if DMA failure
   04h if requested sector not found
   03h if write-protected disk
   02h if bad address mark
   01h if bad command
Note: ORIGINAL FLAGS ON STACK!
-----------------------------------------------------------
INT 25 - COMPAQ DOS 3.31 - ABSOLUTE DISK READ (>32M hard-disk partition)
 AL = Drive number (0=A, 1=B, etc)
 CX = FFFFh
 DS:BX = Packet address
    DWORD sector number
    WORD number of sectors to read
    DWORD transfer address
Return: same as above???
Note: partition is potentially >32M (and requires this form of the call) if
      bit 1 of device attribute word in device driver is set
-----------------------------------------------------------
INT 26 - DOS - ABSOLUTE DISK WRITE (except COMPAQ DOS 3.31 >32M partition)
 AL = Drive number (0=A, 1=B, etc)
 DS:BX = Disk Transfer Address (buffer)
 CX = Number of sectors to write
 DX = First relative sector to write
Return: CF = 1 if error
     AL = error code issued to INT 24h in low half of DI
     AH = same error codes as for INT 25h
Note: ORIGINAL FLAGS ON STACK!
-----------------------------------------------------------
INT 26 - COMPAQ DOS 3.31 - ABSOLUTE DISK WRITE (>32M hard-disk partition)
 AL = Drive number (0=A, 1=B, etc)
 CX = FFFFh
 DS:BX = Packet address
    DWORD sector number
    WORD number of sectors to write
    DWORD transfer address
Return: same as above???
Note: partition is potentially >32M (and requires this form of the call) if
      bit 1 of device attribute word in device driver is set
-----------------------------------------------------------
INT 27 - DOS - TERMINATE BUT STAY RESIDENT
 CS = current program segment
 DX = last program byte + 1
Return: never
-----------------------------------------------------------
INT 28 - DOS Internal - KEYBOARD BUSY LOOP
   This interrupt is called from inside the "get input from keyboard" routine
   in DOS, if and only if it is safe to use INT 21 to access the disk at that
   time.  It is used primarily by the PRINT.COM routines and TSR programs, but
   any number of other routines could be chained to it by saving the original
   vector, and calling it with a FAR call (or just JMPing to it) at the end of
   the new routine.
   The INT 28h handler may invoke any INT 21h function except functions 00h
   through 0Ch (and 50h/51h under DOS 2.xx unless DOS CritErr flag is set).
   Until some program installs its own routine, this interrupt vector simply
   points to an IRET opcode.
-----------------------------------------------------------
INT 29 - DOS Internal - FAST PUTCHAR
   This interrupt is called from the DOS output routines if output is going to
   a device rather than a file, and the device driver's attribute word has
   bit 3 (04h) set to "1".
-----------------------------------------------------------
INT 2A - Microsoft Networks - NETWORK INSTALLATION CHECK
 AH = 00h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2A - Microsoft Networks - CHECK DIRECT I/O
 AX = 0300h
 DS:SI -> ASCIZ disk device name
Return: CF == 0 if allowed
-----------------------------------------------------------
INT 2A - Microsoft Networks - EXECUTE NETBIOS
 AH = 04h
 AL = 0 for error retry, 1 for no retry
 ES:BX -> NCB
Return: AX = 0 for no error
 AH = 1, AL = error code
-----------------------------------------------------------
INT 2A - Microsoft Networks - GET NETWORK RESOURCE INFORMATION
 AX = 0500h
Return: AX = reserved
 BX = number of network names
 CX = number of commands
 DX = number of sessions
-----------------------------------------------------------
INT 2A - NETBIOS 1.10 - NETWORK PRINT-STREAM CONTROL
 AH = 06h
 ???
Return: ???
-----------------------------------------------------------
INT 2A - ???
 AH = 20h
 AL = 01h
 ???
Return: ???
Note: intercepted by DESQview 2.0
-----------------------------------------------------------
INT 2A - Microsoft Networks? - ???
 AH = 82h
Return: ???
Note: Called by the INT 21h function dispatcher in DOS 3.10
-----------------------------------------------------------
INT 2B - Internal routine for MSDOS (IRET)
-----------------------------------------------------------
INT 2C - Internal routine for MSDOS (IRET)
-----------------------------------------------------------
INT 2D - Internal routine for MSDOS (IRET)
-----------------------------------------------------------
INT 2E - DOS Internal - EXECUTE COMMAND
 DS:SI -> counted CR-terminated command string
The top-level command.com executes the command; all registers are destroyed
as in EXEC.
-----------------------------------------------------------
INT 2F notes
 AH identifies which program is to handle the interrupt
    00-7F reserved for DOS
    C0-FF reserved for applications
 AL is the function code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - INSTALLATION CHECK
 AX = 0100h
Return: AL =
     FFh installed
     01h not installed, not OK to install
     00h not installed, OK to install
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - SUBMIT FILE
 AX = 0101h
 DS:DX -> packet of one byte level and DWORD file pointer
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - REMOVE FILE
 AX = 0102h
 DS:DX -> file name (wildcards allowed)
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - REMOVE ALL FILES
 AX = 0103h
Return: CF = 1 if error
     AX = Error Code
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - HOLD QUEUE/GET STATUS
 AX = 0104h
Return: CF = 1 if error
     AX = Error Code
  01h function invalid
  02h file not found
  03h path not found
  04h too many open files
  05h access denied
  08h queue full
  09h spooler busy
  0Ch name too long
  0Fh drive invalid
 DX = Error count
 DS:SI -> print queue (null-string terminated
   list of 64-byte ASCIZ file names)
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT - RESTART QUEUE
 AX = 0105h
Return: Flag CF = 1 if error
 AX = Error Code if any
-----------------------------------------------------------
INT 2F - Multiplexor - ASSIGN - INSTALLATION CHECK
 AX = 0600h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - ASSIGN - ???
 AX = 0601h
 ???
Return: ???
-----------------------------------------------------------
INT 2F - Multiplexor - SHARE - ???
 AH = 10h
 AL = ???
Return: ???
-----------------------------------------------------------
INT 2F - Multiplexor - MSDOS Internal - ???
 AH = 10h
 AL =
     0     returns immediately
     nonzero sets flag in DOS, returns AX=0001 and CF=1
Note: this is without SHARE loaded, SHARE takes over this call
-----------------------------------------------------------
INT 2F - Multiplexor - MSDOS Internal - ???
 AH = 11h
 AL =
      0      returns immediately
      nonzero sets flag in DOS, returns AX=0001 and CF=1
Note: identical to AH=10h in PC-DOS 3.10 without SHARE loaded
-----------------------------------------------------------
INT 2F - Multiplexor - MSDOS Internal - ???
 AH = 12h
 ???
Note: also reads value of word on top of stack immediately before invocation
-----------------------------------------------------------
INT 2F - Multiplexor - APPEND - INSTALLATION CHECK
 AX = B700h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - APPEND - ???
 AX = B701h
 ???
-----------------------------------------------------------
INT 2F - Multiplexor - APPEND - VERSION CHECK
 AX = B702h
 ???
-----------------------------------------------------------
INT 2F - Multiplexor - Network - INSTALLATION CHECK
 AX = B800h
Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - Network - GET CURRENT POST ADDRESS
 AX = B803h
Return: ES:BX = post address
-----------------------------------------------------------
INT 2F - Multiplexor - Network - SET NEW POST ADDRESS
 AX = B804h
 ES:BX = new post address
-----------------------------------------------------------
INT 2F - Multiplexor - Network - VERSION CHECK
 AX = B809h
 ???
-----------------------------------------------------------
INT 30 -> (NOT A VECTOR!) FAR JuMP instruction for CP/M-style calls
INT 31
-----------------------------------------------------------
INT 32 -> not used
-----------------------------------------------------------
INT 33 - MS MOUSE - RESET DRIVER AND READ STATUS
 AX = 0000h
Return: AX = status
     0  hardware/driver not installed
     -1 hardware/driver installed
 BX = number of buttons
     -1 two buttons
     0  other than two
-----------------------------------------------------------
INT 33 - MS MOUSE - SHOW MOUSE CURSOR
 AX = 0001h
-----------------------------------------------------------
INT 33 - MS MOUSE - HIDE MOUSE CURSOR
 AX = 0002h
Note: multiple calls to hide the cursor will require multiple calls to
      function 01h to unhide it.
-----------------------------------------------------------
INT 33 - MS MOUSE - RETURN POSITION AND BUTTON STATUS
 AX = 0003h
Return: BX = button status
    bit 0  left button pressed if 1
    bit 1  right button pressed if 1
 CX = column
 DX = row
-----------------------------------------------------------
INT 33 - MS MOUSE - POSITION MOUSE CURSOR
 AX = 0004h
 CX = column
 DX = row
-----------------------------------------------------------
INT 33 - MS MOUSE - RETURN BUTTON PRESS DATA
 AX = 0005h
 BX = button
     0 left
     1 right
Return: AX = button states
     bit 0 left button pressed if 1
     bit 1 right button pressed if 1
 BX = number of times specified button has been pressed since last call
 CX = column at time specified button was last pressed
 DX = row at time specified button was last pressed
-----------------------------------------------------------
INT 33 - MS MOUSE - RETURN BUTTON RELEASE DATA
 AX = 0006h
 BX = button
     0 left
     1 right
Return: AX = button states
     bit 0 left button pressed if 1
     bit 1 right button pressed if 1
 BX = number of times specified button has been released since last call
 CX = column at time specified button was last released
 DX = row at time specified button was last released
-----------------------------------------------------------
INT 33 - MS MOUSE - DEFINE HORIZONTAL CURSOR RANGE
 AX = 0007h
 CX = minimum column
 DX = maximum column
-----------------------------------------------------------
INT 33 - MS MOUSE - DEFINE VERTICAL CURSOR RANGE
 AX = 0008h
 CX = minimum row
 DX = maximum row
-----------------------------------------------------------
INT 33 - MS MOUSE - DEFINE GRAPHICS CURSOR
 AX = 0009h
 BX = column of cursor hot spot in bitmap
 CX = row of cursor hot spot
 ES:DX = pointer to bitmap
  16 words, each defining the sixteen pixels of a row
  low bit of each word is rightmost in row
-----------------------------------------------------------
INT 33 - MS MOUSE - DEFINE TEXT CURSOR
 AX = 000Ah
 BX = hardware/software text cursor
     0 software
  CX = screen mask
  DX = cursor mask
     1 hardware
  CX = start scan line
  DX = end scan line
